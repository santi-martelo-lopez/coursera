!#############################################################
! List of subroutines
!#############################################################

!      SUBROUTINE IMB_INITIAL

! 				Subroutine for storing and initializing variables used in the Inmersed Boundary Method

!				Reads first the input file for the geometry defintion "geom.cin"
!				The geometry, the number of layers and number of iterations of the Multi-Direct Forcing method are defined here.




!       SUBROUTINE imb_alpha0	


!       SUBROUTINE PartLoc_Initial

! 				??? This subroutine asigns markers to domains and processors and allocate the Force variables used in the MPI scheme



!       SUBROUTINE IB_previous


!       SUBROUTINE IBM

! 				Subroutine for calculating the for F that the Lagrangian markers exert on the fluid cells
! 				Subroutine IBM is the main atribute controlling the algorithm for obtaining a velocity coreection due to the forces applied by the markers of the Immersed Boundaries


!       SUBROUTINE PartLoc

! 				This subroutine asigns markers to domains and processors 
!				Check: Seems to assign the Lagrangian Markers to subdomains


!       SUBROUTINE Deltah

!	Subroutine for finding out the number of neighbouring Eulerian fluid cells, computing the value of the interpolation function, either a delta function of a moving least square method



!      	SUBROUTINE imb_openmp

!			Subroutine for computing the felocity correction of the inmmersed boundary method and
!			computing the force that the boundary applies over the neighbouring eulerian fluid cells

!			This subroutine practicaly does all the heavy lifting




!	SUBROUTINE caldrag


!	SUBROUTINE imb_pressure


!	SUBROUTINE imb_FEM


!	SUBROUTINE imb_FEM_oneblade


!	SUBROUTINE imb_vel_to_zero


!	SUBROUTINE imb_averaging


!	SUBROUTINE move_ST

!		WARNING: check		subroutine that computes initial torque and angular acceleration of the turbine blades
!					when it statrs to move on its own due to drag and lift forces 	

!#############################################################
      SUBROUTINE IMB_INITIAL
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      DOUBLE PRECISION :: PI,revoltime,anst,iteratime
      INTEGER      :: L,I,M,strlen,maxn
      CHARACTER*8  :: char_block
      CHARACTER*31 :: gridfile
      CHARACTER*80 :: dummyline
        PI = 4.D0*DATAN(1.D0)
!        xt = 0.d0	; xdt = 0.d0	; xddt = 0.d0
!	  yt = 0.d0	; ydt = 0.d0	; yddt = 0.d0

	master=0 ! 0 is going to be always the master processor

       open (unit=1, file='geom.cin')
       read (1,*) dummyline
       read (1,*) ibm_out_forces
       read (1,*) yangcase
       read (1,*) mdfsteps
       read (1,*) bodynum

!Allocate variables that all MPI need to know:
       allocate(nodes(bodynum),rotating(bodynum),rads(bodynum))
	   ! ghost cell
        ibmSt_k = 1000
        allocate(ibmSt(bodynum))
        allocate(ibmStMkrs(ibmSt_k))
        allocate(ibmMkrsEL(ibmSt_k))
        ibmSt_k = -1
        ibmStMkrs = -1
        ibmMkrsEL = -1


	allocate(imb_shape(bodynum),imbnumber(bodynum))
	allocate(radsin(bodynum),filepoints(bodynum))
	allocate(turax(bodynum),reddelta(bodynum)) 
	allocate(ibturbine(bodynum)) 
	allocate(LSELFST(bodynum))			!Self-starting 07_2017
	nodes=0 	; rotating=.false. 	; rads=0.d0
	imb_shape=1	; imbnumber=1		; ibturbine=.false.
	radsin=0.d0	; turax =1			; reddelta=1.d0      
	LSELFST=.FALSE.	 !SET HERE IF SELF-STARTING (only for VATTs)	

	IF (myrank.ne.master) RETURN
!Allocate variables only needed by the master:
	allocate(Cx(bodynum),Cxor(bodynum),Cy(bodynum),Cyor(bodynum))
	allocate(Cz(bodynum),Czor(bodynum),pitch(bodynum))
	allocate(R(bodynum),l2norm(bodynum))	
	allocate(xaero(bodynum),yaero(bodynum),zaero(bodynum))
      allocate(cmax(bodynum),axis(bodynum),nscatter(bodynum))
	allocate(linfin(bodynum),zini(bodynum),zend(bodynum))        
      allocate(acc_ST(bodynum),SUMtorque_ST(bodynum)) 	!Self-starting 07_2017
	
	Cx=0.d0 	; Cxor=0.d0 ; Cy=0.d0 
	Cyor=0.d0 	; Cz=0.d0 	; Czor=0.d0 
	pitch=0.d0 	; R=0.d0 	; l2norm=0.d0 	
	xaero=0.d0 	; yaero=0.d0; zaero=0.d0
	cmax=1	; axis=1	; linfin=0.d0 ; zini=0.d0 ; zend=0.d0
	nscatter=0	; SUMtorque_ST =0.d0 ; acc_ST =0.d0

        DO M=1,bodynum
		read (1,*) dummyline 
		read (1,*) imb_shape(M)
		read (1,*) linfin(M),zini(M),zend(M)		
		read (1,*) Cx(M),Cy(M),Cz(M)
		read (1,*) R(M)
		read (1,*) cmax(M)
		read (1,*) axis(M)
		read (1,*) filepoints(M)
		read (1,*) rotating(M)
		read (1,*) reddelta(M)			
		read (1,*) dummyline  		!--- Turbine parameters: 
		read (1,*) ibturbine(M)				
		read (1,*) turax(M)				
		read (1,*) xaero(M),yaero(M),zaero(M)		
		read (1,*) pitch(M)		
		read (1,*) imbnumber(M)
		read (1,*) radsin(M)		

	   if(ibturbine(M).EQ..FALSE.) then
	    xaero(M)=0.d0 ; yaero(M)=0.d0 ; zaero(M)=0.d0 	
	    pitch(M)=0.d0 ; turax(M)=1    ; imbnumber(M)=1
	    LSELFST(M)=.false.
	   endif
	   if(turax(M).eq.2 ) then !HATT
	    xaero(M)=0.d0 ; yaero(M)=0.d0 ; zaero(M)=0.d0 		
	    pitch(M)=0.d0 ; imbnumber(M)=1 ; LSELFST(M)=.false.	
	   endif
	   if (rotating(M).eq..FALSE.) radsin(M)=0.d0
	   if (LSELFST(M).eq..TRUE.) radsin(M)=0.d0

!Actuator line:
	   if(ibturbine(M).EQ..true. .and. turax(M).eq.3 .and. M.eq.1) then
	    allocate(r_act(5000),c_act(5000),Pit_act(5000))
	    r_act=0.d0 ; c_act=0.d0 ;Pit_act=0.d0 
	   endif
!Write possible combinations of movements/body types that doesn't work
      End do !M
      close (1)
	WRITE(6,*)' '
	WRITE(6,*)'===========  Immersed Boundary Details  =========='

!CALCULATE TO WHICH BLOCK IS THE CENTRE OF THE BODIES

	 maxn=1999000	!maximum number of Lagrangian allowed

       allocate (nodex(bodynum,maxn),nodexlocal(bodynum,maxn))
	 allocate (nodey(bodynum,maxn),nodeylocal(bodynum,maxn))
	 allocate (nodez(bodynum,maxn),nodezlocal(bodynum,maxn))

      nodex = 0.d0	; nodey = 0.d0 	  ; nodez = 0.d0  
      nodexlocal = 0.d0	; nodeylocal = 0.d0 ; nodezlocal = 0.d0 
	maxnodeIBS=0

	
      dxm=g_dx/rdivmax ; dym=g_dy/rdivmax ; dzm=g_dz/rdivmax	!Minimum grid sizes
	 
	write(6,*)'Largest rdivmax  :',rdivmax	
	write(6,'(a,3e12.4)')'Smallest gridsize: ',dxm,dym,dzm	 
		
	Do M=1,bodynum
        IF (imb_shape(M).eq.1) call imb_square(M)
        IF (imb_shape(M).eq.2) call imb_cylinder(M)
        IF (imb_shape(M).eq.3) call imb_cube(M)
	IF (imb_shape(M).eq.4) call imb_sphere(M)
        IF (imb_shape(M).eq.11)call imb_cone(M)
        IF (imb_shape(M).eq.12)call imb_dune(M)
        IF (imb_shape(M).eq.13)call imb_hemisphere(M)
 	IF (imb_shape(M).eq.5 .and. turax(M).le.2) call imb_file(M)		!07_2017
 	IF (imb_shape(M).eq.5 .and. turax(M).eq.3) call act_line_geom(M)
! 	  IF (imb_shape(M).eq.5 .and. turax(M).eq.4) call imb_actuator_surf(M)
   	maxnodeIBS=maxnodeIBS+nodes(M)
	IF (maxnodeIBS.gt.maxn)
     & write(6,*)'Too many ib points, change maxn in imb.for'
	IF (maxnodeIBS.gt.maxn) STOP
	Enddo
	

!The velocity and force vectors/matrix are allocated:
      allocate (U_Beta1(bodynum,maxnodeIBS),U_Beta2(bodynum,maxnodeIBS))
      allocate (U_Beta3(bodynum,maxnodeIBS),imb_block(maxnodeIBS))
      allocate (alpha0(bodynum,maxnodeIBS),R0(bodynum,maxnodeIBS))
!Initiate all these variables:
	U_Beta1=0.d0  ; U_Beta2=0.d0  ; U_Beta3=0.d0
	R0=0.d0       ; alpha0=0.d0	  ; imb_block=0

	if (myrank.eq.master) then
       allocate (FX1(bodynum,maxnodeIBS)) ; FX1=0.D0 
       allocate (FX2(bodynum,maxnodeIBS)) ; FX2=0.D0 
       allocate (FX3(bodynum,maxnodeIBS)) ; FX3=0.D0 
       allocate (FX1M(bodynum,maxnodeIBS)) ; FX1M=0.D0 
       allocate (FX2M(bodynum,maxnodeIBS)) ; FX2M=0.D0 
       allocate (FX3M(bodynum,maxnodeIBS)) ; FX3M=0.D0 
	endif
!Local angle and radius:
	 call imb_alpha0	

	if (ibm_out_forces.eq.1) then
!CREATE OUTPUT FILES FOR THE IMMERSED BOUNDARIES:
	L=0
	DO M=1,bodynum
	 DO i=1,imbnumber(M)
             L=L+1 ; forcefilej=399+L
	 IF (ibturbine(M).eq..true.) then !Rotating VATT
         write(char_block,'(i2)') L
         strlen=LEN(TRIM(ADJUSTL(char_block)))
         char_block=REPEAT('0',(2-strlen))//TRIM(ADJUSTL(char_block))
         gridfile='F_Blade_'//TRIM(ADJUSTL(char_block))//'.dat'
         open (unit=forcefilej, file=gridfile, status="unknown",
     &	action="write")
	if (turax(M).eq.1) then
         write (forcefilej,*)'Variables=Deg,Fx,Fy,T1,T2,N1,N2,M'
	else if (turax(M).eq.2) then
         write (forcefilej,*)'Variables=Deg,Fx,Fy,Fz,Ft'
	else if (turax(M).eq.3) then
         write (forcefilej,*)'Variables=Deg,Cx,Cp'
	   goto 363
	endif
	     IF(I.EQ.1) then
		lambda=radsin(M)*R(M)/ubulk
		sigma=imbnumber(M)*1.d0/(R(M)*2*PI)
		revoltime=2.d0*PI/radsin(M)
		anst=radsin(M)*dt*180.0/PI
		iteratime=(360.d0/anst)
	write(6,*)'     '	
	write(6,'(a,i2,a)')   ' ****** Turbine   ',M,'rotating details,'
	write(6,'(a,f12.4)')  '        TSR     : ',lambda
	write(6,'(a,f12.4,a)')'        Solidity: ',sigma*100,' %'
	write(6,'(a,f12.4,a)')'Time per revolut: ',revoltime,' sec'
	write(6,'(a,f12.4,a)')'Iter per revolut: ',iteratime,' it'
	write(6,'(a,f12.4,a)')'     Angle step : ',anst,'deg/iteration'
	    ENDIF
	  ENDIF
	 IF(LSELFST(M).eq..true.) then
	   forcefilej=5452+M
         write(char_block,'(i2)') M
         strlen=LEN(TRIM(ADJUSTL(char_block)))
         char_block=REPEAT('0',(2-strlen))//TRIM(ADJUSTL(char_block))
         gridfile='ST_VATT_'//TRIM(ADJUSTL(char_block))//'.dat'
         open (unit=forcefilej, file=gridfile, status="unknown",
     &	action="write")
         write (forcefilej,*)'Variables=CTIME,Accel,Vel,Rads,Torque'
	 ENDIF !TURBINE
363	CONTINUE	!09-2017

	 IF (ibturbine(M).eq..false. .and. rotating(L).eq..false. ) then !Rotating VATT
         write(char_block,'(i2)') L
         strlen=LEN(TRIM(ADJUSTL(char_block)))
         char_block=REPEAT('0',(2-strlen))//TRIM(ADJUSTL(char_block))
         if(imb_shape(M).eq.1) then
         gridfile='F_Squ_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif        
         if(imb_shape(M).eq.2) then
         gridfile='F_Cyl_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif
         if(imb_shape(M).eq.3) then
         gridfile='F_Cub_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif
         if(imb_shape(M).eq.4) then
         gridfile='F_Sph_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif     
         if(imb_shape(M).eq.5 .and. rotating(L).eq..false.) then
         gridfile='F_Bod_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif 	      
         if(imb_shape(M).ge.11) then
		 gridfile='F_Con_'//TRIM(ADJUSTL(char_block))//'.dat'
     	 endif 

	    open (unit=forcefilej, file=gridfile)
           write (forcefilej,*)'Variables=CTIME,Fx,Fy,Fz'
	 ENDIF

	! ! File for keeping track of the forces at play in the ghost cell method
	! gridfile = 'F_gh_'//TRIM(ADJUSTL(char_block))//'.dat'
	! forcefilegh = 31
	! open (unit=forcefilegh, file=gridfile)
	! write (forcefilegh,*)'Variables=CTIME,Fx,Fy,Fz'


        if(imb_shape(M).eq.5 .and. ibturbine(M).eq..false.) then
	   if(rotating(L).eq..true.) then
           write(char_block,'(i2)') L
           strlen=LEN(TRIM(ADJUSTL(char_block)))
           char_block=REPEAT('0',(2-strlen))//TRIM(ADJUSTL(char_block))
           gridfile='F_Body_'//TRIM(ADJUSTL(char_block))//'.dat'
           open (unit=forcefilej, file=gridfile)
           write (forcefilej,*)'TITLE = Times series of ST analysis'
           write (forcefilej,*)'Variables=Deg,Fx,Fy,Fz,Ft'
	    endif
     	   endif       
    
	 Enddo !i

	ENDDO !M

	open (unit=757, file= 'l2norm.dat')
	write(757,*)'Variables=Ctime,l2-norm,l1norm-U,l1norm-V'
	WRITE(6,*)' '
	WRITE(6,*)'Total # of IB POINTS.........',maxnodeIBS
	WRITE(6,*)' '

	endif !If the IBM force output

      RETURN
      end
!#############################################################
      SUBROUTINE imb_alpha0	
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      INTEGER  :: M,L,iii,K,strlen
      DOUBLE PRECISION :: PI
      CHARACTER*8  :: char_block2
      CHARACTER*31 :: gridfile

       PI = 4.D0*DATAN(1.D0)
      
	Do M=1,bodynum

	IF(imb_shape(M).eq.5) then

!!!! TURBINES  !!!!!!!!!!
        write(char_block2,'(I3)') M
         strlen=LEN(TRIM(ADJUSTL(char_block2)))
         char_block2=REPEAT('0',(3-strlen))//TRIM(ADJUSTL(char_block2))
         gridfile='g_angles_'//TRIM(ADJUSTL(char_block2))//'.dat'
         open (unit=2, file=gridfile)
	write(2,*)'variables=x,y,z,al0,R0'

	 if(ibturbine(M).eq..false.) then  !Not a turbine

           do L=1,nodes(M)    			!!!!!assumed z-axis...
            alpha0(M,L)=datan(nodexlocal(M,L)/nodeylocal(M,L))
            R0(M,L)=dsqrt(nodexlocal(M,L)**2+nodeylocal(M,L)**2)
         if(nodexlocal(M,L).gt.0.d0 .and. nodeylocal(M,L).gt.0.d0)then !1st quarter. Alpha>0
          alpha0(M,L)=alpha0(M,L)
         endif
         if(nodexlocal(M,L).le.0.d0 .and. nodeylocal(M,L).ge.0.d0)then !2nd quarter. Alpha<0
          alpha0(M,L)=2*PI+alpha0(M,L)
         endif 
         if(nodexlocal(M,L).lt.0.d0 .and. nodeylocal(M,L).lt.0.d0)then !3rd quarter. Alpha>0 
          alpha0(M,L)=PI+alpha0(M,L)
         endif 
         if(nodexlocal(M,L).gt.0.d0 .and. nodeylocal(M,L).lt.0.d0)then !4th quarter. Alpha>0
          alpha0(M,L)=PI+alpha0(M,L)
         endif
            enddo

	 else


	IF (turax(M).eq.1) then		! Vertical Axis Turbine
	   K=nodes(M)/imbnumber(M)
          do L=1,K 
          alpha0(M,L)=-datan(nodexlocal(M,L)/(nodeylocal(M,L)+R(M))) !!!!!!!! 30 Aug Pablo
          R0(M,L)=dsqrt((nodexlocal(M,L))**2+(nodeylocal(M,L)+R(M))**2)
          enddo
          Do iii=1,imbnumber(M)-1
           do L=1,K
             alpha0(M,L+K*iii)=(2.D0*PI/imbnumber(M))*iii+alpha0(M,L)
	 if(alpha0(M,L+K*iii).gt.2.d0*PI) 
     &	 alpha0(M,L+K*iii)=alpha0(M,L+K*iii)-2.d0*PI
             R0(M,L+K*iii)= R0(M,L)
           enddo
          Enddo
        ENDIF

	IF (turax(M).eq.2) then	! Horizontal Axis Turbine
          do L=1,nodes(M) 
          alpha0(M,L)=datan(nodeylocal(M,L)/(nodezlocal(M,L)))
          if(nodeylocal(M,L).ge.0.d0 .and. nodezlocal(M,L).ge.0.d0) then !1st quarter. Alpha>0
         	alpha0(M,L)=alpha0(M,L)
          endif           
          if(nodeylocal(M,L).lt.0.d0 .and. nodezlocal(M,L).gt.0.d0) then !2nd quarter. Alpha<0
          	alpha0(M,L)=2.D0*PI+alpha0(M,L)
          endif 
          if(nodeylocal(M,L).lt.0.d0 .and. nodezlocal(M,L).lt.0.d0) then !3rd quarter. Alpha>0
         	 alpha0(M,L)=PI+alpha0(M,L)
          endif
          if(nodeylocal(M,L).gt.0.d0 .and. nodezlocal(M,L).lt.0.d0) then !4th quarter. Alpha<0
          	alpha0(M,L)=PI+alpha0(M,L)
          endif
          R0(M,L)=dsqrt((nodeylocal(M,L))**2+(nodezlocal(M,L))**2)                               
          enddo
        ENDIF


	IF (turax(M).eq.3) then		! ACTUATOR LINE
	   K=nodes(M)/imbnumber(M)
          do L=1,K 
          alpha0(M,L)=0.d0
          R0(M,L)=r_act(L)
          enddo
          Do iii=1,imbnumber(M)-1
           do L=1,K
             alpha0(M,L+K*iii)=(2.D0*PI/imbnumber(M))*iii+alpha0(M,L)
	    if(alpha0(M,L+K*iii).gt.2.d0*PI) 
     &	 alpha0(M,L+K*iii)=alpha0(M,L+K*iii)-2.d0*PI
             R0(M,L+K*iii)= R0(M,L)
           enddo
          Enddo
        ENDIF
                 
	 endif

         do L=1,nodes(M)
	    write(2,'(5f12.6)')nodex(M,L),nodey(M,L),nodez(M,L)
     &		,alpha0(M,L)*180/3.1416,R0(M,L)
	   enddo
       close(2)

	endif

	Enddo ! M

   88 FORMAT (i5)
   89 FORMAT (5f12.5)
        RETURN
        END SUBROUTINE
!######################################################################
      SUBROUTINE PartLoc_Initial
!######################################################################
      use vars
      use imb
      use mpi
      use multidata
      implicit none
	INTEGER :: K,L,N,numIBslv

       call MPI_BCAST(maxnodeIBS,1,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!Total # IB points
       call MPI_BCAST(nodes,bodynum,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# IB points of each body
       call MPI_BCAST(imb_shape,bodynum,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!IB shape of each body
       call MPI_BCAST(imbnumber,bodynum,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# IB bodies of each body
       call MPI_BCAST(turax,bodynum,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# axis of rotation for turbines     
       call MPI_BCAST(reddelta,bodynum,MPI_DOUBLE_PRECISION,
     &  master,MPI_COMM_WORLD,ierr) 	!Reduction factor
       call MPI_BCAST(radsin,bodynum,MPI_DOUBLE_PRECISION,
     &  master,MPI_COMM_WORLD,ierr)		!Rotational velocity of each IB body
       call MPI_BCAST(rotating,bodynum,MPI_LOGICAL,
     &  master,MPI_COMM_WORLD,ierr)		!If the body rotates
       call MPI_BCAST(ibturbine,bodynum,MPI_LOGICAL,
     &  master,MPI_COMM_WORLD,ierr)		!If the body is a turbine
		call MPI_BARRIER(MPI_COMM_WORLD,ierr)

		! Ghost Cell
       call MPI_BCAST(tf1,3,MPI_DOUBLE_PRECISION,
     &  master,MPI_COMM_WORLD,ierr) 	!Total Force
       call MPI_BCAST(p1,3,MPI_DOUBLE_PRECISION,
     &  master,MPI_COMM_WORLD,ierr) 	!Total Pressure Force 
       call MPI_BCAST(sh1,3,MPI_DOUBLE_PRECISION,
     &  master,MPI_COMM_WORLD,ierr) 	!Total Shear Stress Force


	nIBslv=maxnodeIBS

!Now each processor will store the # of markers assigned (nIBslv)		
      allocate (kmaxU(nIBslv),kmaxV(nIBslv),kmaxW(nIBslv))
      allocate (nodex_loc(nIBslv),U_Beta1_loc(nIBslv),FX1_loc(nIBslv))
      allocate (nodey_loc(nIBslv),U_Beta2_loc(nIBslv),FX2_loc(nIBslv))
      allocate (nodez_loc(nIBslv),U_Beta3_loc(nIBslv),FX3_loc(nIBslv))
      allocate (alpha0_loc(maxnodeIBS),R0_loc(maxnodeIBS))
	allocate (imb_block_loc(maxnodeIBS),lag_bod_loc(maxnodeIBS))
	allocate (imbinblock_loc(num_domains),rott_loc(maxnodeIBS))
      allocate (FX1NF(nIBslv),FX2NF(nIBslv),FX3NF(nIBslv))

	  kmaxU=0 		 ; kmaxV=0 			; kmaxW=0	         		  
	  nodex_loc=0.d0 	 ; nodey_loc=0.d0 	; nodez_loc=0.d0 
	  U_Beta1_loc=0.d0 ; U_Beta2_loc =0.d0 	; U_Beta3_loc =0.d0 
	  FX1_loc =0.d0    ; FX2_loc =0.d0    	; FX3_loc =0.d0 
	  imbinblock_loc=0 ; imb_block_loc=0  	; lag_bod_loc = 0
 	  alpha0_loc =0.d0 ; R0_loc =0.d0 		; rott_loc=2
	  FX1NF=0.D0	 ; FX2NF=0.D0		; FX3NF=0.D0
								
!nxl is the length of the kernel used for the delta functions. 
!nl is the number of neighbours considered
	if (yangcase.eq.2 .or. yangcase.eq.4.or. yangcase.eq.7) then
	 nxl=2.499999d0 	; nl=125
	 deps = 3
	endif
	if (yangcase.eq.3 .or. yangcase.eq.6) then
	 nxl=1.999999d0  	; nl=64 
	 deps = 2
	endif
	if (yangcase.eq.1 .or. yangcase.eq.5) then
	 nxl=1.499999d0  	; nl=27
	 deps = 1
	endif

       allocate (dh1_loc(nIBslv,nl),dh2_loc(nIBslv,nl))
       allocate (dh3_loc(nIBslv,nl))
	 allocate (I_nr_U(nIBslv,nl),J_nr_U(nIBslv,nl))
	 allocate (I_nr_V(nIBslv,nl),J_nr_V(nIBslv,nl))
	 allocate (I_nr_W(nIBslv,nl),J_nr_W(nIBslv,nl))
	 allocate (K_nr_U(nIBslv,nl),K_nr_V(nIBslv,nl))
	 allocate (K_nr_W(nIBslv,nl))

	  dh1_loc=0.d0	; dh2_loc=0.d0	; dh3_loc=0.d0
	  I_nr_U=0		; J_nr_u=0 		; K_nr_U=0
	  I_nr_V=0 		; J_nr_V=0 		; K_nr_V=0
	  I_nr_W=0 		; J_nr_W=0 		; K_nr_W=0
                                         
	RETURN
	END
!######################################################################
      SUBROUTINE  gh_initial_geomtry
!######################################################################
		! This subroutine broacast to the processors the charateristi feature of the 
		! geometry of the inmmersed body:
		! ibmStMkrs	: markers per stations:
		! ibmMkrsEL : markers in the exterior layer of each station
		! ibmSt  	: number of station in each inmmersed body
		! ibmSt_k	: total number of stations 
		!
      use vars
      use imb
      use mpi
      use multidata
      implicit none

       call MPI_BCAST(ibmSt_k,1,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!Total # Stations in the immersed bodies
       call MPI_BCAST(ibmSt,bodynum,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# Stations of each body
     									 ! for each postion, it stores the number of stations defined in each body
      call MPI_BCAST(ibmStMkrs,ibmSt_k,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# IB points is each station of each body,
     									 ! for each postion jj, it stores the number of markers in station jj
      call MPI_BCAST(ibmMkrsEL,ibmSt_k,MPI_INTEGER,
     &  master,MPI_COMM_WORLD,ierr)		!# IB points in the exterior layer in each station of each body

	! debug
	 ! if(myrank.ne.master) then
	!	write(*,*) "iiiiiiiiiiiiiiiiiiiiiiiiiiiii",ibmSt_k
	!	write(*,*) "iiiiiiiiiiiiiiiiiiiiiiiiiiiii",ibmSt(bodynum)
	!	write(*,*) "iiiiiiiiiiiiiiiiiiiiiiiiiiiii",ibmStMkrs(ibmSt_k)
	!	write(*,*) "iiiiiiiiiiiiiiiiiiiiiiiiiiiii",ibmMkrsEL(ibmSt_k)
	! endif

 !######################################################################
      END
 !######################################################################



!######################################################################
      SUBROUTINE IB_previous
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      INTEGER :: K
	Do K=1,bodynum

!Distribute properties of the actuator line turbines
	if(itime.eq.itime_start .AND. 
     &	    imb_shape(K).eq.5 .and. turax(K).eq.3) then
		 CALL ActuatorLine_Initial			!Turbine via Actuator Line model
		 write(*,*) "Turbine via Actuator Line model"
	endif

	 IF (imb_shape(K).eq.5 .and. rotating(K).eq..TRUE.) then
	   if(ibturbine(K).eq..true.) then
	      IF(LSELFST(K)) then
			call move_ST ! 					!Self-starting 07_2017
			write(*,*) "!Self-starting 07_2017"
		ELSE
			rads(K)=radsin(K)*CTIME			!Prescribed rotational speed
			write(*,*) "Prescribed rotational speed: ", rads(K)
		ENDIF
	   else
			rads(K)=-radsin(K)*3.1416D0/180.D0*DSIN(0.1983*CTIME)	!Pitching airfoil case
			write(*,*) "Pitching airfoil case: ", rads(K)
	   endif
		 call imb_moved(K) 		 		!In shapes.for
		 write(*,*) "imb_moved(K)"
	   if(ibturbine(K).eq..true. .and. turax(K).eq.1)
     &	 call imb_moved_shades(K)  			 !In shapes.for
	   write(*,*) "imb_moved_shades(K)"
	 ENDIF
	 !
	 !
	 !
	 ! oscilating cylinder for testing the ghostcell method
	    if(rotating(K).eq..TRUE.) then
		  ! VERICALLY OSCILLATING CYLINDER
	      transverseFlag = 1
	      if (transverseFlag .eq. 1) then	! from
	      	call imb_oscillating_cylinder(K)	!In shapes.for
	      endif
	    endif
	 !
	 Enddo
	 !
		Call PartLoc  					!Asign markers to domains and processors 
		! if (itime.eq.itime_start)   	call imb_vel_to_zero
	!
	!
	IF(itime.eq.itime_start) then				!Generate delta func for steady bodies
	 if(myrank.eq.master)write(6,*)'Delta functions initiating'
	   Call Deltah 
	 if(myrank.eq.master)write(6,*)'Delta functions generated'
	ENDIF
	!
      END SUBROUTINE
!
!######################################################################
      SUBROUTINE IBM
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      INTEGER :: NF,M,L,N
!call exchange subroutines to fill the ghost cells with Ustar values
	call exchange(11) ; call exchange(22) ; call exchange(33)

	 FX1NF=0.d0;FX2NF=0.d0;FX3NF=0.d0

	!DO NF =1,mdfsteps+1	!MDF loops. +1 as the default loop for IB is 0 MDF loops
	  !call imb_openmp
	!  rott_loc=2 !This is set to avoid to calculate dh again when NF>1
	 ! call ghostCell2(1)
	!ENDDO

	  ! Setting USTAR, VSTAR, WSTAR to 0 in the cells containing markers after 
	  ! applying the velocity correction due to the inmersed bounday effect at the end of imb_openmp
!	  call Zero_U_V_W_STAR(NF) 	

!		call imb_averaging !Calculate mean IB force values
	if (mod(itime,2) .eq. 0 .and. ibm_out_forces.eq.1) then
		call caldrag	!Output of IB forces
		if(ibturbine(1).eq. .TRUE. .and. turax(1).eq.2) then
		 call imb_FEM		!Structural loadings of all blades
		 call imb_FEM_oneblade !Structural loadings for a single blade divided into sections
	      endif
	endif

      if (mod(itime,n_out).eq.0) call imb_pressure		!returns coordinates and forces of markers every nout 
!update the velocities at the ghost cell values	
	call exchange(11) ; call exchange(22) ; call exchange(33)
      END SUBROUTINE

!######################################################################
	SUBROUTINE ghostCell(flag1)
!######################################################################

        use imb
        use mpi
	    use multidata
        use vars
		
        implicit none


	  INTEGER, INTENT(IN):: flag1
	  
		  ! definition of iterators
	  INTEGER :: ib,iii,jjj,kkk,nn,ll,M,qF
	  INTEGER :: iic, jjc, kkc, ii, jj, kk
	  ! ib: index for subdomain,
	  ! iii : index for cells along the OX direction
	  ! jjj : index for cells along the OX direction
	  ! kkk : index for cells along the OX direction	
	  ! mm :
	  ! nn : index for nodes belonging to the M-th mody
	  !
	  ! Intefece with function interpolationF
	  INTEGER ::vec2(8)
	  DOUBLE PRECISION :: vec3(3)
	  DOUBLE PRECISION :: mirror_u,mirror_w,mirror_p, k
	  !
	  INTEGER :: is,ie,js,je,ks,ke
	  INTEGER :: i_n_cells ,j_n_cells,k_n_cells
	  !
	  ! dh : equivalent grid spacing in 3D
	  ! margin: Boundary Margings
	  !
	  ! Inteface variables with the marked cells
	  INTEGER :: gcumi,gcwmi,gcpmi
	  INTEGER :: gcumj,gcwmj,gcpmj
	  INTEGER :: gcumk,gcwmk,gcpmk
	  DOUBLE PRECISION :: gcumx,gcux,gcwmx,gcwx,gcpmx,gcpx
	  DOUBLE PRECISION :: gcumy,gcuy,gcwmy,gcwy,gcpmy,gcpy
	  DOUBLE PRECISION :: gcumz,gcuz,gcwmz,gcwz,gcpmz,gcpz
	  !
	  ! Intefece with bilinear_cramer
	  DOUBLE PRECISION :: pvec(4),nx(2),nz(2),mrx,mrz
	  INTEGER :: id,kd
	  !
	  !
	do ib = 1, nbp ! lets sweep only the subdomains with makers

	  !if (myrank.eq.0) then ! The control is passed down to the master processor

	if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
												! markers are located
		i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
		j_n_cells = dom(ib)%ttc_j
		k_n_cells = dom(ib)%ttc_k

			if (flag1.eq.1) then
			do kk=1,dom(ib)%ttc_k
			do ii=1,dom(ib)%ttc_i
			do jj=1,dom(ib)%ttc_j
			   	dom(ib)%ucpy(ii,jj,kk)=dom(ib)%ustar(ii,jj,kk)
			   	dom(ib)%vcpy(ii,jj,kk)=dom(ib)%vstar(ii,jj,kk)
			   	dom(ib)%wcpy(ii,jj,kk)=dom(ib)%wstar(ii,jj,kk)
			enddo
			enddo
			enddo
			elseif(flag1.eq.2) then
			do kk=1,dom(ib)%ttc_k
			do ii=1,dom(ib)%ttc_i
			do jj=1,dom(ib)%ttc_j
				dom(ib)%ucpy(ii,jj,kk)=dom(ib)%u(ii,jj,kk)
				dom(ib)%vcpy(ii,jj,kk)=dom(ib)%v(ii,jj,kk)
				dom(ib)%wcpy(ii,jj,kk)=dom(ib)%w(ii,jj,kk)
				dom(ib)%pcpy(ii,jj,kk)=dom(ib)%p(ii,jj,kk)
			enddo
			enddo
			enddo
			elseif(flag1.eq.0) then ! CKECK_AAA
			do kk=1,dom(ib)%ttc_k
			do ii=1,dom(ib)%ttc_i
			do jj=1,dom(ib)%ttc_j
				dom(ib)%ucpy(ii,jj,kk)=dom(ib)%uoo(ii,jj,kk)
				dom(ib)%vcpy(ii,jj,kk)=dom(ib)%voo(ii,jj,kk)
				dom(ib)%wcpy(ii,jj,kk)=dom(ib)%woo(ii,jj,kk)
				dom(ib)%pcpy(ii,jj,kk)=dom(ib)%p(ii,jj,kk)
			enddo
			enddo
			enddo
	 		endif
		!
		!
		! ghost cell method
		! Initiallizing current cell flags for the fluid cells currently inside the inmersed body
          do kk=1,dom(ib)%ttc_k
          do ii=1,dom(ib)%ttc_i
	      do jj=1,dom(ib)%ttc_j
		    if(dom(ib)%mucx(ii,jj,kk).ne.0)then ! ghost cell treatment for the u velocity field
			    nn = dom(ib)%mucxnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
			    if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 !                                 
				 !ib = dom(ib)%mucxib(ii,jj,kk)  ! ll    if for layer at which nn marker is located
				 ll = dom(ib)%mucxll(ii,jj,kk)  ! ib 
				 if(ll.eq.1)then
				 iii = dom(ib)%mucxi(ii,jj,kk)  ! iii   ox location of the u ghost cell centre 
				 jjc = dom(ib)%mucxj(ii,jj,kk)  ! jjc   oy location of the u ghost cell centre
				 kkk = dom(ib)%mucxk(ii,jj,kk)  ! kkk   oy location of the u ghost cell centre
				 qF = dom(ib)%mucx(ii,jj,kk)	  ! qf 
				 M = lag_bod_loc(nn)
				 !                                 
				 gcux  = dom(ib)%mucxx(ii,jj,kk) ! ox location of the u ghost cell  centre
				 gcuy  = dom(ib)%mucxy(ii,jj,kk) ! oy location of the u ghost cell centre
				 gcuz  = dom(ib)%mucxz(ii,jj,kk) ! oy location of the u ghost cell centre
				 !                                 
				 gcumx = dom(ib)%mucxmx(ii,jj,kk) ! ox location of the u mirror point in fluid cell
				 gcumy = dom(ib)%mucxmy(ii,jj,kk) ! oy location of the u mirror point in fluid cell
				 gcumz = dom(ib)%mucxmz(ii,jj,kk) ! oy location of the u mirror point in fluid cell
				 !                                 
				 gcumi = dom(ib)%mucxmi(ii,jj,kk) ! dom(ib)%x id of the u mirror point in fluid cell
				 if (gcumi.eq.0) then
					write(*,*) "warning warning warning, gcumi = 0"
				 endif
				 gcumj = dom(ib)%mucxmj(ii,jj,kk) ! dom(ib)%y id of the u mirror point in fluid cell
				 if (gcumj.eq.0) then
					write(*,*) "warning warning warning, gcumj = 0"
				 endif
				 gcumk = dom(ib)%mucxmk(ii,jj,kk) ! dom(ib)%z id of the u mirror point in fluid cell
				 if (gcumk.eq.0) then
					write(*,*) "warning warning warning, gcumk = 0"
				 endif
				 !                                 
			     !deltaFUnction
			     vec2(1) = nn ! nn	! Node nds(1.5)
			     vec2(2) = ib ! ib 
			     vec2(3) = ll ! ll
			     vec2(4) = gcumi ! id 
			     vec2(5) = gcumj ! jjj
			     vec2(6) = gcumk ! kd
			     vec2(7) = qF ! qF
			     vec2(8) = 1 ! 1 ! fieldFlag for selecting u velocity
			     vec3(1) = gcumx !mrx
			     vec3(2) = gcumy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			     vec3(3) = gcumz !mrz
			     call interpolationF(vec2,vec3,mirror_u)
				 !
				 ! debug
	   			 !	if((nn.gt.9240).and.(nn.lt.(9240+126))) then
	   			 !	write(*,*) "================================="
	   			 !	write(6,*) vec2
				 !	   write(6,*) vec3
	   			 !	write(6,*) gcumy,dom(ib)%mucxmy(ii,jj,kk)
	   			 !	write(6,*) myrank
	   			 !	endif
				 !
				 !if (rott_loc(nn).eq.1) then
			     if(rotating(M).eq..FALSE.) then
			     	k = - mirror_u
			     	!k = -1.0d00	
			     !elseif (rott_loc(nn).eq.2) then
			     elseif(rotating(M).eq..TRUE.) then
					 k = 2*U_p - mirror_u  ! moving body
					 !k = -1.0d00
				 endif
				 elseif(ll.eq.2)then
					k = 0.0d00
				 endif
				 !
				 if(flag1.eq.0) dom(ib)%uoo(iii,jjc,kkk) = k
				 if(flag1.eq.1) dom(ib)%ustar(iii,jjc,kkk) = k
				 if(flag1.eq.2) dom(ib)%u(iii,jjc,kkk) = k
				 !
				 !debug
				  !if(flag1.eq.1) then
				  !if((nn.gt.9240).and.(nn.lt.(9240+126))) then
				  !    !	write(6,*) nn, k ,rott_loc(nn)
				  !  	write(*,*) "USTAR___USTAR___USTAR___USTAR"
				  !		write(6,*) nn, iii,jjj,kkk
				  !		write(6,*) dom(ib)%mucx(iii,jjc,kkk),qF
				  !		write(6,*) dom(ib)%ustar(iii,jjc,kkk)
				  !	!write(6,*) qF, fieldF, fieldVal
				  !	!write(6,*) vec2(1),vec2(2),vec2(3)
				  !	!write(6,*) vec2(4),vec2(5),vec2(6)
				  !	!write(6,*) vec2(7),vec2(8)
				  !	!write(6,*) vec3(1),vec3(2),vec3(3)
				  !	!write(6,*) "======================="
			      ! endif
			      ! endif
			      ! if(flag1.eq.2) then
				  ! if((nn.gt.9240).and.(nn.lt.(9240+126))) then
				  !    !	write(6,*) nn, k ,rott_loc(nn)
				  !  	write(*,*) "U_____U_____U_____U_____U_____U"
				  !		write(6,*) nn, iii,jjj,kkk
				  !		write(6,*) dom(ib)%mucx(iii,jjc,kkk),qF
				  !		write(6,*) dom(ib)%u(iii,jjc,kkk)
				  !	!write(6,*) qF, fieldF, fieldVal
				  !	!write(6,*) vec2(1),vec2(2),vec2(3)
				  !	!write(6,*) vec2(4),vec2(5),vec2(6)
				  !	!write(6,*) vec2(7),vec2(8)
				  !	!write(6,*) vec3(1),vec3(2),vec3(3)
				  !	!write(6,*) "======================="
			      !endif
			      !endif
                endif   ! Ensuring processor ID matches subdomain ID???
				!
			endif ! ghost cell treatment for the u velocity field
			!
			if(dom(ib)%mwcz(ii,jj,kk).ne.0)then ! ghost cell treatment for the w velocity field
				nn = dom(ib)%mwcznn(ii,jj,kk)  ! nn    id for IB point or marker 
				!
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 !
				 !ib = dom(ib)%mwczib(ii,jj,kk)  ! ib    if for layer at which nn marker is located
				 ll = dom(ib)%mwczll(ii,jj,kk)  ! ll
				 if(ll.eq.1)then
				 iic = dom(ib)%mwczi(ii,jj,kk)  ! iii   ox location of the w ghost cell  centre
				 jjc = dom(ib)%mwczj(ii,jj,kk)  ! jjc   oy location of the w ghost cell centre
				 kkk = dom(ib)%mwczk(ii,jj,kk)  ! kkk   oy location of the w ghost cell centre
				 qF = dom(ib)%mwcz(ii,jj,kk)	  ! qf 
				 M = lag_bod_loc(nn)
				 !                                  
				 gcwx  = dom(ib)%mwczx(ii,jj,kk) ! ox location of the w ghost cell  centre
				 gcwy  = dom(ib)%mwczy(ii,jj,kk) ! oy location of the w ghost cell centre
				 gcwz  = dom(ib)%mwczz(ii,jj,kk) ! oy location of the w ghost cell centre
				 !                                 
				 gcwmx = dom(ib)%mwczmx(ii,jj,kk) ! ox location of the w mirror point in fluid cell
				 gcwmy = dom(ib)%mwczmy(ii,jj,kk) ! oy location of the w mirror point in fluid cell
				 gcwmz = dom(ib)%mwczmz(ii,jj,kk) ! oy location of the w mirror point in fluid cell
				 !                                 
				 gcwmi = dom(ib)%mwczmi(ii,jj,kk) ! dom(ib)%x id of the w mirror point in fluid cell
				 if (gcwmi.eq.0) then
					write(*,*) "warning warning warning, gcwmi = 0"
				 endif
				 gcwmj = dom(ib)%mwczmj(ii,jj,kk) ! dom(ib)%y id of the w mirror point in fluid cell
				 if (gcwmj.eq.0) then
					write(*,*) "warning warning warning, gcwmj = 0"
				 endif
				 gcwmk = dom(ib)%mwczmk(ii,jj,kk) ! dom(ib)%z id of the w mirror point in fluid cell
				 if (gcwmk.eq.0) then
					write(*,*) "warning warning warning, gcwmk = 0"
				 endif
				 !
				 !deltaFUnction
				 vec2(1) = nn ! nn	! Node nds(1.5)
				 vec2(2) = ib ! ib 
				 vec2(3) = ll ! ll
				 vec2(4) = gcwmi ! id 
				 vec2(5) = gcwmj ! jjj
				 vec2(6) = gcwmk ! kd
				 vec2(7) = qF ! qF
				 vec2(8) = 3 ! 3 ! fieldFlag for selecting 3 velocity
				 vec3(1) = gcwmx !mrx
				 vec3(2) = gcwmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
				 vec3(3) = gcwmz !mrz
				 call interpolationF(vec2,vec3,mirror_w)
				 !
				 !if (rott_loc(nn).eq.1) then
				 if(rotating(M).eq..FALSE.) then
				 	k = - mirror_w
				 	!k = -1.0d00	
				 !elseif (rott_loc(nn).eq.2) then
				 elseif(rotating(M).eq..TRUE.) then
					k = 2*W_p - mirror_w  ! moving bodys
					!k = -1.0d00
				 endif
				 elseif(ll.eq.2)then
					k = 0.0d00
				 endif
				 !
				 if(flag1.eq.0) dom(ib)%woo(iic,jjc,kkk) = k
				 if(flag1.eq.1) dom(ib)%wstar(iic,jjc,kkk) = k
				 if(flag1.eq.2) dom(ib)%w(iic,jjc,kkk) = k
				 !
				    !if(flag1.eq.1) then
					!if((nn.gt.9240).and.(nn.lt.(9240+126))) then
					!   !	write(6,*) nn, k ,rott_loc(nn)
					!	 write(*,*) "WSTAR___WSTAR___WSTAR___WSTAR"
					!	   write(6,*) nn, iic,jjc,kkk
					!	   write(6,*) dom(ib)%mwcz(iic,jjc,kkk),qF
					!	   write(6,*) dom(ib)%wstar(iic,jjc,kkk)
					!   !write(6,*) qF, fieldF, fieldVal
					!   !write(6,*) vec2(1),vec2(2),vec2(3)
					!   !write(6,*) vec2(4),vec2(5),vec2(6)
					!   !write(6,*) vec2(7),vec2(8)
					!   !write(6,*) vec3(1),vec3(2),vec3(3)
					!   !write(6,*) "======================="
					!endif
					!endif
					!if(flag1.eq.2) then
					!if((nn.gt.9240).and.(nn.lt.(9240+126))) then
					!   !	write(6,*) nn, k ,rott_loc(nn)
					!	 write(*,*) "W_____W_____W_____W_____W_____W"
					!	   write(6,*) nn, iic,jjc,kkk
					!	   write(6,*) dom(ib)%mwcz(iic,jjc,kkk),qF
					!	   write(6,*) dom(ib)%w(iic,jjc,kkk)
					!   !write(6,*) qF, fieldF, fieldVal
					!   !write(6,*) vec2(1),vec2(2),vec2(3)
					!   !write(6,*) vec2(4),vec2(5),vec2(6)
					!   !write(6,*) vec2(7),vec2(8)
					!   !write(6,*) vec3(1),vec3(2),vec3(3)
					!   !write(6,*) "======================="
				   !endif
				   !endif
				endif   ! Ensuring processor ID matches subdomain ID???
				!debug
				!
			endif ! ghost cell treatment for the w velocity field
			!
			if ( (flag1.eq.0).or.(flag1.eq.2) ) then
			if(dom(ib)%mpc(ii,jj,kk).ne.0)then ! ghost cell treatment for the pressure field
				nn = dom(ib)%mpcnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 !
				 	!ib  = dom(ib)%mpcib(ii,jj,kk)  ! ib    if for layer at which nn marker is located
					ll  = dom(ib)%mpcll(ii,jj,kk)  ! ll
					if(ll.eq.1) then 
					iic = dom(ib)%mpci(ii,jj,kk)  ! iii   ox location of the p ghost cell 
					jjc = dom(ib)%mpcj(ii,jj,kk)  ! jjc   oy location of the p ghost cell
					kkc = dom(ib)%mpck(ii,jj,kk)  ! kkk   oy location of the p ghost cell
					qF  = dom(ib)%mpc(ii,jj,kk)	  ! qf 
					M   = lag_bod_loc(nn)
					!                                  
					gcpx  = dom(ib)%mpcx(ii,jj,kk) ! ox location of the p ghost cell  centre
					gcpy  = dom(ib)%mpcy(ii,jj,kk) ! oy location of the p ghost cell centre
					gcpz  = dom(ib)%mpcz(ii,jj,kk) ! oy location of the p ghost cell centre
					!                                 
					gcpmx = dom(ib)%mpcmx(ii,jj,kk) ! ox location of the p mirror cell  centre
					gcpmy = dom(ib)%mpcmy(ii,jj,kk) ! oy location of the p mirror cell centre
					gcpmz = dom(ib)%mpcmz(ii,jj,kk) ! oy location of the p mirror cell centre
					!                                 
					gcpmi = dom(ib)%mpcmi(ii,jj,kk) ! dom(ib)%x id of the p mirror point in fluid cell
					if (gcpmi.eq.0) then
						write(*,*) "warning warning warning, gcpmi = 0"
				 	endif 
					gcpmj = dom(ib)%mpcmj(ii,jj,kk) ! dom(ib)%y id of the p mirror point in fluid cell
					if (gcpmj.eq.0) then
						write(*,*) "warning warning warning, gcpmj = 0"
				 	endif 
					gcpmk = dom(ib)%mpcmk(ii,jj,kk) ! dom(ib)%z id of the p mirror point in fluid cell
					if (gcpmk.eq.0) then
						write(*,*) "warning warning warning, gcpmk = 0"
				 	endif 
				    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				    !!! BILINEAR INTERPOLATION
				    id = gcpmi
				    kd = gcpmk
			        pvec(1) = dom(ib)%pcpy(id-1,jjc,kd-1) ! q11
			        pvec(2) = dom(ib)%pcpy(id,jjc,kd-1)   ! q21
			        pvec(3) = dom(ib)%pcpy(id-1,jjc,kd)   ! q12
			        pvec(4) = dom(ib)%pcpy(id,jjc,kd)	   ! q22
			        nx(1) = dom(ib)%xc(id-1)		! CHECK_AAA	! Check %xc(id-1)
			        nx(2) = dom(ib)%xc(id)		! CHECK_AAA
			        nz(1) = dom(ib)%zc(kd-1)
			        nz(2) = dom(ib)%zc(kd)
			        !	mirror_p = bilinear1(nn,nx,nz,pvec,mrx,mrz)
			        !	if(nn.eq.126) then
			        !		write(6,*) "Mirror p (Bilinear Interpolation: explicit)",mirror_p
			        !	endif
			        ! Alternative (2nd order Least Squares & Cramer's solver)
			        !mirror_p = ls_2ndOrder_cramer(nn,nx,nz,pvec,mrx,mrz)
			        !if ( nn.eq.70 ) then
			        ! write(6,*) "Mirror p (2nd order Least Squares: cramer)",nn,mirror_p
			        !endif
			        !!! LINEAR INTERPOLATION
			        !mirror_p = l1(nn,nx,nz,pvec,mrx,mrz)
			        !if(nn.eq.70) then
			        !	write(6,*) "Mirror p (linear interpolation)", nn, mirror_p
			        !endif
			        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			        ! Alternative (Least Squares & Cramer's solver)
			        !mirror_p = ls_cramer(nn,nx,nz,pvec,mrx,mrz)
			        !if ( nn.eq.70 ) then
			        ! write(6,*) "Mirror p (Least Squares: cramer)", nn, mirror_p
			        !endif
				    ! Alternative: Bilinear Interpoaltion and Cramers solver
				    mrx = gcpmx
				    mrz = gcpmz
			        mirror_p = bl_cramer(nn,nx,nz,pvec,mrx,mrz)
			        !if ( nn.eq.70 ) then
			        ! write(6,*) "Mirror p (Bilinear Interpolation: cramer)", nn, mirror_p
			        !endif
			        !
				    !
				    !deltaFUnction
				    vec2(1) = nn ! nn	! Node nds(1.5)
				    vec2(2) = ib ! ib 
				    vec2(3) = ll ! ll
				    vec2(4) = gcpmi ! id 
				    vec2(5) = gcpmj ! jjj
				    vec2(6) = gcpmk ! kd
				    vec2(7) = qF ! qF
				    vec2(8) = 4 ! 1 ! fieldFlag for selecting p pressure
				    vec3(1) = gcpmx !mrx
				    vec3(2) = gcpmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
				    vec3(3) = gcpmz !mrz
				    !call interpolationF(vec2,vec3,mirror_p)
					!
					k = mirror_p
					!k = 0.0d00
					elseif(ll.eq.2)then
						k = 0.0d00
					endif
				    !
				    dom(ib)%p(iic,jjc,kkc) = k
					!
					! debug
					!if((nn.gt.9240).and.(nn.lt.(9240+126))) then
					!	!	write(6,*) nn, k ,rott_loc(nn)
					!	  write(*,*) "p_____p_____p_____p_____p_____p"
					!		write(6,*) nn,qF 
					!		write(6,*) iic,jjc,kkc
					!		write(6,*) id,kd
					!		write(6,*) nx,nz
					!		write(6,*) mrx,mrz
					!		write(6,*) pvec
					!		write(6,*) k!dom(ib)%p(iic,jjc,kkc)
					!endif
					!
				endif   ! Ensuring processor ID matches subdomain ID???
				!
			endif ! ghost cell treatment for the pressure field
			endif ! flag1
			!
		enddo
		enddo
		enddo
		!
		!
	endif ! Filtering out procesors
	!
	enddo ! End of the  loop sweeping the domains
			CONTAINS


			!######################################################################
			DOUBLE PRECISION FUNCTION bilinear1(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
			DOUBLE PRECISION:: factor1
			
			! Bilinear Interpolation (explicit formulation)
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			
			factor1 = 1.0d00/( (x2-x1)*(z2-z1) )
							
			m1(1) = x2 - mrx
			m1(2) = mrx - x1
			
			m2(1,1) = q11	! First row, 1st column
			m2(2,1) = q12	! 1 st row, 2 nd column
			m2(1,2) = q21	! 2 nd row,	1 st column
			m2(2,2) = q22	! 2 nd row, 2 nd column
			
			m3(1) = z2 - mrz
			m3(2) = mrz - z1
			
			m4 = matmul(m1,m2)
			
			bilinear1 = factor1*dot_product(m3,m4)
			
			!######################################################################
			END FUNCTION bilinear1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			
			
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = dx1*dx1; a1(5,1) = dz1*dz1; a1(6,1) = dx1*dz1

			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = dx2*dx2; a1(5,2) = dz1*dz1; a1(6,2) = dx2*dz1

			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = dx1*dx1; a1(5,3) = dz2*dz2; a1(6,3) = dx1*dz2

			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = dx2*dx2; a1(5,4) = dz2*dz2; a1(6,4) = dx2*dz2

			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,6)
			
			ls_2ndOrder_cramer = sol(1)
			
			!######################################################################
			END FUNCTION ls_2ndOrder_cramer
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION l1(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################

			implicit none

			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			DOUBLE PRECISION:: ux1,uz1,ux2,uz2
			DOUBLE PRECISION:: x1,z1,x2,z2
			DOUBLE PRECISION:: mirror_px1, mirror_px2 
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!! LINEAR INTERPOLATION
				! mirror velocity for x = mrx and z = zc(kd) = z1
			!	ux1 = dom(ib)%u(id,jjc,kd)
			!	ux2 = dom(ib)%u(id+1,jjc,kd)
			!	x1 = dom(ib)%x(id)
			!	x2 = dom(ib)%x(id+1)

				! Alternative
			ux1 = pvec(1)	!dom(ib)%u(id,jjc,kd)
			ux2 = pvec(2) 	!dom(ib)%u(id-1,jjc,kd)
			x1 = nx(1) 	!dom(ib)%x(id)
			x2 = nx(2)	!dom(ib)%x(id-1)
			
			mirror_px1 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = zc(kd-1) = z2				
			!ux1 = dom(ib)%u(id,jjc,kd-1)
			!ux2 = dom(ib)%u(id+1,jjc,kd-1)

			! Alternative
			ux1 = pvec(3)	!dom(ib)%u(id,jjc,kd-1)
			ux2 = pvec(4)	!dom(ib)%u(id-1,jjc,kd-1)

			mirror_px2 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = mrz
			uz1 = mirror_px1
			uz2 = mirror_px2
			z1 = nz(1)	!dom(ib)%zc(kd)
			z2 = nz(2)	!dom(ib)%zc(kd-1)

			l1 = uz1 + (uz2-uz1)*(mrz-z1)/(z2-z1)

			!######################################################################
			END FUNCTION l1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION cosAngle(x1,z1,x2,z2,x3,z3,l12)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: x1,z1,x2,z2,x3,z3,l12
			DOUBLE PRECISION:: x12,z12, x13, l13, z13

			x12 = x2-x1
			z12 = z2-z1
			x13 = x3-x1
			z13 = z3-z1
			l13 = sqrt(x13**2+z13**2)

			cosAngle = (x12*x13 + z12*z13)/(l12*l13)


			!######################################################################
			END FUNCTION cosAngle
			!######################################################################


			!######################################################################
			INTEGER FUNCTION quadrant(cnx,cnz,cnx2,cnz2,margin)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: cnx,cnz,cnx2,cnz2, margin
			INTEGER:: qFlag

										! ( 0, 90 ] First quadrant?
			if ( (cnx2 - cnx) .gt. -margin) then
			if ( (cnz2 - cnz) .gt. margin) then	! Proper way

				qFlag = 1			

			endif
			endif


			! ( 90, 180 ] 2nd quadrant?
			if ( (cnx2 - cnx) .le. -margin) then
			if ( (cnz2 - cnz) .ge. -margin) then

				qFlag = 2

			! End 2nd Quadrant ops
			endif
			endif


			! ( 180, 270 ] 3rd quadrant?
			if ( (cnx2 - cnx) .le. margin) then
			if ( (cnz2 - cnz) .lt. -margin) then

				qFlag = 3

			endif
			endif

			! ( 270, 360 ] 4th quadrant?
			if ( (cnx2 - cnx) .gt. margin) then
			if ( (cnz2 - cnz) .le. margin) then

				qFlag = 4


			endif
			endif		

			quadrant = qFlag

			!######################################################################
			END FUNCTION quadrant
			!######################################################################

!######################################################################		
	END SUBROUTINE ghostCell
!######################################################################	


!######################################################################	
      SUBROUTINE checkEmergingCells
!######################################################################	
	! subroutine for checking if there is any emerging fluid cell from the inmersed body
	! the condition is that for the same cell adress the flag mucx is zero and the flag
	! mucold is either 1,2,3 or 4.
	!
	! In searchGhostCells, the flag mucx is set to zero by default at the beggining. If the 
	! algorithm finds any fluid cell inside the body, mucx takes the value qF, that is, the 
	! quadrant in which that fluid cell is located.
	!
	! Case 1
	! Thus, for the same cell adress, if you have mucx = 0 and mucxold = 1,2,3 or 4, that means that
	! in the last time step, that cell was inside the inmersed body and in the current time step the 
	! cell is actually outside the moving body. When this happens we need to set mucxold = 0.
	!
	! case 2
	! When mucx = 1, 2, 3 or 4 and mucxold = 0, a new cell is inside the inmersed body. 
	! So we need to set mucxold = 1,2,3 or 4.
	!
	! case 3
	! It can also happen that the solid position has rotated and mucx = 1,3 or 4 and mucxold = 2 
      use imb
      use mpi
      use multidata
      use vars
      implicit none
	  !
	  INTEGER::ii,jj,kk,ib,nn,ll,qF,M
	  INTEGER::iii,jjj,kkk,iic,jjc,kkc
	  DOUBLE PRECISION::gcux,gcumx,gcui,gcumi
	  DOUBLE PRECISION::gcuy,gcumy,gcuj,gcumj
	  DOUBLE PRECISION::gcuz,gcumz,gcuk,gcumk
	  !
	  DOUBLE PRECISION::gcwx,gcwmx,gcwi,gcwmi
	  DOUBLE PRECISION::gcwy,gcwmy,gcwj,gcwmj
	  DOUBLE PRECISION::gcwz,gcwmz,gcwk,gcwmk
	  !
	  DOUBLE PRECISION::gcpx,gcpmx,gcpi,gcpmi
	  DOUBLE PRECISION::gcpy,gcpmy,gcpj,gcpmj
	  DOUBLE PRECISION::gcpz,gcpmz,gcpk,gcpmk
	  ! 
	  ! Interface with interpolationF
	  INTEGER::vec2(8)
	  DOUBLE PRECISION::vec3(3)
	  DOUBLE PRECISION::newu0,newu0b,newu
	  DOUBLE PRECISION::neww0,neww0b,neww
	  DOUBLE PRECISION::newp0,newp0b,newp
	  !
	  ! Interface with bilinear interpolation
	  DOUBLE PRECISION::nx(2),nz(2),pvec(4)
	  !
	  ! Flags
	  INTEGER:: fA,fB
	  !
      do ib = 1, nbp ! lets sweep only the subdomains with makers
	    if(imbinblock_loc(dom_id(ib)+1).NE.0) then	! Filtering out procesors that do not have accesss 
													! to the domain where there are markers or IB points 
         do kk=1,dom(ib)%ttc_k
         do ii=1,dom(ib)%ttc_i
		 do jj=1,dom(ib)%ttc_j
			! the flag "mucx(ii,jj,kk)" was reset previously in the sobroutine call searchGhostCells
			fA = dom(ib)%mucx(ii,jj,kk)
			fB = dom(ib)%mucxold(ii,jj,kk)
            ! CHECK_AAA		if(dom(ib)%mucx(ii,jj,kk).ne.dom(ib)%mucxold(ii,jj,kk))then 
			!
	  	    ! CHECK_AAA		if(dom(ib)%mucx(ii,jj,kk).eq.0) then	! ouside
			! CHECK_AAA		if(dom(ib)%mucxold(ii,jj,kk).ne.0) then	! inside the cylinder
			!
			! ghost cell treatment for the u velocity field
			if( (fA.eq.0).and.(fB.ne.0) ) then
				! Checking for case 1
				!
	  			! We have found an emerging cell
	  			! now we need to update the u velocity of the emerging cell
	  			! dom(ib)%uoo(i,j,k) = ...
			    nn = dom(ib)%mucxoldnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
			    if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 !                                 
				 ll = dom(ib)%mucxoldll(ii,jj,kk)  ! ll    id for layer at which nn marker is located
				 if (ll.eq.2) then
				  write(*,*) "In checkEmergingCells u cell with ll = 2"
				 endif  
				 iii = dom(ib)%mucxoldi(ii,jj,kk)  ! iii   ox location of the u ghost cell 
				 jjc = dom(ib)%mucxoldj(ii,jj,kk)  ! jjc   oy location of the u ghost cell
				 kkk = dom(ib)%mucxoldk(ii,jj,kk)  ! kkk   oy location of the u ghost cell, !check kkc?
				 qF = dom(ib)%mucxold(ii,jj,kk)	  ! qf 
				 M = lag_bod_loc(nn)
				 !                                 
				 gcux  = dom(ib)%mucxoldx(ii,jj,kk) ! ox location of the u ghost cell centre
				 gcuy  = dom(ib)%mucxoldy(ii,jj,kk) ! oy location of the u ghost cell centre
				 gcuz  = dom(ib)%mucxoldz(ii,jj,kk) ! oy location of the u ghost cell centre
				 !                                 
				 gcumx = dom(ib)%mucxoldmx(ii,jj,kk) ! ox location of the u mirror point in fluid cells 
				 gcumy = dom(ib)%mucxoldmy(ii,jj,kk) ! oy location of the u mirror point in fluid cells
				 gcumz = dom(ib)%mucxoldmz(ii,jj,kk) ! oy location of the u mirror point in fluid cells
				 !                                 
				 gcumi = dom(ib)%mucxoldmi(ii,jj,kk) ! dom(ib)%x id of the u mirror point in fluid cells
				 if (gcumi.eq.0) then
					write(*,*) "In checkEmergingCells gcumi = 0"
				 endif
				 gcumj = dom(ib)%mucxoldmj(ii,jj,kk) ! dom(ib)%y id of the u mirror point in fluid cells
				 gcumk = dom(ib)%mucxoldmk(ii,jj,kk) ! dom(ib)%z id of the u mirror point in fluid cells
				 !                                 
			     !deltaFUnction
			     vec2(1) = nn   ! nn	! Node nds(1.5)
			     vec2(2) = ib   ! ib 
			     vec2(3) = ll   ! ll
			     vec2(4) = iii  ! id 
			     vec2(5) = jjc  ! jjj
			     vec2(6) = kkk  ! kd !check kkc?
			     vec2(7) = qF   ! qF
			     vec2(8) = 1    ! 1 ! fieldFlag for selecting u velocity
			     vec3(1) = gcux !gcumx !mrx
			     vec3(2) = gcuy !gcumy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			     vec3(3) = gcuz !gcumz !mrz
				 call interpolationF(vec2,vec3,newu)	! go with this one
				 !if(qF.eq.1) newu = 0.7*dom(ib)%u(ii+1,jj,kk-1) 
				 !if(qF.eq.2) newu = 0.7*dom(ib)%u(ii+1,jj,kk+1) 
				 !if(qF.eq.3) newu = 0.7*dom(ib)%u(ii-1,jj,kk+1) 
				 !if(qF.eq.4) newu = 0.7*dom(ib)%u(ii-1,jj,kk-1) 
				 !
				 if(qF.eq.1) newu0b = dom(ib)%u(ii+1,jj,kk-1) 
				 if(qF.eq.2) newu0b = dom(ib)%u(ii+1,jj,kk+1) 
				 if(qF.eq.3) newu0b = dom(ib)%u(ii-1,jj,kk+1) 
				 if(qF.eq.4) newu0b = dom(ib)%u(ii-1,jj,kk-1)
				 !
				 newu0 = dom(ib)%uoo(ii,jj,kk) ! in the previous time step  dom(ib)%uoo(ii,jj,kk) = (2*Up - mirror_u)
				 dom(ib)%uoo(ii,jj,kk) = newu	! -newu0
				 !dom(ib)%uoo(ii,jj,kk) = -newu0 + 2*Up
				 !		-(  newu0 -2*Up  )
				 !
				 !debug
				 if((nn.gt.9240).and.(nn.lt.(9240+126))) then
				    write(*,*) "mucx____mucx____mucx____mucx____mucx____mucx"
				 	write(6,*) vec2
				 	write(6,*) vec3
				 	write(6,*) ii,jj,kk
				  	write(6,*) newu0b,newu0,dom(ib)%uoo(ii,jj,kk)
			     endif
				 !
				 ! Now lets update the flags
				 dom(ib)%mucxold(ii,jj,kk) = 0 
				 dom(ib)%mucxoldnn(ii,jj,kk) = 0
				 dom(ib)%mucxoldib(ii,jj,kk) = 0
				 dom(ib)%mucxoldll(ii,jj,kk) = 0
				 dom(ib)%mucxoldi(ii,jj,kk)  = 0
				 dom(ib)%mucxoldj(ii,jj,kk)  = 0
				 dom(ib)%mucxoldk(ii,jj,kk)  = 0
				 dom(ib)%mucxoldx(ii,jj,kk)  = 0
				 dom(ib)%mucxoldy(ii,jj,kk)  = 0
				 dom(ib)%mucxoldz(ii,jj,kk)  = 0
				 dom(ib)%mucxoldmi(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mucxoldmj(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mucxoldmk(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mucxoldmx(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mucxoldmy(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mucxoldmz(ii,jjj,kk) = 0 !CHECK_AAA
				 !
				 !dom(ib)%mucx(ii,jj,kk) = 0 ! this way the ghostCell Method will not be applied to this cell
				 dom(ib)%mucxnn(ii,jj,kk) = 0
				 dom(ib)%mucxib(ii,jj,kk) = 0
				 dom(ib)%mucxll(ii,jj,kk) = 0
				 dom(ib)%mucxi(ii,jj,kk)  = 0
				 dom(ib)%mucxj(ii,jj,kk)  = 0
				 dom(ib)%mucxk(ii,jj,kk)  = 0
				 dom(ib)%mucxx(ii,jj,kk)  = 0
				 dom(ib)%mucxy(ii,jj,kk)  = 0
				 dom(ib)%mucxz(ii,jj,kk)  = 0
				 dom(ib)%mucxmi(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mucxmj(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mucxmk(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mucxmx(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mucxmy(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mucxmz(ii,jjj,kk) = 0 !CHECK_AAA
			    endif	! Ensuring processor ID matches subdomain ID???
			 !
			 !
	  	    ! CHECK_AAA		endif
	  	    ! CHECK_AAA		endif
	  		!
	  		! CHECK_AAA		if(dom(ib)%mucx(ii,jj,kk).ne.0) then	! inside
			! CHECK_AAA		if(dom(ib)%mucxold(ii,jj,kk).eq.0) then	! outside
			elseif( (fA.ne.0).and.(fB.eq.0) ) then	
				! Checking for case 2
				!
				! we have found a new solid cell (formerly it was a fluid cell)
				! the rest of the info we need has already been saved in the arrays of the familly "mucx..."
				! this was done in the subroutines "searchCells" and "setMirror_u".
				dom(ib)%mucxold(ii,jj,kk)   = dom(ib)%mucx(ii,jj,kk)   ! qF for u ghost cells
				dom(ib)%mucxoldnn(ii,jj,kk) = dom(ib)%mucxnn(ii,jj,kk) ! nn for u ghost cells
				dom(ib)%mucxoldib(ii,jj,kk) = dom(ib)%mucxib(ii,jj,kk) ! ib for u ghost cells
				dom(ib)%mucxoldll(ii,jj,kk) = dom(ib)%mucxll(ii,jj,kk) ! ll for u ghost cells
				dom(ib)%mucxoldi(ii,jj,kk)  = dom(ib)%mucxi(ii,jj,kk)  ! %x  id for u ghost cells centre
				dom(ib)%mucxoldj(ii,jj,kk)  = dom(ib)%mucxj(ii,jj,kk)  ! %yc id for u ghost cells centre
				dom(ib)%mucxoldk(ii,jj,kk)  = dom(ib)%mucxk(ii,jj,kk)  ! %z  id for u ghost cells centre
				dom(ib)%mucxoldx(ii,jj,kk)  = dom(ib)%mucxx(ii,jj,kk)  ! %x  for u ghost cells centre
				dom(ib)%mucxoldy(ii,jj,kk)  = dom(ib)%mucxy(ii,jj,kk)  ! %yc for u ghost cells centre
				dom(ib)%mucxoldz(ii,jj,kk)  = dom(ib)%mucxz(ii,jj,kk)  ! %z  for u ghost cells centre
				!                                                       
				dom(ib)%mucxoldmi(ii,jjj,kk) = dom(ib)%mucxmi(ii,jjj,kk) ! dom(ib)%x id of the u mirror point in fluid cells	 CHECK_AAA
				dom(ib)%mucxoldmj(ii,jjj,kk) = dom(ib)%mucxmj(ii,jjj,kk) ! dom(ib)%y id of the u mirror point in fluid cells	 CHECK_AAA
				dom(ib)%mucxoldmk(ii,jjj,kk) = dom(ib)%mucxmk(ii,jjj,kk) ! dom(ib)%z id of the u mirror point in fluid cells	 CHECK_AAA
				dom(ib)%mucxoldmx(ii,jjj,kk) = dom(ib)%mucxmx(ii,jjj,kk) ! dom(ib)%x location of the u mirror point in fluid cells	 CHECK_AAA
				dom(ib)%mucxoldmy(ii,jjj,kk) = dom(ib)%mucxmy(ii,jjj,kk) ! dom(ib)%y location of the u mirror point in fluid cells	 CHECK_AAA
				dom(ib)%mucxoldmz(ii,jjj,kk) = dom(ib)%mucxmz(ii,jjj,kk) ! dom(ib)%z location of the u mirror point in fluid cells	 CHECK_AAA
	  		! CHECK_AAA		endif
	  		! CHECK_AAA		endif
	  		!
	  		! CHECK_AAA		if(dom(ib)%mucx(ii,jj,kk).ne.0)then	! inside
			! CHECK_AAA		if(dom(ib)%mucxold(ii,jj,kk).ne.0)then	! inside
			elseif( (fA.ne.0).and.(fB.ne.0) ) then
				! Case 3
				!
				! If the cylinder has moved, the mirror cell coordinates in previous time step will be different than in the
				! current time step. So we basically need to update information. 
				! The body has moved and this cell is still inside but we need to update
				! the info for this cell.
				dom(ib)%mucxold(ii,jj,kk)   = dom(ib)%mucx(ii,jj,kk)   ! qF for u ghost cells
				dom(ib)%mucxoldnn(ii,jj,kk) = dom(ib)%mucxnn(ii,jj,kk) ! nn for u ghost cells
				dom(ib)%mucxoldib(ii,jj,kk) = dom(ib)%mucxib(ii,jj,kk) ! ib for u ghost cells
				dom(ib)%mucxoldll(ii,jj,kk) = dom(ib)%mucxll(ii,jj,kk) ! ll for u ghost cells
				dom(ib)%mucxoldi(ii,jj,kk)  = dom(ib)%mucxi(ii,jj,kk)  ! %x  id for u ghost cells centre
				dom(ib)%mucxoldj(ii,jj,kk)  = dom(ib)%mucxj(ii,jj,kk)  ! %yc id for u ghost cells centre
				dom(ib)%mucxoldk(ii,jj,kk)  = dom(ib)%mucxk(ii,jj,kk)  ! %z  id for u ghost cells centre
				dom(ib)%mucxoldx(ii,jj,kk)  = dom(ib)%mucxx(ii,jj,kk)  ! %x  for u ghost cells centre
				dom(ib)%mucxoldy(ii,jj,kk)  = dom(ib)%mucxy(ii,jj,kk)  ! %yc for u ghost cells centre
				dom(ib)%mucxoldz(ii,jj,kk)  = dom(ib)%mucxz(ii,jj,kk)  ! %z  for u ghost cells centre
				!                                                     
				dom(ib)%mucxoldmi(ii,jj,kk) = dom(ib)%mucxmi(ii,jj,kk) ! %x  id for u mirror point in fluid cell
				dom(ib)%mucxoldmj(ii,jj,kk) = dom(ib)%mucxmj(ii,jj,kk) ! %yc id for u mirror point in fluid cell
				dom(ib)%mucxoldmk(ii,jj,kk) = dom(ib)%mucxmk(ii,jj,kk) ! %z  id for u mirror point in fluid cell
				dom(ib)%mucxoldmx(ii,jj,kk) = dom(ib)%mucxmx(ii,jj,kk) ! %x  location for u mirror point in fluid cell
				dom(ib)%mucxoldmy(ii,jj,kk) = dom(ib)%mucxmy(ii,jj,kk) ! %yc location for u mirror point in fluid cell
				dom(ib)%mucxoldmz(ii,jj,kk) = dom(ib)%mucxmz(ii,jj,kk) ! %z  location for u mirror point in fluid cell
				!
				!
	  		! CHECK_AAA		endif
	  		! CHECK_AAA		endif
            !
		   endif ! ghost cell treatment for the u velocity field
		   !
		   !
		   fA = dom(ib)%mwcz(ii,jj,kk)
		   fB = dom(ib)%mwczold(ii,jj,kk)
		   ! ghost cell treatment for the w velocity field
		   ! CHECK_AAA		if(dom(ib)%mwcz(ii,jj,kk).ne.dom(ib)%mwczold(ii,jj,kk))then
			if( (fA.eq.0).and.(fB.ne.0) ) then
				!
				! the flag "mwcz(ii,jj,kk)" was reset previously in the sobroutine call searchGhostCells
				! Checking for case 1
				! CHECK_AAA		if(dom(ib)%mwcz(ii,jj,kk).eq.0) then
				! CHECK_AAA		if(dom(ib)%mwczold(ii,jj,kk).ne.0) then
				! We have found an emerging cell
				! now we need to update the u velocity of the emerging cell
				! dom(ib)%woo(i,j,k) = ...
				nn = dom(ib)%mwczoldnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 !                                 
				 ll = dom(ib)%mwczoldll(ii,jj,kk)  ! ll    id for layer at which nn marker is located
				 if (ll.eq.2) then
					write(*,*) "Warning Warning Waring w cell with ll = 2"
				 endif  
				 iic = dom(ib)%mwczoldi(ii,jj,kk)  ! iii   ox location of the w ghost cell centre 
				 jjc = dom(ib)%mwczoldj(ii,jj,kk)  ! jjc   oy location of the w ghost cell centre
				 kkk = dom(ib)%mwczoldk(ii,jj,kk)  ! kkk   oy location of the w ghost cell centre
				 qF = dom(ib)%mwczold(ii,jj,kk)	  ! qf 
				 M = lag_bod_loc(nn)
				 !                                 
				 gcwx  = dom(ib)%mwczoldx(ii,jj,kk) ! ox location of the w ghost cell centre 
				 gcwy  = dom(ib)%mwczoldy(ii,jj,kk) ! oy location of the w ghost cell centre
				 gcwz  = dom(ib)%mwczoldz(ii,jj,kk) ! oy location of the w ghost cell centre
				 !                                 
				 gcwmx = dom(ib)%mwczoldmx(ii,jj,kk) ! ox location of the w mirror point in fluid cell 
				 gcwmy = dom(ib)%mwczoldmy(ii,jj,kk) ! oy location of the w mirror point in fluid cell
				 gcwmz = dom(ib)%mwczoldmz(ii,jj,kk) ! oy location of the w mirror point in fluid cell
				 !                                 
				 gcwmi = dom(ib)%mwczoldmi(ii,jj,kk) ! dom(ib)%x id of the w mirror point in fluid cell
				 if (gcwmi.eq.0) then
					write(*,*) "In checkEmergingCells gcwmi = 0"
				 endif
				 gcwmj = dom(ib)%mwczoldmj(ii,jj,kk) ! dom(ib)%y id of the w mirror point in fluid cell
				 gcwmk = dom(ib)%mwczoldmk(ii,jj,kk) ! dom(ib)%z id of the w mirror point in fluid cell
				 !                                 
				 !deltaFUnction
				 vec2(1) = nn   ! nn	! Node nds(1.5)
				 vec2(2) = ib   ! ib 
				 vec2(3) = ll   ! ll
				 vec2(4) = iic  ! id 
				 vec2(5) = jjc  ! jjj
				 vec2(6) = kkk  ! kd !check kkc?
				 vec2(7) = qF   ! qF
				 vec2(8) = 1    ! 1 ! fieldFlag for selecting u velocity
				 vec3(1) = gcwx !gcwmx !mrx
				 vec3(2) = gcwy !gcwmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
				 vec3(3) = gcwz !gcwmz !mrz
				 call interpolationF(vec2,vec3,neww)				! also interpolate for pressure
				 !if(qF.eq.1) neww = 0.7*dom(ib)%w(ii+1,jj,kk-1) 
				 !if(qF.eq.2) neww = 0.7*dom(ib)%w(ii+1,jj,kk+1) 
				 !if(qF.eq.3) neww = 0.7*dom(ib)%w(ii-1,jj,kk+1) 
				 !if(qF.eq.4) neww = 0.7*dom(ib)%w(ii-1,jj,kk-1) 
				 !
				 if(qF.eq.1) neww0b = dom(ib)%w(ii+1,jj,kk-1) 
				 if(qF.eq.2) neww0b = dom(ib)%w(ii+1,jj,kk+1) 
				 if(qF.eq.3) neww0b = dom(ib)%w(ii-1,jj,kk+1) 
				 if(qF.eq.4) neww0b = dom(ib)%w(ii-1,jj,kk-1)
				 !
				 neww0 = dom(ib)%woo(ii,jj,kk) ! in the previous time step  dom(ib)%woo(ii,jj,kk) = (2*Wp - mirror_w)
				 dom(ib)%woo(ii,jj,kk) = neww
				 !dom(ib)%woo(ii,jj,kk) = -neww0 + 2*Wp
				 !		-(  neww0 -2*Wp  )
				 !
				 !debug
				 if((nn.gt.9240).and.(nn.lt.(9240+126))) then
					write(*,*) "mwcz____mwcz____mwcz____mwcz____mwcz____mwcz"
					 write(6,*) vec2
					 write(6,*) vec3
					 write(6,*) ii,jj,kk
					  write(6,*) neww0b,neww0,dom(ib)%woo(ii,jj,kk)
				 endif
				 !
				 ! Now lets update the flags
				 dom(ib)%mwczold(ii,jj,kk) = 0 
				 dom(ib)%mwczoldnn(ii,jj,kk) = 0
				 dom(ib)%mwczoldib(ii,jj,kk) = 0
				 dom(ib)%mwczoldll(ii,jj,kk) = 0
				 dom(ib)%mwczoldi(ii,jj,kk)  = 0
				 dom(ib)%mwczoldj(ii,jj,kk)  = 0
				 dom(ib)%mwczoldk(ii,jj,kk)  = 0
				 dom(ib)%mwczoldx(ii,jj,kk)  = 0
				 dom(ib)%mwczoldy(ii,jj,kk)  = 0
				 dom(ib)%mwczoldz(ii,jj,kk)  = 0
				 dom(ib)%mwczoldmi(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mwczoldmj(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mwczoldmk(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mwczoldmx(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mwczoldmy(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mwczoldmz(ii,jjj,kk) = 0 !CHECK_AAA
				 !
				 dom(ib)%mwcz(ii,jj,kk) = 0 ! this way the ghostCell Method will not be applied to this cell
				 dom(ib)%mwcznn(ii,jj,kk) = 0
				 dom(ib)%mwczib(ii,jj,kk) = 0
				 dom(ib)%mwczll(ii,jj,kk) = 0
				 dom(ib)%mwczi(ii,jj,kk)  = 0
				 dom(ib)%mwczj(ii,jj,kk)  = 0
				 dom(ib)%mwczk(ii,jj,kk)  = 0
				 dom(ib)%mwczx(ii,jj,kk)  = 0
				 dom(ib)%mwczy(ii,jj,kk)  = 0
				 dom(ib)%mwczz(ii,jj,kk)  = 0
				 dom(ib)%mwczmi(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mwczmj(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mwczmk(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mwczmx(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mwczmy(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mwczmz(ii,jjj,kk) = 0 !CHECK_AAA
				endif
				!
				!
				! CHECK_AAA		endif
				! CHECK_AAA		endif
				!
				!	CHECK_AAA	if(dom(ib)%mwcz(ii,jj,kk).ne.0) then
				!	CHECK_AAA	if(dom(ib)%mwczold(ii,jj,kk).eq.0) then
			elseif( (fA.ne.0).and.(fB.eq.0) ) then
			  	! Checking for case 2
				!
				! we have found a new solid cell (formerly it was a fluid cell)
				! the rest of the info we need has already been saved in the arrays of the familly "mwcz..."
				! this was done in the subroutines "searchCells" and "setMirror_u".
				dom(ib)%mwczold(ii,jj,kk)   = dom(ib)%mwcz(ii,jj,kk)   ! qF for w ghost cells
				dom(ib)%mwczoldnn(ii,jj,kk) = dom(ib)%mwcznn(ii,jj,kk) ! nn for w ghost cells
				dom(ib)%mwczoldib(ii,jj,kk) = dom(ib)%mwczib(ii,jj,kk) ! ib for w ghost cells
				dom(ib)%mwczoldll(ii,jj,kk) = dom(ib)%mwczll(ii,jj,kk) ! ll for w ghost cells
				dom(ib)%mwczoldi(ii,jj,kk)  = dom(ib)%mwczi(ii,jj,kk)  ! %x  id for w ghost cells centre
				dom(ib)%mwczoldj(ii,jj,kk)  = dom(ib)%mwczj(ii,jj,kk)  ! %yc id for w ghost cells centre
				dom(ib)%mwczoldk(ii,jj,kk)  = dom(ib)%mwczk(ii,jj,kk)  ! %z  id for w ghost cells centre
				dom(ib)%mwczoldx(ii,jj,kk)  = dom(ib)%mwczx(ii,jj,kk)  ! %x  for w ghost cells centre
				dom(ib)%mwczoldy(ii,jj,kk)  = dom(ib)%mwczy(ii,jj,kk)  ! %yc for w ghost cells centre
				dom(ib)%mwczoldz(ii,jj,kk)  = dom(ib)%mwczz(ii,jj,kk)  ! %z  for w ghost cells centre
				!
				dom(ib)%mwczoldmi(ii,jjj,kk) = dom(ib)%mwczmi(ii,jjj,kk) !%x  id for w mirror point in fluid cell
				dom(ib)%mwczoldmj(ii,jjj,kk) = dom(ib)%mwczmj(ii,jjj,kk) !%yc id for w mirror point in fluid cell
				dom(ib)%mwczoldmk(ii,jjj,kk) = dom(ib)%mwczmk(ii,jjj,kk) !%z  id for w mirror point in fluid cell
				dom(ib)%mwczoldmx(ii,jjj,kk) = dom(ib)%mwczmx(ii,jjj,kk) !%x  location for w mirror point in fluid cell
				dom(ib)%mwczoldmy(ii,jjj,kk) = dom(ib)%mwczmy(ii,jjj,kk) !%yc location for w mirror point in fluid cell
				dom(ib)%mwczoldmz(ii,jjj,kk) = dom(ib)%mwczmz(ii,jjj,kk) !%z  location for w mirror point in fluid cell
				! the mirror velocity has already been sed in "setMirror_u"
			  ! CHECK_AAA		endif
			  ! CHECK_AAA		endif
			  !
			  ! CHECK_AAA		if(dom(ib)%mwcz(ii,jj,kk).ne.0)then
			  ! CHECK_AAA		if(dom(ib)%mwczold(ii,jj,kk).ne.0)then
			elseif( (fA.ne.0).and.(fB.ne.0) ) then
				! Case 3
				!
				! The body has moved and this cell is still inside but we need to update
				! the info for this cell.
				dom(ib)%mwczold(ii,jj,kk)   = dom(ib)%mwcz(ii,jj,kk)   ! qF for w ghost cells
				dom(ib)%mwczoldnn(ii,jj,kk) = dom(ib)%mwcznn(ii,jj,kk) ! nn for w ghost cells
				dom(ib)%mwczoldib(ii,jj,kk) = dom(ib)%mwczib(ii,jj,kk) ! ib for w ghost cells
				dom(ib)%mwczoldll(ii,jj,kk) = dom(ib)%mwczll(ii,jj,kk) ! ll for w ghost cells
				dom(ib)%mwczoldi(ii,jj,kk)  = dom(ib)%mwczi(ii,jj,kk)  ! %x  id for w ghost cells centre
				dom(ib)%mwczoldj(ii,jj,kk)  = dom(ib)%mwczj(ii,jj,kk)  ! %yc id for w ghost cells centre
				dom(ib)%mwczoldk(ii,jj,kk)  = dom(ib)%mwczk(ii,jj,kk)  ! %z  id for w ghost cells centre
				dom(ib)%mwczoldx(ii,jj,kk)  = dom(ib)%mwczx(ii,jj,kk)  ! %x  for w ghost cells centre
				dom(ib)%mwczoldy(ii,jj,kk)  = dom(ib)%mwczy(ii,jj,kk)  ! %yc for w ghost cells centre
				dom(ib)%mwczoldz(ii,jj,kk)  = dom(ib)%mwczz(ii,jj,kk)  ! %z  for w ghost cells centre
				!
				dom(ib)%mwczoldmi(ii,jj,kk) = dom(ib)%mwczmi(ii,jj,kk) ! %x  id for w mirror point in fluid cells
				dom(ib)%mwczoldmj(ii,jj,kk) = dom(ib)%mwczmj(ii,jj,kk) ! %yc id for w mirror point in fluid cells
				dom(ib)%mwczoldmk(ii,jj,kk) = dom(ib)%mwczmk(ii,jj,kk) ! %z  id for w mirror point in fluid cells
				dom(ib)%mwczoldmx(ii,jj,kk) = dom(ib)%mwczmx(ii,jj,kk) ! %x  location for w mirror point in fluid cells
				dom(ib)%mwczoldmy(ii,jj,kk) = dom(ib)%mwczmy(ii,jj,kk) ! %yc location for w mirror point in fluid cells
				dom(ib)%mwczoldmz(ii,jj,kk) = dom(ib)%mwczmz(ii,jj,kk) ! %z  location for w mirror point in fluid cells
				!
				!
			  !	CHECK_AAA		endif
			  !	CHECK_AAA		endif
			  !
		   endif ! ghost cell treatment for the w velocity field
		   !
		   !
		   !
		   !aa
		   !
		   fA = dom(ib)%mpc(ii,jj,kk)
		   fB = dom(ib)%mpcold(ii,jj,kk)
		   ! CHECK_AAA		if(dom(ib)%mpc(ii,jj,kk).ne.dom(ib)%mpcold(ii,jj,kk))then
		   ! ghost cell treatment for the p pressure field
			if( (fA.eq.0).and.(fB.ne.0) ) then
				! Checking for case 1
				!
				! the flag "mpc(ii,jj,kk)" was reset previously in the sobroutine call searchGhostCells
				! CHECK_AAA		if(dom(ib)%mpc(ii,jj,kk).eq.0) then
				! CHECK_AAA		if(dom(ib)%mpcold(ii,jj,kk).ne.0) then
				! We have found an emerging cell
				! now we need to update the u velocity of the emerging cell
				! dom(ib)%p(i,j,k) = ...
				nn = dom(ib)%mpcoldnn(ii,jj,kk)  ! nn    id for IB point or marker 
				!                                 
				if(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				 !                                 
				 ll = dom(ib)%mpcoldll(ii,jj,kk)  ! ll    id for layer at which nn marker is located
				 if (ll.eq.2) then
					write(*,*) "Warning Warning Waring p cell with ll = 2"
				 endif  
				 iic = dom(ib)%mpcoldi(ii,jj,kk)  ! iii   ox location of the u ghost cell 
				 jjc = dom(ib)%mpcoldj(ii,jj,kk)  ! jjc   oy location of the u ghost cell
				 kkc = dom(ib)%mpcoldk(ii,jj,kk)  ! kkk   oy location of the u ghost cell, !check kkc?
				 qF = dom(ib)%mpcold(ii,jj,kk)	  ! qf 
				 M = lag_bod_loc(nn)
				 !                                 
				 gcpx  = dom(ib)%mpcoldx(ii,jj,kk) ! ox location of the u ghost cell 
				 gcpy  = dom(ib)%mpcoldy(ii,jj,kk) ! oy location of the u ghost cell
				 gcpz  = dom(ib)%mpcoldz(ii,jj,kk) ! oy location of the u ghost cell
				 !                                 
				 gcpmx = dom(ib)%mpcoldmx(ii,jj,kk) ! ox location of the u mirror cell 
				 gcpmy = dom(ib)%mpcoldmy(ii,jj,kk) ! oy location of the u mirror cell
				 gcpmz = dom(ib)%mpcoldmz(ii,jj,kk) ! oy location of the u mirror cell
				 !                                 
				 gcpmi = dom(ib)%mpcoldmi(ii,jj,kk) ! dom(ib)%x id of the u mirror cell 
				 if (gcpmi.eq.0) then
					write(*,*) "In checkEmergingCells gcpmi = 0"
				 endif
				 gcpmj = dom(ib)%mpcoldmj(ii,jj,kk) ! dom(ib)%y id of the u mirror cell
				 gcpmk = dom(ib)%mpcoldmk(ii,jj,kk) ! dom(ib)%z id of the u mirror cell
                 !                                 
                 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				 !!! deltaFUnction
				    !vec2(1) = nn   ! nn	! Node nds(1.5)
				    !vec2(2) = ib   ! ib 
				    !vec2(3) = ll   ! ll
				    !vec2(4) = iic  ! id 
				    !vec2(5) = jjc  ! jjj
				    !vec2(6) = kkc  ! kd !check kkc?
				    !vec2(7) = qF   ! qF
				    !vec2(8) = 1    ! 1 ! fieldFlag for selecting u velocity
				    !vec3(1) = gcpx !gcpmx !mrx
				    !vec3(2) = gcpy !gcpmy !dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
				    !vec3(3) = gcpz !gcpmz !mrz
                    !call interpolationF(vec2,vec3,newp)				! also interpolate for pressure
                 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				 !!! BILINEAR INTERPOLATION
                 if(qF.eq.1) then
                    pvec(1) = dom(ib)%p(iic+1,jjc,kkc) ! q11
                    pvec(2) = dom(ib)%p(iic+2,jjc,kkc)   ! q21
                    pvec(3) = dom(ib)%p(iic+1,jjc,kkc-1)   ! q12
                    pvec(4) = dom(ib)%p(iic+2,jjc,kkc-1)	   ! q22
                    !
                    nx(1) = dom(ib)%xc(iic+1)
                    nx(2) = dom(ib)%xc(iic+2)
                    nz(1) = dom(ib)%zc(kkc)
                    nz(2) = dom(ib)%zc(kkc-1)
                 elseif(qF.eq.2) then
                    pvec(1) = dom(ib)%p(iic+1,jjc,kkc) ! q11
                    pvec(2) = dom(ib)%p(iic+2,jjc,kkc)   ! q21
                    pvec(3) = dom(ib)%p(iic+1,jjc,kkc+1)   ! q12
                    pvec(4) = dom(ib)%p(iic+2,jjc,kkc+1)	   ! q22
                    !
                    nx(1) = dom(ib)%xc(iic+1)
                    nx(2) = dom(ib)%xc(iic+2)
                    nz(1) = dom(ib)%zc(kkc)
                    nz(2) = dom(ib)%zc(kkc+1)
                 elseif(qF.eq.3) then
                    pvec(1) = dom(ib)%p(iic-1,jjc,kkc) ! q11
                    pvec(2) = dom(ib)%p(iic-2,jjc,kkc)   ! q21
                    pvec(3) = dom(ib)%p(iic-1,jjc,kkc+1)   ! q12
                    pvec(4) = dom(ib)%p(iic-2,jjc,kkc+1)	   ! q22
                    !
                    nx(1) = dom(ib)%xc(iic-1)
                    nx(2) = dom(ib)%xc(iic-2)
                    nz(1) = dom(ib)%zc(kkc)
                    nz(2) = dom(ib)%zc(kkc+1)
                 elseif(qF.eq.4) then
                    pvec(1) = dom(ib)%p(iic-1,jjc,kkc) ! q11
                    pvec(2) = dom(ib)%p(iic-2,jjc,kkc)   ! q21
                    pvec(3) = dom(ib)%p(iic-1,jjc,kkc-1)   ! q12
                    pvec(4) = dom(ib)%p(iic-2,jjc,kkc-1)	   ! q22
                    !
                    nx(1) = dom(ib)%xc(iic-1)
                    nx(2) = dom(ib)%xc(iic-2)
                    nz(1) = dom(ib)%zc(kkc)
                    nz(2) = dom(ib)%zc(kkc-1)
				 endif
				 !
                 newp = bl_cramer(nn,nx,nz,pvec,gcpx,gcpz)
				 !if(qF.eq.1) newp = 0.7*dom(ib)%w(ii+1,jj,kk-1) 
				 !if(qF.eq.2) newp = 0.7*dom(ib)%w(ii+1,jj,kk+1) 
				 !if(qF.eq.3) newp = 0.7*dom(ib)%w(ii-1,jj,kk+1) 
				 !if(qF.eq.4) newp = 0.7*dom(ib)%w(ii-1,jj,kk-1) 
				 !
				 if(qF.eq.1) newp0b = dom(ib)%p(ii+1,jj,kk-1) 
				 if(qF.eq.2) newp0b = dom(ib)%p(ii+1,jj,kk+1) 
				 if(qF.eq.3) newp0b = dom(ib)%p(ii-1,jj,kk+1) 
				 if(qF.eq.4) newp0b = dom(ib)%p(ii-1,jj,kk-1)
				 !
				 newp0 = dom(ib)%p(ii,jj,kk) ! value in the previous time step 
				 dom(ib)%p(ii,jj,kk) = newp
				 !
				 !debug
				 if((nn.gt.9240).and.(nn.lt.(9240+126))) then
					write(*,*) "mpc____mpc____mpc____mpc____mpc____mpc"
					 !write(6,*) vec2
					 !write(6,*) vec3
					 write(6,*) ii,jj,kk
					  write(6,*) newp0b,newp0,dom(ib)%p(ii,jj,kk)
				 endif
				 !
				 ! Now lets update the flags
				 dom(ib)%mpcold(ii,jj,kk) = 0 
				 dom(ib)%mpcoldnn(ii,jj,kk) = 0
				 dom(ib)%mpcoldib(ii,jj,kk) = 0
				 dom(ib)%mpcoldll(ii,jj,kk) = 0
				 dom(ib)%mpcoldi(ii,jj,kk)  = 0
				 dom(ib)%mpcoldj(ii,jj,kk)  = 0
				 dom(ib)%mpcoldk(ii,jj,kk)  = 0
				 dom(ib)%mpcoldx(ii,jj,kk)  = 0
				 dom(ib)%mpcoldy(ii,jj,kk)  = 0
				 dom(ib)%mpcoldz(ii,jj,kk)  = 0
				 dom(ib)%mpcoldmi(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcoldmj(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcoldmk(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcoldmx(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcoldmy(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcoldmz(ii,jjj,kk) = 0 !CHECK_AAA
				 !
				 dom(ib)%mpcnn(ii,jj,kk) = 0
				 dom(ib)%mpcib(ii,jj,kk) = 0
				 dom(ib)%mpcll(ii,jj,kk) = 0
				 dom(ib)%mpci(ii,jj,kk)  = 0
				 dom(ib)%mpcj(ii,jj,kk)  = 0
				 dom(ib)%mpck(ii,jj,kk)  = 0
				 dom(ib)%mpcx(ii,jj,kk)  = 0
				 dom(ib)%mpcy(ii,jj,kk)  = 0
				 dom(ib)%mpcz(ii,jj,kk)  = 0
				 dom(ib)%mpcmi(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcmj(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcmk(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcmx(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcmy(ii,jjj,kk) = 0 !CHECK_AAA
				 dom(ib)%mpcmz(ii,jjj,kk) = 0 !CHECK_AAA
				endif
			  ! CHECK_AAA		endif
			  ! CHECK_AAA		endif
			  !
			  ! CHECK_AAA		if(dom(ib)%mpc(ii,jj,kk).ne.0) then	! inside
			  ! CHECK_AAA		if(dom(ib)%mpcold(ii,jj,kk).eq.0) then ! outside
			elseif( (fA.ne.0).and.(fB.eq.0) ) then
				! Checking for case 2
				!
				! we have found a new solid cell (formerly it was a fluid cell)
				! the rest of the info we need has already been saved in the arrays of the familly "mpc..."
				! this was done in the subroutines "searchCells" and "setMirror_u".
				dom(ib)%mpcold(ii,jj,kk)   = dom(ib)%mpc(ii,jj,kk)   ! qF for p ghost cells
				dom(ib)%mpcoldnn(ii,jj,kk) = dom(ib)%mpcnn(ii,jj,kk) ! nn for p ghost cells
				dom(ib)%mpcoldib(ii,jj,kk) = dom(ib)%mpcib(ii,jj,kk) ! ib for p ghost cells
				dom(ib)%mpcoldll(ii,jj,kk) = dom(ib)%mpcll(ii,jj,kk) ! ll for p ghost cells
				dom(ib)%mpcoldi(ii,jj,kk)  = dom(ib)%mpci(ii,jj,kk)  ! %x  id for p ghost cells centre
				dom(ib)%mpcoldj(ii,jj,kk)  = dom(ib)%mpcj(ii,jj,kk)  ! %yc id for p ghost cells centre
				dom(ib)%mpcoldk(ii,jj,kk)  = dom(ib)%mpck(ii,jj,kk)  ! %z  id for p ghost cells centre
				dom(ib)%mpcoldx(ii,jj,kk)  = dom(ib)%mpcx(ii,jj,kk)  ! %x  for p ghost cells centre
				dom(ib)%mpcoldy(ii,jj,kk)  = dom(ib)%mpcy(ii,jj,kk)  ! %yc for p ghost cells centre
				dom(ib)%mpcoldz(ii,jj,kk)  = dom(ib)%mpcz(ii,jj,kk)  ! %z  for p ghost cells centre
				!
				dom(ib)%mpcoldmi(ii,jjj,kk) = dom(ib)%mpcmi(ii,jjj,kk) !%x  id for p mirror point in fluid cell
				dom(ib)%mpcoldmj(ii,jjj,kk) = dom(ib)%mpcmj(ii,jjj,kk) !%yc id for p mirror point in fluid cell
				dom(ib)%mpcoldmk(ii,jjj,kk) = dom(ib)%mpcmk(ii,jjj,kk) !%z  id for p mirror point in fluid cell
				dom(ib)%mpcoldmx(ii,jjj,kk) = dom(ib)%mpcmx(ii,jjj,kk) !%x  location for p mirror point in fluid cell
				dom(ib)%mpcoldmy(ii,jjj,kk) = dom(ib)%mpcmy(ii,jjj,kk) !%yc location for p mirror point in fluid cell
				dom(ib)%mpcoldmz(ii,jjj,kk) = dom(ib)%mpcmz(ii,jjj,kk) !%z  location for p mirror point in fluid cell
			  ! CHECK_AAA		endif
			  ! CHECK_AAA		endif
			  !
			  ! CHECK_AAA		if(dom(ib)%mpc(ii,jj,kk).ne.0)then	! inside
			  ! CHECK_AAA		if(dom(ib)%mpcold(ii,jj,kk).ne.0)then	! inside
			elseif( (fA.ne.0).and.(fB.ne.0) ) then
				! Case 3
				!
				! The body has moved and this cell is still inside but we need to update
				! the info for this cell.
				dom(ib)%mpcold(ii,jj,kk)   = dom(ib)%mpc(ii,jj,kk)   ! qF for p ghost cells
				dom(ib)%mpcoldnn(ii,jj,kk) = dom(ib)%mpcnn(ii,jj,kk) ! nn for p ghost cells
				dom(ib)%mpcoldib(ii,jj,kk) = dom(ib)%mpcib(ii,jj,kk) ! ib for p ghost cells
				dom(ib)%mpcoldll(ii,jj,kk) = dom(ib)%mpcll(ii,jj,kk) ! ll for p ghost cells
				dom(ib)%mpcoldi(ii,jj,kk)  = dom(ib)%mpci(ii,jj,kk)  ! %x  id for p ghost cells centre
				dom(ib)%mpcoldj(ii,jj,kk)  = dom(ib)%mpcj(ii,jj,kk)  ! %yc id for p ghost cells centre
				dom(ib)%mpcoldk(ii,jj,kk)  = dom(ib)%mpck(ii,jj,kk)  ! %z  id for p ghost cells centre
				dom(ib)%mpcoldx(ii,jj,kk)  = dom(ib)%mpcx(ii,jj,kk)  ! %x  for p ghost cells centre
				dom(ib)%mpcoldy(ii,jj,kk)  = dom(ib)%mpcy(ii,jj,kk)  ! %yc for p ghost cells centre
				dom(ib)%mpcoldz(ii,jj,kk)  = dom(ib)%mpcz(ii,jj,kk)  ! %z  for p ghost cells centre
				!
				dom(ib)%mpcoldmi(ii,jj,kk) = dom(ib)%mpcmi(ii,jj,kk) ! %x  id for p mirror point in fluid cells
				dom(ib)%mpcoldmj(ii,jj,kk) = dom(ib)%mpcmj(ii,jj,kk) ! %yc id for p mirror point in fluid cells
				dom(ib)%mpcoldmk(ii,jj,kk) = dom(ib)%mpcmk(ii,jj,kk) ! %z  id for p mirror point in fluid cells
				dom(ib)%mpcoldmx(ii,jj,kk) = dom(ib)%mpcmx(ii,jj,kk) ! %x  location for p mirror point in fluid cells
				dom(ib)%mpcoldmy(ii,jj,kk) = dom(ib)%mpcmy(ii,jj,kk) ! %yc location for p mirror point in fluid cells
				dom(ib)%mpcoldmz(ii,jj,kk) = dom(ib)%mpcmz(ii,jj,kk) ! %z  location for p mirror point in fluid cells
				!
				!
			  ! CHECK_AAA		endif
			  ! CHECK_AAA		endif
			  !
	        endif ! ghost cell treatment for the p pressure field
		   !
		   !
         enddo !i loop
         enddo !j loop
         enddo !k loop
        endif ! Filtering out procesors
	  enddo ! sweeping subdomains
			CONTAINS

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			
			
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = dx1*dx1; a1(5,1) = dz1*dz1; a1(6,1) = dx1*dz1

			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = dx2*dx2; a1(5,2) = dz1*dz1; a1(6,2) = dx2*dz1

			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = dx1*dx1; a1(5,3) = dz2*dz2; a1(6,3) = dx1*dz2

			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = dx2*dx2; a1(5,4) = dz2*dz2; a1(6,4) = dx2*dz2

			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,6)
			
			ls_2ndOrder_cramer = sol(1)
			
			!######################################################################
			END FUNCTION ls_2ndOrder_cramer
			!######################################################################

!######################################################################	
      END SUBROUTINE checkEmergingCells
!######################################################################	


!######################################################################			
	  !SUBROUTINE searchGhostCells(flag1)
      SUBROUTINE searchGhostCells
!######################################################################	

        use imb
        use mpi
	    use multidata
        use vars
		
        implicit none


	  !INTEGER, INTENT(IN):: flag1
      INTEGER 	:: M,L
	  
		  ! definition of iterators
	  INTEGER :: ib,iii,jjj,kkk,nn,mm,ll
	  INTEGER :: iic, jjc, kkc, ii, jj, kk
	  ! ib: index for subdomain,
	  ! iii : index for cells along the OX direction
	  ! jjj : index for cells along the OX direction
	  ! kkk : index for cells along the OX direction	
	  ! mm :
	  ! nn : index for nodes belonging to the M-th mody
	  INTEGER ::vec0u(8), vec0w(8)
	  !
	  INTEGER :: nnStart, nnFinish
	  INTEGER :: is,ie,js,je,ks,ke
	  INTEGER :: i_n_cells ,j_n_cells,k_n_cells
	  !
	  DOUBLE PRECISION :: cnx,cny,cnz ! Marker coordinates, cn
	  !
	  ! Boundary Margings
	  DOUBLE PRECISION:: dh, margin,dx_l,dy_l,dz_l,swapTemp
	  ! dh : equivalent grid spacing in 3D
	  ! margin: Boundary Margings
	  INTEGER:: layers2Sweep,mksPS
	  INTEGER:: mksEL, St_k
	  !
	  DOUBLE PRECISION, DIMENSION(3) :: vec1 ! vec1: vector linking markers cn and cn2
	  DOUBLE PRECISION:: origin_x, origin_y, origin_z
	  DOUBLE PRECISION:: origin_xc , origin_yc, origin_zc
	  DOUBLE PRECISION, DIMENSION(11):: ndsx,ndsy,ndsz
	  ! Flags
	  INTEGER :: qFlag,flag2, temp

		temp = 0
	do ib = 1, nbp ! lets sweep only the subdomains with makers

	  !if (myrank.eq.0) then ! The control is passed down to the master processor

	if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
												! markers are located
!		if (myrank .eq. 0) then !x2
!		if (myrank .eq. 8) then !x4


		dx_l = dom(ib)%dx
		dy_l= dom(ib)%dy
		dz_l= dom(ib)%dz
		dh = (dx_l*dy_l*dz_l)**(1.0D00/3)
		
		margin = 1.0e-9	!1.0e-5	! Margin for searching if arkers are within the boundaries of a cell
		
		origin_x = dom(ib)%x(1)
		origin_y = dom(ib)%y(1)
		origin_z = dom(ib)%z(1)
		
		origin_xc = dom(ib)%xc(1)
		origin_yc = dom(ib)%yc(1)
		origin_zc = dom(ib)%zc(1)

			! Bounds for u velocity component (NOT INCLUDING GHOST LAYERS)
		is=dom(ib)%isu; ie=dom(ib)%ieu
		js=dom(ib)%jsu; je=dom(ib)%jeu
		ks=dom(ib)%ksu; ke=dom(ib)%keu
		
		i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
		j_n_cells = dom(ib)%ttc_j
		k_n_cells = dom(ib)%ttc_k

		! CHECK: use uoo
		!	if (flag1.eq.1) then
		!	do kk=1,dom(ib)%ttc_k
		!	do ii=1,dom(ib)%ttc_i
		!	do jj=1,dom(ib)%ttc_j
		!	   	dom(ib)%ucpy(ii,jj,kk)=dom(ib)%ustar(ii,jj,kk)
		!	   	dom(ib)%vcpy(ii,jj,kk)=dom(ib)%vstar(ii,jj,kk)
		!	   	dom(ib)%wcpy(ii,jj,kk)=dom(ib)%wstar(ii,jj,kk)
		!	enddo
		!	enddo
		!	enddo
		!	elseif(flag1.eq.2) then
		!	do kk=1,dom(ib)%ttc_k
		!	do ii=1,dom(ib)%ttc_i
		!	do jj=1,dom(ib)%ttc_j
		!		dom(ib)%ucpy(ii,jj,kk)=dom(ib)%u(ii,jj,kk)
		!		dom(ib)%vcpy(ii,jj,kk)=dom(ib)%v(ii,jj,kk)
		!		dom(ib)%wcpy(ii,jj,kk)=dom(ib)%w(ii,jj,kk)
		!		dom(ib)%pcpy(ii,jj,kk)=dom(ib)%p(ii,jj,kk)
		!	enddo
		!	enddo
		!	enddo
	 	!	endif
		!
		! CHECK_AAA		do kk=1,dom(ib)%ttc_k
		! CHECK_AAA		do ii=1,dom(ib)%ttc_i
		! CHECK_AAA		do jj=1,dom(ib)%ttc_j
		! CHECK_AAA			dom(ib)%ucpy(ii,jj,kk)=dom(ib)%uoo(ii,jj,kk)
		! CHECK_AAA			dom(ib)%vcpy(ii,jj,kk)=dom(ib)%voo(ii,jj,kk)
		! CHECK_AAA			dom(ib)%wcpy(ii,jj,kk)=dom(ib)%woo(ii,jj,kk)
		! CHECK_AAA			dom(ib)%pcpy(ii,jj,kk)=dom(ib)%p(ii,jj,kk)
		! CHECK_AAA		enddo
		! CHECK_AAA		enddo
		! CHECK_AAA		enddo
		!
		! ghost cell method
		! Initiallizing current cell flags for the fluid cells currently inside the inmersed body
          do kk=1,dom(ib)%ttc_k
          do ii=1,dom(ib)%ttc_i
          do jj=1,dom(ib)%ttc_j
             dom(ib)%mucx(ii,jj,kk) = 0
             !dom(ib)%mvcy(ii,jj,kk) = 0
             dom(ib)%mwcz(ii,jj,kk) = 0
             dom(ib)%mpc(ii,jj,kk) = 0
          end do
          end do
          end do
		!
        nnStart = 0
        nnFinish = 0

        St_k = ibmSt(bodynum)
		! allocate(ibmSt(bodynum)) 
		! ibmSt : for each postion, it stores the number of stations defined in each body
		! St_k = 0	! counter of the total number of stations
		! do ii = 1, bodynum
		! 	St_k = St_k + ibmSt(ii)
		! enddo
		! allocate(ibmStMkrs(St_k)) ! for each postion jj, it stores the number of markers in station jj for body M
		! ibmStMkrs( (M-1)*ibmSt(M-1) + M*jj ) : number of markers at station jj for body M
		! 
		! ibmStMkrs
	!	mksPS = ibmStMkrs(ibmSt_k)	
		
		
		! St_k = 0	! counter of the total number of stations
		! do ii = 1, bodynum
		! 	St_k = St_k + ibmSt(ii)
		! enddo
		! allocate(ibmMkrsEL(St_k)) ! for each postion jj, it stores the number of markers in the exterior layer in station jj
		! ibmMkrsEL( (M-1)*ibmSt(M-1) + M*jj ) : number of markers at exterior layer in station k for body M
		! 
		! ibmMkrsEL
	!	mksEL = ibmMkrsEL(ibmSt_k)	! array with the size the number of bodies, bodynum
		do mm = 1, St_k	! sweeping stations
		!
		!layers2Sweep = 20
		!
		mksPS = ibmStMkrs(ibmSt_k)	! Markers per station
		mksEL = ibmMkrsEL(ibmSt_k)	! markers in exterior layer of each stations
		!
		nnFinish = mksEL + (mm-1)*mksPS
		nnStart = 1 + (mm-1)*mksPS
		!
		!do nn = 1, maxnodeIBS	! sweeping markers
		do nn = nnFinish+1, mm*mksPS
			IF(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
			!
			ll = 2
			!
			ndsx(1) = nodex_loc(nn) 
			ndsy(1) = nodey_loc(nn) 
			ndsz(1) = nodez_loc(nn)
			!
			iii = int ( ( ndsx(1) - origin_x - margin) /dx_l) + 2 
			jjc = int ( ( ndsy(1) - origin_yc - margin) /dy_l) + 2
			kkk = int ( ( ndsz(1) - origin_z - margin) /dz_l) + 2	! aka kkkn check note 1
			!
			iic = int ( ( ndsx(1) - origin_xc - margin) /dx_l) + 2 
			kkc = int ( ( ndsz(1) - origin_zc - margin) /dz_l) + 2
			!
										! Check for not modifying the ghost layer beyoud the boundaries of the control volume
			if (jjc .lt. js) then
				jjc = js
			endif
			if (jjc .gt. je) then
				jjc = je
			endif
			!
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Checking bounding box for u cell
			if((dom(ib)%x(iii-1)-margin).gt.ndsx(1)) then
				write(6,*) "Warning 1, bounding box too high!!"
			endif
			if((dom(ib)%x(iii)+margin).lt.ndsx(1)) then
				 write(6,*)  "Warning 2, bounding box too low!!"
			endif
			if((dom(ib)%zc(kkc-1)-margin).gt.ndsz(1)) then
				write(6,*) "Warning 3, bounding box too forward!!"
			endif
			if((dom(ib)%zc(kkc)+margin).lt.ndsz(1)) then
				write(6,*) "Warning 4, bounding box too behind!!"
			endif
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Checking bounding box for w cell
			if((dom(ib)%xc(iic-1)-margin).gt.ndsx(1)) then
				write(6,*) "Warning 11, bounding box too high!!"
			endif
			if((dom(ib)%xc(iic)+margin).lt.ndsx(1)) then
				 write(6,*)  "Warning 22, bounding box too low!!"
			endif
			if((dom(ib)%z(kkk-1)-margin).gt.ndsz(1)) then
				write(6,*) "Warning 33, bounding box too forward!!"
			endif
			if((dom(ib)%z(kkk)+margin).lt.ndsz(1)) then
				write(6,*) "Warning 44, bounding box too behind!!"
			endif
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Checking bounding box for p cell
			if((dom(ib)%xc(iic-1)-margin).gt.ndsx(1)) then
				write(6,*) "Warning 111, bounding box too high!!"
			endif
			if((dom(ib)%xc(iic)+margin).lt.ndsx(1)) then
				 write(6,*)  "Warning 222, bounding box too low!!"
			endif
			if((dom(ib)%zc(kkc-1)-margin).gt.ndsz(1)) then
				write(6,*) "Warning 333, bounding box too forward!!"
			endif
			if((dom(ib)%zc(kkc)+margin).lt.ndsz(1)) then
				write(6,*) "Warning 444, bounding box too behind!!"
			endif
			!
			!
			! Extrancting coordinates of the neighbouring markers from the same layer
			if (nn .eq. nnStart) then
										
				! Coordinates of the next marker, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nnFinish)
				ndsy(3) = nodey_loc(nnFinish)
				ndsz(3) = nodez_loc(nnFinish)
				
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
			
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nnFinish-1)
				ndsy(5) = nodey_loc(nnFinish-1)
				ndsz(5) = nodez_loc(nnFinish-1)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nnFinish-2)
				ndsy(7) = nodey_loc(nnFinish-2)
				ndsz(7) = nodez_loc(nnFinish-2)
			
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nnFinish-3)
				ndsy(9) = nodey_loc(nnFinish-3)
				ndsz(9) = nodez_loc(nnFinish-3)

				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nnFinish-4)
				ndsy(11) = nodey_loc(nnFinish-4)
				ndsz(11) = nodez_loc(nnFinish-4)
			
			elseif ( nn .eq. nnFinish) then
			
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nnStart)
				ndsy(2) = nodey_loc(nnStart)
				ndsz(2) = nodez_loc(nnStart)																				
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)
			
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nnStart+1)
				ndsy(4) = nodey_loc(nnStart+1)
				ndsz(4) = nodez_loc(nnStart+1)
				
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)		
				
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nnStart+2)
				ndsy(6) = nodey_loc(nnStart+2)
				ndsz(6) = nodez_loc(nnStart+2)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
				
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nnStart+3)
				ndsy(8) = nodey_loc(nnStart+3)
				ndsz(8) = nodez_loc(nnStart+3)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)

				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nnStart+4)
				ndsy(10) = nodey_loc(nnStart+4)
				ndsz(10) = nodez_loc(nnStart+4)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)
				
			
			elseif (nn .eq. nnStart+1) then
			
				! Coordinates of the next marker, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nnStart)
				ndsy(3) = nodey_loc(nnStart)
				ndsz(3) = nodez_loc(nnStart)
				
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
			
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nnFinish)
				ndsy(5) = nodey_loc(nnFinish)
				ndsz(5) = nodez_loc(nnFinish)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nnFinish-1)
				ndsy(7) = nodey_loc(nnFinish-1)
				ndsz(7) = nodez_loc(nnFinish-1)
				
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nnFinish-2)
				ndsy(9) = nodey_loc(nnFinish-2)
				ndsz(9) = nodez_loc(nnFinish-2)

				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nnFinish-3)
				ndsy(11) = nodey_loc(nnFinish-3)
				ndsz(11) = nodez_loc(nnFinish-3)

					
			elseif ( nn .eq. nnFinish-1) then
			
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nnFinish)
				ndsy(2) = nodey_loc(nnFinish)
				ndsz(2) = nodez_loc(nnFinish)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)
			
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nnStart)
				ndsy(4) = nodey_loc(nnStart)
				ndsz(4) = nodez_loc(nnStart)
			
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nnStart+1)
				ndsy(6) = nodey_loc(nnStart+1)
				ndsz(6) = nodez_loc(nnStart+1)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
			
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nnStart+2)
				ndsy(8) = nodey_loc(nnStart+2)
				ndsz(8) = nodez_loc(nnStart+2)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)
				
				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nnStart+3)
				ndsy(10) = nodey_loc(nnStart+3)
				ndsz(10) = nodez_loc(nnStart+3)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)
			
			elseif (nn .eq. nnStart+2) then
			
				! Coordinates of the next marker, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nnStart+1)
				ndsy(3) = nodey_loc(nnStart+1)
				ndsz(3) = nodez_loc(nnStart+1)
				
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
			
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nnStart)
				ndsy(5) = nodey_loc(nnStart)
				ndsz(5) = nodez_loc(nnStart)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nnFinish)
				ndsy(7) = nodey_loc(nnFinish)
				ndsz(7) = nodez_loc(nnFinish)
			
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nnFinish-1)
				ndsy(9) = nodey_loc(nnFinish-1)
				ndsz(9) = nodez_loc(nnFinish-1)

				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nnFinish-2)
				ndsy(11) = nodey_loc(nnFinish-2)
				ndsz(11) = nodez_loc(nnFinish-2)
			
			
			elseif ( nn .eq. nnFinish-2) then
			
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nnFinish-1)
				ndsy(2) = nodey_loc(nnFinish-1)
				ndsz(2) = nodez_loc(nnFinish-1)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)
			
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nnFinish)
				ndsy(4) = nodey_loc(nnFinish)
				ndsz(4) = nodez_loc(nnFinish)
			
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nnStart)
				ndsy(6) = nodey_loc(nnStart)
				ndsz(6) = nodez_loc(nnStart)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
			
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nnStart+1)
				ndsy(8) = nodey_loc(nnStart+1)
				ndsz(8) = nodez_loc(nnStart+1)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)
				
				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nnStart+2)
				ndsy(10) = nodey_loc(nnStart+2)
				ndsz(10) = nodez_loc(nnStart+2)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)                                            
			
				elseif (nn .eq. nnStart+3) then
			
					! Coordinates of the next marker, cn2
					ndsx(2) = nodex_loc(nn+1)
					ndsy(2) = nodey_loc(nn+1)
					ndsz(2) = nodez_loc(nn+1)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nnStart+2)
					ndsy(3) = nodey_loc(nnStart+2)
					ndsz(3) = nodez_loc(nnStart+2)
					
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nn+2)
					ndsy(4) = nodey_loc(nn+2)
					ndsz(4) = nodez_loc(nn+2)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nnStart+1)
					ndsy(5) = nodey_loc(nnStart+1)
					ndsz(5) = nodez_loc(nnStart+1)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nn+3)
					ndsy(6) = nodey_loc(nn+3)
					ndsz(6) = nodez_loc(nn+3)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nnStart)
					ndsy(7) = nodey_loc(nnStart)
					ndsz(7) = nodez_loc(nnStart)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nn+4)
					ndsy(8) = nodey_loc(nn+4)
					ndsz(8) = nodez_loc(nn+4)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nnFinish)
					ndsy(9) = nodey_loc(nnFinish)
					ndsz(9) = nodez_loc(nnFinish)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nn+5)
					ndsy(10) = nodey_loc(nn+5)
					ndsz(10) = nodez_loc(nn+5)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nnFinish-1)
					ndsy(11) = nodey_loc(nnFinish-1)
					ndsz(11) = nodez_loc(nnFinish-1)                                                
			
			
				elseif ( nn .eq. nnFinish-3) then
			
					! Coordinates of the next markers, cn2
					ndsx(2) = nodex_loc(nnFinish-2)
					ndsy(2) = nodey_loc(nnFinish-2)
					ndsz(2) = nodez_loc(nnFinish-2)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nn-1)
					ndsy(3) = nodey_loc(nn-1)
					ndsz(3) = nodez_loc(nn-1)
			
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nnFinish-1)
					ndsy(4) = nodey_loc(nnFinish-1)
					ndsz(4) = nodez_loc(nnFinish-1)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nn-2)
					ndsy(5) = nodey_loc(nn-2)
					ndsz(5) = nodez_loc(nn-2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nnFinish)
					ndsy(6) = nodey_loc(nnFinish)
					ndsz(6) = nodez_loc(nnFinish)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nn-3)
					ndsy(7) = nodey_loc(nn-3)
					ndsz(7) = nodez_loc(nn-3)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nnStart)
					ndsy(8) = nodey_loc(nnStart)
					ndsz(8) = nodez_loc(nnStart)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nn-4)
					ndsy(9) = nodey_loc(nn-4)
					ndsz(9) = nodez_loc(nn-4)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nnStart+1)
					ndsy(10) = nodey_loc(nnStart+1)
					ndsz(10) = nodez_loc(nnStart+1)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nn-5)
					ndsy(11) = nodey_loc(nn-5)
					ndsz(11) = nodez_loc(nn-5)
					

				elseif (nn .eq. nnStart+4) then
			
					! Coordinates of the next marker, cn2
					ndsx(2) = nodex_loc(nn+1)
					ndsy(2) = nodey_loc(nn+1)
					ndsz(2) = nodez_loc(nn+1)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nnStart+3)
					ndsy(3) = nodey_loc(nnStart+3)
					ndsz(3) = nodez_loc(nnStart+3)
					
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nn+2)
					ndsy(4) = nodey_loc(nn+2)
					ndsz(4) = nodez_loc(nn+2)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nnStart+2)
					ndsy(5) = nodey_loc(nnStart+2)
					ndsz(5) = nodez_loc(nnStart+2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nn+3)
					ndsy(6) = nodey_loc(nn+3)
					ndsz(6) = nodez_loc(nn+3)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nnStart+1)
					ndsy(7) = nodey_loc(nnStart+1)
					ndsz(7) = nodez_loc(nnStart+1)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nn+4)
					ndsy(8) = nodey_loc(nn+4)
					ndsz(8) = nodez_loc(nn+4)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nnStart)
					ndsy(9) = nodey_loc(nnStart)
					ndsz(9) = nodez_loc(nnStart)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nn+5)
					ndsy(10) = nodey_loc(nn+5)
					ndsz(10) = nodez_loc(nn+5)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nnFinish)
					ndsy(11) = nodey_loc(nnFinish)
					ndsz(11) = nodez_loc(nnFinish)
			
				elseif ( nn .eq. nnFinish-4) then
			
					! Coordinates of the next markers, cn2
					ndsx(2) = nodex_loc(nnFinish-3)
					ndsy(2) = nodey_loc(nnFinish-3)
					ndsz(2) = nodez_loc(nnFinish-3)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nn-1)
					ndsy(3) = nodey_loc(nn-1)
					ndsz(3) = nodez_loc(nn-1)
			
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nnFinish-2)
					ndsy(4) = nodey_loc(nnFinish-2)
					ndsz(4) = nodez_loc(nnFinish-2)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nn-2)
					ndsy(5) = nodey_loc(nn-2)
					ndsz(5) = nodez_loc(nn-2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nnFinish-1)
					ndsy(6) = nodey_loc(nnFinish-1)
					ndsz(6) = nodez_loc(nnFinish-1)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nn-3)
					ndsy(7) = nodey_loc(nn-3)
					ndsz(7) = nodez_loc(nn-3)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nnFinish)
					ndsy(8) = nodey_loc(nnFinish)
					ndsz(8) = nodez_loc(nnFinish)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nn-4)
					ndsy(9) = nodey_loc(nn-4)
					ndsz(9) = nodez_loc(nn-4)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nnStart)
					ndsy(10) = nodey_loc(nnStart)
					ndsz(10) = nodez_loc(nnStart)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nn-5)
					ndsy(11) = nodey_loc(nn-5)
					ndsz(11) = nodez_loc(nn-5)                                                

			else
			
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)										
			
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
				
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
			
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)

				! Coordinates of second previous marker, cn8
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)	
			
				! Coordinates of second previous marker, cn9
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)

			endif
			!
			flag2 = 0	
			!
			vec0u(1) = nn 
			vec0u(2) = ll 
			vec0u(3) = ib 
			vec0u(4) = iii
			vec0u(5) = jjc
			vec0u(6) = kkk
			vec0u(8) = lag_bod_loc(nn)
			!
			vec0w(1) = nn 
			vec0w(2) = ll 
			vec0w(3) = ib 
			vec0w(4) = iic
			vec0w(5) = jjc
			vec0w(6) = kkk
			vec0w(8) = lag_bod_loc(nn)
			!
			!if(flag1.eq.1) then
			!	!
			!	! ( 0, 90 ] First quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
			!	if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
			!		qFlag = 1
			!		 vec0u(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,1)
			!		!
			!		vec0w(7) = qFlag
			!		call setQuadrant_w(vec0w,ndsx,ndsz,1)
			!	endif
			!	endif
			!	! ( 90, 180 ] 2nd quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .le. -margin) then
			!	if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
			!		qFlag = 2
			!		vec0u(7) = qFlag
			!		vec0w(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,1)
			!		call setQuadrant_w(vec0w,ndsx,ndsz,1)
			!	endif
			!	endif
			!	! ( 180, 270 ] 3rd quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .le. margin) then
			!	if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
			!		qFlag = 3
			!		vec0u(7) = qFlag
			!		vec0w(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,1)
			!		call setQuadrant_w(vec0w,ndsx,ndsz,1)
			!	endif
			!	endif
			!	! ( 270, 360 ] 4th quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .gt. margin) then
			!	if ( (ndsz(2) - ndsz(1)) .le. margin) then
			!		qFlag = 4
			!		vec0u(7) = qFlag
			!		vec0w(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,1)
			!		call setQuadrant_w(vec0w,ndsx,ndsz,1)
			!	endif
			!	endif
			!	!
			!	elseif(flag1.eq.2) then	
				!
				! ( 0, 90 ] First quadrant?
				if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
				if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
					qFlag = 1
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				! ( 90, 180 ] 2nd quadrant?
				if ( (ndsx(2) - ndsx(1)) .le. -margin) then
				if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
					qFlag = 2
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				! ( 180, 270 ] 3rd quadrant?
				if ( (ndsx(2) - ndsx(1)) .le. margin) then
				if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
					qFlag = 3
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				! ( 270, 360 ] 4th quadrant?
				if ( (ndsx(2) - ndsx(1)) .gt. margin) then
				if ( (ndsz(2) - ndsz(1)) .le. margin) then
					qFlag = 4
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				!
			!	endif
				!
			ENDIF	! Ensuring processor ID matches subdomain ID???
		enddo
		!
		!
		!
		! ghost cell method
		! Initiallizing current cell flags for the fluid cells currently inside the inmersed body
		! debug
		!write(*,*) "ready",mm, dom(ib)%mucxold(94,11,127)
		!write(*,*) dom(ib)%ttc_i,dom(ib)%ttc_j,dom(ib)%ttc_k
          !do kk=1,dom(ib)%ttc_k
          !do ii=1,dom(ib)%ttc_i
          !do jj=1,dom(ib)%ttc_j
		  !   dom(ib)%mucxold(ii,jj,kk) = 0
		  !   ! debug
		  !   !if((ii.eq.94).and.(jj.eq.11).and.(kk.eq.127))then
		  !   !write(*,*) "Set	",dom(ib)%mucxold(ii,jj,kk)
		  !   !endif
          !   !dom(ib)%mvcyold(ii,jj,kk) = 0
          !   dom(ib)%mwczold(ii,jj,kk) = 0
          !   dom(ib)%mpcold(ii,jj,kk) = 0
          !end do
          !end do
          !end do
		! debug
		!  if(dom(ib)%mucxold(94,11,127).ne.0) then
		!	write(*,*) "WARNING WARNING WARNING", dom(ib)%mucxold(94,11,127)
		!  endif
		!  write(*,*) "========================", dom(ib)%mucxold(94,11,127)
		!
		!
		do nn = nnStart, nnFinish	!  sweeping markers outermost layer of each station
		 IF(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
			!
			ll = 1
			!
			ndsx(1) = nodex_loc(nn) 
			ndsy(1) = nodey_loc(nn) 
			ndsz(1) = nodez_loc(nn)
			!
			iii = int ( ( ndsx(1) - origin_x - margin) /dx_l) + 2 
			jjc = int ( ( ndsy(1) - origin_yc - margin) /dy_l) + 2
			kkk = int ( ( ndsz(1) - origin_z - margin) /dz_l) + 2	! aka kkkn check note 1
			!
			iic = int ( ( ndsx(1) - origin_xc - margin) /dx_l) + 2 
			kkc = int ( ( ndsz(1) - origin_zc - margin) /dz_l) + 2
!Note 1: It makes more sense to work with kkkn in u cells because it gives you the same kkc index for the cell centre of the cell
! that the marker mkz occupies.
! kkc		1		2		3		4		5
! c		0.7		1.7		2.7		3.7		4.7
!
! kkk		1		2		3		4		5
! F			1.2		2.2		3.2		4.2		5.2
!
! OZF	1.2
! OZC	0.7
! dz 	1.0
!
!	mkz		0.8		1.3		1.8		2.3
! 	kkks									0		1		1		2
!	kkcs	1		1		2		2
!
!	kkkn	1		2		2		3
!	kkcn	2		2		3		3
			! Check for not modifying the ghost layer beyoud the boundaries of the control volume
			if (jjc .lt. js) then
				jjc = js
			endif
			if (jjc .gt. je) then
				jjc = je
			endif
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Checking bounding box for u cell
			if((dom(ib)%x(iii-1)-margin).gt.ndsx(1)) then
				write(6,*) "Warning 1, bounding box too high!!"
			endif
			if((dom(ib)%x(iii)+margin).lt.ndsx(1)) then
				 write(6,*)  "Warning 2, bounding box too low!!"
			endif
			if((dom(ib)%zc(kkc-1)-margin).gt.ndsz(1)) then
				write(6,*) "Warning 3, bounding box too forward!!"
			endif
			if((dom(ib)%zc(kkc)+margin).lt.ndsz(1)) then
				write(6,*) "Warning 4, bounding box too behind!!"
			endif
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Checking bounding box for w cell
			if((dom(ib)%xc(iic-1)-margin).gt.ndsx(1)) then
				write(6,*) "Warning 11, bounding box too high!!"
			endif
			if((dom(ib)%xc(iic)+margin).lt.ndsx(1)) then
				 write(6,*)  "Warning 22, bounding box too low!!"
			endif
			if((dom(ib)%z(kkk-1)-margin).gt.ndsz(1)) then
				write(6,*) "Warning 33, bounding box too forward!!"
			endif
			if((dom(ib)%z(kkk)+margin).lt.ndsz(1)) then
				write(6,*) "Warning 44, bounding box too behind!!"
			endif
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Checking bounding box for p cell
			if((dom(ib)%xc(iic-1)-margin).gt.ndsx(1)) then
				write(6,*) "Warning 111, bounding box too high!!"
			endif
			if((dom(ib)%xc(iic)+margin).lt.ndsx(1)) then
				 write(6,*)  "Warning 222, bounding box too low!!"
			endif
			if((dom(ib)%zc(kkc-1)-margin).gt.ndsz(1)) then
				write(6,*) "Warning 333, bounding box too forward!!"
			endif
			if((dom(ib)%zc(kkc)+margin).lt.ndsz(1)) then
				write(6,*) "Warning 444, bounding box too behind!!"
			endif
			!
			!
			! Extrancting coordinates of the neighbouring markers from the same layer
			if (nn .eq. nnStart) then
										
				! Coordinates of the next marker, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nnFinish)
				ndsy(3) = nodey_loc(nnFinish)
				ndsz(3) = nodez_loc(nnFinish)
				
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
			
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nnFinish-1)
				ndsy(5) = nodey_loc(nnFinish-1)
				ndsz(5) = nodez_loc(nnFinish-1)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nnFinish-2)
				ndsy(7) = nodey_loc(nnFinish-2)
				ndsz(7) = nodez_loc(nnFinish-2)
			
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nnFinish-3)
				ndsy(9) = nodey_loc(nnFinish-3)
				ndsz(9) = nodez_loc(nnFinish-3)

				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nnFinish-4)
				ndsy(11) = nodey_loc(nnFinish-4)
				ndsz(11) = nodez_loc(nnFinish-4)
			
			elseif ( nn .eq. nnFinish) then
			
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nnStart)
				ndsy(2) = nodey_loc(nnStart)
				ndsz(2) = nodez_loc(nnStart)																				
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)
			
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nnStart+1)
				ndsy(4) = nodey_loc(nnStart+1)
				ndsz(4) = nodez_loc(nnStart+1)
				
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)		
				
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nnStart+2)
				ndsy(6) = nodey_loc(nnStart+2)
				ndsz(6) = nodez_loc(nnStart+2)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
				
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nnStart+3)
				ndsy(8) = nodey_loc(nnStart+3)
				ndsz(8) = nodez_loc(nnStart+3)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)

				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nnStart+4)
				ndsy(10) = nodey_loc(nnStart+4)
				ndsz(10) = nodez_loc(nnStart+4)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)
				
			
			elseif (nn .eq. nnStart+1) then
			
				! Coordinates of the next marker, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nnStart)
				ndsy(3) = nodey_loc(nnStart)
				ndsz(3) = nodez_loc(nnStart)
				
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
			
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nnFinish)
				ndsy(5) = nodey_loc(nnFinish)
				ndsz(5) = nodez_loc(nnFinish)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nnFinish-1)
				ndsy(7) = nodey_loc(nnFinish-1)
				ndsz(7) = nodez_loc(nnFinish-1)
				
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nnFinish-2)
				ndsy(9) = nodey_loc(nnFinish-2)
				ndsz(9) = nodez_loc(nnFinish-2)

				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nnFinish-3)
				ndsy(11) = nodey_loc(nnFinish-3)
				ndsz(11) = nodez_loc(nnFinish-3)

					
			elseif ( nn .eq. nnFinish-1) then
			
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nnFinish)
				ndsy(2) = nodey_loc(nnFinish)
				ndsz(2) = nodez_loc(nnFinish)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)
			
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nnStart)
				ndsy(4) = nodey_loc(nnStart)
				ndsz(4) = nodez_loc(nnStart)
			
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nnStart+1)
				ndsy(6) = nodey_loc(nnStart+1)
				ndsz(6) = nodez_loc(nnStart+1)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
			
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nnStart+2)
				ndsy(8) = nodey_loc(nnStart+2)
				ndsz(8) = nodez_loc(nnStart+2)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)
				
				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nnStart+3)
				ndsy(10) = nodey_loc(nnStart+3)
				ndsz(10) = nodez_loc(nnStart+3)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)
			
			elseif (nn .eq. nnStart+2) then
			
				! Coordinates of the next marker, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nnStart+1)
				ndsy(3) = nodey_loc(nnStart+1)
				ndsz(3) = nodez_loc(nnStart+1)
				
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
			
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nnStart)
				ndsy(5) = nodey_loc(nnStart)
				ndsz(5) = nodez_loc(nnStart)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nnFinish)
				ndsy(7) = nodey_loc(nnFinish)
				ndsz(7) = nodez_loc(nnFinish)
			
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nnFinish-1)
				ndsy(9) = nodey_loc(nnFinish-1)
				ndsz(9) = nodez_loc(nnFinish-1)

				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nnFinish-2)
				ndsy(11) = nodey_loc(nnFinish-2)
				ndsz(11) = nodez_loc(nnFinish-2)
			
			
			elseif ( nn .eq. nnFinish-2) then
			
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nnFinish-1)
				ndsy(2) = nodey_loc(nnFinish-1)
				ndsz(2) = nodez_loc(nnFinish-1)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)
			
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nnFinish)
				ndsy(4) = nodey_loc(nnFinish)
				ndsz(4) = nodez_loc(nnFinish)
			
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nnStart)
				ndsy(6) = nodey_loc(nnStart)
				ndsz(6) = nodez_loc(nnStart)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
			
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nnStart+1)
				ndsy(8) = nodey_loc(nnStart+1)
				ndsz(8) = nodez_loc(nnStart+1)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)
				
				! Coordinates of second previous marker, cn10
				ndsx(10) = nodex_loc(nnStart+2)
				ndsy(10) = nodey_loc(nnStart+2)
				ndsz(10) = nodez_loc(nnStart+2)
				
				! Coordinates of second previous marker, cn11
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)                                            
			
				elseif (nn .eq. nnStart+3) then
			
					! Coordinates of the next marker, cn2
					ndsx(2) = nodex_loc(nn+1)
					ndsy(2) = nodey_loc(nn+1)
					ndsz(2) = nodez_loc(nn+1)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nnStart+2)
					ndsy(3) = nodey_loc(nnStart+2)
					ndsz(3) = nodez_loc(nnStart+2)
					
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nn+2)
					ndsy(4) = nodey_loc(nn+2)
					ndsz(4) = nodez_loc(nn+2)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nnStart+1)
					ndsy(5) = nodey_loc(nnStart+1)
					ndsz(5) = nodez_loc(nnStart+1)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nn+3)
					ndsy(6) = nodey_loc(nn+3)
					ndsz(6) = nodez_loc(nn+3)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nnStart)
					ndsy(7) = nodey_loc(nnStart)
					ndsz(7) = nodez_loc(nnStart)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nn+4)
					ndsy(8) = nodey_loc(nn+4)
					ndsz(8) = nodez_loc(nn+4)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nnFinish)
					ndsy(9) = nodey_loc(nnFinish)
					ndsz(9) = nodez_loc(nnFinish)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nn+5)
					ndsy(10) = nodey_loc(nn+5)
					ndsz(10) = nodez_loc(nn+5)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nnFinish-1)
					ndsy(11) = nodey_loc(nnFinish-1)
					ndsz(11) = nodez_loc(nnFinish-1)                                                
			
			
				elseif ( nn .eq. nnFinish-3) then
			
					! Coordinates of the next markers, cn2
					ndsx(2) = nodex_loc(nnFinish-2)
					ndsy(2) = nodey_loc(nnFinish-2)
					ndsz(2) = nodez_loc(nnFinish-2)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nn-1)
					ndsy(3) = nodey_loc(nn-1)
					ndsz(3) = nodez_loc(nn-1)
			
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nnFinish-1)
					ndsy(4) = nodey_loc(nnFinish-1)
					ndsz(4) = nodez_loc(nnFinish-1)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nn-2)
					ndsy(5) = nodey_loc(nn-2)
					ndsz(5) = nodez_loc(nn-2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nnFinish)
					ndsy(6) = nodey_loc(nnFinish)
					ndsz(6) = nodez_loc(nnFinish)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nn-3)
					ndsy(7) = nodey_loc(nn-3)
					ndsz(7) = nodez_loc(nn-3)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nnStart)
					ndsy(8) = nodey_loc(nnStart)
					ndsz(8) = nodez_loc(nnStart)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nn-4)
					ndsy(9) = nodey_loc(nn-4)
					ndsz(9) = nodez_loc(nn-4)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nnStart+1)
					ndsy(10) = nodey_loc(nnStart+1)
					ndsz(10) = nodez_loc(nnStart+1)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nn-5)
					ndsy(11) = nodey_loc(nn-5)
					ndsz(11) = nodez_loc(nn-5)
					

				elseif (nn .eq. nnStart+4) then
			
					! Coordinates of the next marker, cn2
					ndsx(2) = nodex_loc(nn+1)
					ndsy(2) = nodey_loc(nn+1)
					ndsz(2) = nodez_loc(nn+1)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nnStart+3)
					ndsy(3) = nodey_loc(nnStart+3)
					ndsz(3) = nodez_loc(nnStart+3)
					
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nn+2)
					ndsy(4) = nodey_loc(nn+2)
					ndsz(4) = nodez_loc(nn+2)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nnStart+2)
					ndsy(5) = nodey_loc(nnStart+2)
					ndsz(5) = nodez_loc(nnStart+2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nn+3)
					ndsy(6) = nodey_loc(nn+3)
					ndsz(6) = nodez_loc(nn+3)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nnStart+1)
					ndsy(7) = nodey_loc(nnStart+1)
					ndsz(7) = nodez_loc(nnStart+1)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nn+4)
					ndsy(8) = nodey_loc(nn+4)
					ndsz(8) = nodez_loc(nn+4)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nnStart)
					ndsy(9) = nodey_loc(nnStart)
					ndsz(9) = nodez_loc(nnStart)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nn+5)
					ndsy(10) = nodey_loc(nn+5)
					ndsz(10) = nodez_loc(nn+5)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nnFinish)
					ndsy(11) = nodey_loc(nnFinish)
					ndsz(11) = nodez_loc(nnFinish)
			
				elseif ( nn .eq. nnFinish-4) then
			
					! Coordinates of the next markers, cn2
					ndsx(2) = nodex_loc(nnFinish-3)
					ndsy(2) = nodey_loc(nnFinish-3)
					ndsz(2) = nodez_loc(nnFinish-3)
			
					! Coordinates of the previous marker, cn3
					ndsx(3) = nodex_loc(nn-1)
					ndsy(3) = nodey_loc(nn-1)
					ndsz(3) = nodez_loc(nn-1)
			
					! Coordinates of second next marker, cn4
					ndsx(4) = nodex_loc(nnFinish-2)
					ndsy(4) = nodey_loc(nnFinish-2)
					ndsz(4) = nodez_loc(nnFinish-2)
			
					! Coordinates of second previous marker, cn5
					ndsx(5) = nodex_loc(nn-2)
					ndsy(5) = nodey_loc(nn-2)
					ndsz(5) = nodez_loc(nn-2)
			
					! Coordinates of second previous marker, cn6
					ndsx(6) = nodex_loc(nnFinish-1)
					ndsy(6) = nodey_loc(nnFinish-1)
					ndsz(6) = nodez_loc(nnFinish-1)	
			
					! Coordinates of second previous marker, cn7
					ndsx(7) = nodex_loc(nn-3)
					ndsy(7) = nodey_loc(nn-3)
					ndsz(7) = nodez_loc(nn-3)
			
					! Coordinates of second previous marker, cn8
					ndsx(8) = nodex_loc(nnFinish)
					ndsy(8) = nodey_loc(nnFinish)
					ndsz(8) = nodez_loc(nnFinish)	
			
					! Coordinates of second previous marker, cn9
					ndsx(9) = nodex_loc(nn-4)
					ndsy(9) = nodey_loc(nn-4)
					ndsz(9) = nodez_loc(nn-4)

					! Coordinates of second previous marker, cn10
					ndsx(10) = nodex_loc(nnStart)
					ndsy(10) = nodey_loc(nnStart)
					ndsz(10) = nodez_loc(nnStart)

					! Coordinates of second previous marker, cn11
					ndsx(11) = nodex_loc(nn-5)
					ndsy(11) = nodey_loc(nn-5)
					ndsz(11) = nodez_loc(nn-5)                                                

			else
			
				! Coordinates of the next markers, cn2
				ndsx(2) = nodex_loc(nn+1)
				ndsy(2) = nodey_loc(nn+1)
				ndsz(2) = nodez_loc(nn+1)
			
				! Coordinates of the previous marker, cn3
				ndsx(3) = nodex_loc(nn-1)
				ndsy(3) = nodey_loc(nn-1)
				ndsz(3) = nodez_loc(nn-1)										
			
				! Coordinates of second next marker, cn4
				ndsx(4) = nodex_loc(nn+2)
				ndsy(4) = nodey_loc(nn+2)
				ndsz(4) = nodez_loc(nn+2)
				
				! Coordinates of second previous marker, cn5
				ndsx(5) = nodex_loc(nn-2)
				ndsy(5) = nodey_loc(nn-2)
				ndsz(5) = nodez_loc(nn-2)
			
				! Coordinates of second previous marker, cn6
				ndsx(6) = nodex_loc(nn+3)
				ndsy(6) = nodey_loc(nn+3)
				ndsz(6) = nodez_loc(nn+3)	
			
				! Coordinates of second previous marker, cn7
				ndsx(7) = nodex_loc(nn-3)
				ndsy(7) = nodey_loc(nn-3)
				ndsz(7) = nodez_loc(nn-3)
			
				! Coordinates of second previous marker, cn8
				ndsx(8) = nodex_loc(nn+4)
				ndsy(8) = nodey_loc(nn+4)
				ndsz(8) = nodez_loc(nn+4)	
			
				! Coordinates of second previous marker, cn9
				ndsx(9) = nodex_loc(nn-4)
				ndsy(9) = nodey_loc(nn-4)
				ndsz(9) = nodez_loc(nn-4)

				! Coordinates of second previous marker, cn8
				ndsx(10) = nodex_loc(nn+5)
				ndsy(10) = nodey_loc(nn+5)
				ndsz(10) = nodez_loc(nn+5)	
			
				! Coordinates of second previous marker, cn9
				ndsx(11) = nodex_loc(nn-5)
				ndsy(11) = nodey_loc(nn-5)
				ndsz(11) = nodez_loc(nn-5)

			endif
			!
			flag2 = 0
			!
			!
			vec0u(1) = nn 
			vec0u(2) = ll 
			vec0u(3) = ib 
			vec0u(4) = iii
			vec0u(5) = jjc
			vec0u(6) = kkk
			vec0u(8) = lag_bod_loc(nn)
			!
			vec0w(1) = nn 
			vec0w(2) = ll 
			vec0w(3) = ib 
			vec0w(4) = iic
			vec0w(5) = jjc
			vec0w(6) = kkk
			vec0w(8) = lag_bod_loc(nn)
			!
			!if(flag1.eq.1) then
			!	!
			!	!
			!	! ( 0, 90 ] First quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
			!	if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
			!		qFlag = 1
			!		vec0u(7) = qFlag
			!		vec0w(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,1)
			!		call setQuadrant_w(vec0w,ndsx,ndsz,1)
			!	endif
			!	endif
			!	! ( 90, 180 ] 2nd quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .le. -margin) then
			!	if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
			!		qFlag = 2
			!		vec0u(7) = qFlag
			!		vec0w(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,1)
			!		call setQuadrant_w(vec0w,ndsx,ndsz,1)
			!	endif
			!	endif
			!	! ( 180, 270 ] 3rd quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .le. margin) then
			!	if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
			!		qFlag = 3
			!		vec0u(7) = qFlag
			!		vec0w(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,1)
			!		call setQuadrant_w(vec0w,ndsx,ndsz,1)
			!	endif
			!	endif
			!	! ( 270, 360 ] 4th quadrant?
			!	if ( (ndsx(2) - ndsx(1)) .gt. margin) then
			!	if ( (ndsz(2) - ndsz(1)) .le. margin) then
			!		qFlag = 4
			!		vec0u(7) = qFlag
			!		vec0w(7) = qFlag
			!		call setQuadrant_u(vec0u,ndsx,ndsz,1)
			!		call setQuadrant_w(vec0w,ndsx,ndsz,1)
			!	endif
			!	endif
			!	!
			!	elseif(flag1.eq.2) then
			!	!
				! ( 0, 90 ] First quadrant?
				if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
				if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
					qFlag = 1
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				! ( 90, 180 ] 2nd quadrant?
				if ( (ndsx(2) - ndsx(1)) .le. -margin) then
				if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
					qFlag = 2
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				! ( 180, 270 ] 3rd quadrant?
				if ( (ndsx(2) - ndsx(1)) .le. margin) then
				if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
					qFlag = 3
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				! ( 270, 360 ] 4th quadrant?
				if ( (ndsx(2) - ndsx(1)) .gt. margin) then
				if ( (ndsz(2) - ndsz(1)) .le. margin) then
					qFlag = 4
					vec0u(7) = qFlag
					vec0w(7) = qFlag
					call setQuadrant_u(vec0u,ndsx,ndsz,2)
					call setQuadrant_w(vec0w,ndsx,ndsz,2)
					call setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkk,qFlag)
				endif
				endif
				!
			!	endif
				!
				!
		! endif ! Filetring interior layers

		 endif	! Ensuring processor ID matches subdomain ID???
		enddo	!  sweeping markers outermost layer of each station
		!
		enddo	! sweeping stations
		!
		!
	endif ! Filtering out procesors
	!
	enddo ! End of the  loop sweeping the domains

!######################################################################
	END SUBROUTINE searchGhostCells
!######################################################################	


!######################################################################			
	SUBROUTINE setQuadrant_u(vec0,ndsx,ndsz,fieldF)
!######################################################################		
		use imb
		use mpi
		use multidata

		implicit none

		! temporal variables
		DOUBLE PRECISION:: temp, t1, t2

		! Input valriables
		INTEGER, INTENT(IN):: vec0(8)
		INTEGER:: nn, ll, ib, iii,jjj,kkk, qF, M
		INTEGER, INTENT(IN):: fieldF
		DOUBLE PRECISION, INTENT(IN)::ndsx(11),ndsz(11)

		! safety variables
		DOUBLE PRECISION:: margin

		! Intersections
		DOUBLE PRECISION:: ys, ys2

		! Locations of faces
		DOUBLE PRECISION:: as3,as2,as,ae,ae2,ae3

		DOUBLE PRECISION:: cs3,cs2,cs,ce,ce2,ce3		

		DOUBLE PRECISION:: zc0,zc1, zc2, zc3, zc4

		! Indeces of faces
		INTEGER:: ke0,ke,ke2,ke3,ke4
		INTEGER:: ie,is, is2, is3

		! Special variables for avoiding selecting cell outise the geometry in the 2nd and 4th quarters
		INTEGER:: isq, keq, ieq
		DOUBLE PRECISION:: asq, aeq
		INTEGER:: fxq1, fzq1, fxq2, fzq2, fxs3, fzs3, fxk3, fzk3
		!
		! Flags
		INTEGER:: flag1, flag2,flagA,flagB,flagC
		DOUBLE PRECISION:: fx, fz

		! Interfaces
		INTEGER:: vec1(8)
		!
		!
		!
		nn  = vec0(1)
		ll  = vec0(2)
		ib  = vec0(3)
		iii = vec0(4)
		jjj = vec0(5)
		kkk = vec0(6)
		qF  = vec0(7)
		 M  = vec0(8)
		 !
		vec1(1) = nn
		vec1(2) = ib
		vec1(3) = ll
		vec1(4) = iii
		vec1(5) = jjj
		vec1(6) = kkk
		vec1(7) = qF
		vec1(8) = M

		margin = 1.0e-5

	!	if (myrank.eq. master ) then ! The control is passed down to the master processor
		if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN
			IF(imb_block_loc(nn).eq.dom_id(ib)) then
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 1st quadrant
				
		if (qF.eq.1) then

		as3 = dom(ib)%x(iii-3)
		as2 = dom(ib)%x(iii-2)	
		as = dom(ib)%x(iii-1) 
		asq = as

		ae = dom(ib)%x(iii) 
		aeq = as !ae
		
		ae2 = dom(ib)%x(iii+1)
		ae3 = dom(ib)%x(iii+2)
		
		cs3 = dom(ib)%z(kkk-3)
		cs2 = dom(ib)%z(kkk-2)
		cs = dom(ib)%z(kkk-1)

		ce = dom(ib)%z(kkk) 
		ce2 = dom(ib)%z(kkk+1)
		ce3 = dom(ib)%z(kkk+2)	

		zc1 = dom(ib)%zc(kkk)	! cell cetre. We want to obtain the mirror value for this cell centre
		zc2 = dom(ib)%zc(kkk+1)	! cell cetre. We want to obtain the mirror value for this cell centre
		zc3 = dom(ib)%zc(kkk+2)	! cell cetre. We want to obtain the mirror value for this cell centre
		zc4 = dom(ib)%zc(kkk+3)	! cell cetre. We want to obtain the mirror value for this cell centre		

		

		ie = iii; ke = kkk
		ke2 = kkk+1; ke3 = kkk+2; ke4 = kkk+3

		is = iii-1 ; is2 = iii-2; is3 = iii - 3
		isq = is; keq = ke
		ieq = is	

		fx = 1
		fz = 1
		fxq1 = fx
		fzq1 = fz
		fxq2 = fx
		fzq2 = fz
		fxs3 = fx
		fzs3 = fz

		endif

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 2nd quadrant

		if (qF.eq.2) then

			ae3 = dom(ib)%x(iii-3)
			ae2 = dom(ib)%x(iii-2)	



			ae = dom(ib)%x(iii-1) 
	
			as = dom(ib)%x(iii) 
			asq = ae
			aeq = ae

			as2 = dom(ib)%x(iii-2)

			as3 = dom(ib)%x(iii-3)

			

			cs3 = dom(ib)%z(kkk-3)
			cs2 = dom(ib)%z(kkk-2)
			cs = dom(ib)%z(kkk-1)
	
			ce = dom(ib)%z(kkk) 
			ce2 = dom(ib)%z(kkk+1)
			ce3 = dom(ib)%z(kkk+2)			

			zc1 = dom(ib)%zc(kkk)	! cell cetre. We want to obtain the mirror value for this cell centre
			zc2 = dom(ib)%zc(kkk-1)	! cell cetre. We want to obtain the mirror value for this cell centre
			zc3 = dom(ib)%zc(kkk-2)	! cell cetre. We want to obtain the mirror value for this cell centre
			zc4 = dom(ib)%zc(kkk-3)	! cell cetre. We want to obtain the mirror value for this cell centre				
	
			ie = iii-1; ke = kkk
			ke2 = kkk-1; ke3 = kkk-2; ke4 = kkk-3
	
			is = iii; is2 = iii-2; is3 = iii - 3
			isq = is; keq = kkk + 1
			ieq = ie
				
			fx = -1
			fz = -1
			fxq1 = fx
			fzq1 = fz
			fxq2 = -fx
			fzq2 = -fz
			fxs3 = -fx
			fzs3 = -fz
	
			endif


		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 3rd quadrant
				
			if (qF.eq.3) then

				ae3 = dom(ib)%x(iii-3)
				ae2 = dom(ib)%x(iii-2)	
				ae = dom(ib)%x(iii-1) 
		
				as = dom(ib)%x(iii) 
				asq = as
				aeq = as
	
				as2 = dom(ib)%x(iii+1)
	
				as3 = dom(ib)%x(iii+2)
	
				
	
				cs3 = dom(ib)%z(kkk-3)
				cs2 = dom(ib)%z(kkk-2)
				cs = dom(ib)%z(kkk-1)
		
				ce = dom(ib)%z(kkk) 
				ce2 = dom(ib)%z(kkk+1)
				ce3 = dom(ib)%z(kkk+2)	

				zc1 = dom(ib)%zc(kkk)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc2 = dom(ib)%zc(kkk-1)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc3 = dom(ib)%zc(kkk-2)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc4 = dom(ib)%zc(kkk-3)	! cell cetre. We want to obtain the mirror value for this cell centre					
		
				ie = iii-1; ke = kkk
				ke2 = kkk-1; ke3 = kkk-2; ke4 = kkk-3				
		
				is = iii; is2 = iii+1; is3 = iii+2
				isq = is; keq = ke		
				ieq = is
						
			!	is = iii; is2 = iii; is3 = iii + 1

				fx = -1
				fz = -1
				fxq1 = -fx
				fzq1 = -fz
				fxq2 = fx
				fzq2 = fz
				fxs3 = fx
				fzs3 = fz
			
		
				endif			

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 4th quadrant
				
			if (qF.eq.4) then

				ae3 = dom(ib)%x(iii+2)
				ae2 = dom(ib)%x(iii+1)	
				ae = dom(ib)%x(iii) 
				!
				as = dom(ib)%x(iii-1) 
				asq = ae
				aeq = ae
				as2 = dom(ib)%x(iii+1)
				as3 = dom(ib)%x(iii+2)
	
				
	
				cs3 = dom(ib)%z(kkk-3)
				cs2 = dom(ib)%z(kkk-2)
				cs = dom(ib)%z(kkk-1)
		
				ce = dom(ib)%z(kkk) 
				ce2 = dom(ib)%z(kkk+1)
				ce3 = dom(ib)%z(kkk+2)	

				zc1 = dom(ib)%zc(kkk)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc2 = dom(ib)%zc(kkk+1)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc3 = dom(ib)%zc(kkk+2)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc4 = dom(ib)%zc(kkk+3)	! cell cetre. We want to obtain the mirror value for this cell centre					

				ie = iii; ke = kkk
				ke2 = kkk+1; ke3 = kkk+2; ke4 = kkk+3
		
				is = iii-1; is2 = iii+1; is3 = iii+2
				isq = ie; keq = kkk - 1
				ieq = ie
		
				fx = 1
				fz = 1
				fxq1 = fx
				fzq1 = fz
				fxq2 = -fx
				fzq2 = -fz
				fxs3 = -fx
				fzs3 = -fz
		
				endif

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Checking quadrants

		flag1 = 0
		flag2 = 0
		flagA = 0
		flagB = 0

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE E

		if ( ( ndsx(2) -  ae )*fx.gt. -margin ) then	! The East Face is pierced for the FIRTS TIME
			!
			ys = ndsz(1) + (ndsz(2) - ndsz(1))*(ae - ndsx(1))/(ndsx(2) - ndsx(1))
			!
			! case a.1.1.1	 Checking if u(ie,jjj,ke) is above cn-cn2
			!12345 if(dom(ib)%mucxold(ie,jjj,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1)then
			if( ( zc1 - ys)*fz .gt. -margin ) then		
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2  !CHECK12345 
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
		        ! There  may be an issue			
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
					!dom(ib)%uoo(ie,jjj,ke) = t2
					! debug
					!if((nn.gt.9240).and.(nn.lt.(9240+126))) then
					!	!	write(6,*) nn, k ,rott_loc(nn)
					!		write(6,*) nn, ie,jjj,ke
					!		write(6,*) dom(ib)%mucx(ie,jjj,ke),qF
					!		write(6,*) !dom(ib)%uoo(ie,jjj,ke)
					!	!write(6,*) qF, fieldF, fieldVal
					!	!write(6,*) vec2(1),vec2(2),vec2(3)
					!	!write(6,*) vec2(4),vec2(5),vec2(6)
					!	!write(6,*) vec2(7),vec2(8)
					!	!write(6,*) vec3(1),vec3(2),vec3(3)
					!	!write(6,*) "======================="
					!endif
				endif
			!endif
			! case a.1.1.2	 Checking if u(ie,jjj,ke4) is above cn-cn2
			else
				!flag2 = 1
				flagA = 1
		
			endif
			!
			!else!12345
			!
			! debug
			! if((nn.gt.9240).and.(nn.lt.(9240+126))) then
			! !	write(6,*) nn, k ,rott_loc(nn)
			! 	if(fieldF.eq.1) then
			! 	write(6,*) nn, ie,jjj,ke
			! 	write(6,*) dom(ib)%mucxold(ie,jjj,ke),qF
			! 	write(6,*) dom(ib)%ustar(ie,jjj,ke),  fieldF
			! 	endif
			! 	if(fieldF.eq.2) then
			! 	write(6,*) nn, ie,jjj,ke
			! 	write(6,*) dom(ib)%mucxold(ie,jjj,ke),qF
			! 	write(6,*) dom(ib)%u(ie,jjj,ke),  fieldF
			! 	endif
			! !write(6,*) qF, fieldF, fieldVal
			! !write(6,*) vec2(1),vec2(2),vec2(3)
			! !write(6,*) vec2(4),vec2(5),vec2(6)
			! !write(6,*) vec2(7),vec2(8)
			! !write(6,*) vec3(1),vec3(2),vec3(3)
			! !write(6,*) "======================="
			! endif
			!
			!endif!12345 
			!
			!
			!
		! case a.1.1.2	 Checking if u(ie,jjj,ke2) is above cn-cn2
			!12345 if(dom(ib)%mucxold(ie,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			if( ( zc2 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
				! There  may be an issue			
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                    !dom(ib)%uoo(ie,jjj,ke2) = t2
				endif		
			endif
			!endif!12345 
			!
			!
			!
			! case a.1.1.2	 Checking if u(ie,jjj,ke3) is above cn-cn2
			!12345 if(dom(ib)%mucxold(ie,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			if( ( zc3 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				! There  may be an issue
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                    !dom(ib)%uoo(ie,jjj,ke3) = t2
				endif
			endif
			!endif!12345 
			!
			!
			!
		elseif ( ( ndsx(4) - ae )*fx .gt. -margin ) then	! The East face is pierced for the FIRST TIME
		!
		ys = ndsz(2) + (ndsz(4)-ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
		!
			! case a.2.1.1	Checking if u(ie,jjj,ke) is above cn2-cn4
			!12345 if(dom(ib)%mucxold(ie,jjj,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                        !dom(ib)%uoo(ie,jjj,ke) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke) = t2
                    !dom(ib)%uoo(ie,jjj,ke) = t2
				endif			
			else
				!flag2 = 1
				flagB = 1
			endif
			!endif!12345 
	
			! case a.2.1.2  Checking if u(ie,jjj,ke2) is above cn2-cn4 
			!12345 if(dom(ib)%mucxold(ie,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			if( ( zc2 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                        !dom(ib)%uoo(ie,jjj,ke2) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke2) = t2
                    !dom(ib)%uoo(ie,jjj,ke2) = t2
				endif		
			endif
			!endif!12345 
			!
			!
		! case a.1.1.2	 Checking if u(ie,jjj,ke3) is above cn-cn2
			!12345 if(dom(ib)%mucxold(ie,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			if( ( zc3 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                        !dom(ib)%uoo(ie,jjj,ke3) = t2
					endif
		! There  may be an issue
				else
					call setMirror_u(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke3) = t2
                    !dom(ib)%uoo(ie,jjj,ke3) = t2
				endif		
			endif
			!endif!12345 
			!
			!
			!
		! WARNING A				
		!else			
		elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too
			!
			! case a.2.1.1	Checking if u(ieq,jjj,ke) is above cn4-cn6
			!12345 if(dom(ib)%mucxold(ieq,jjj,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
				if( ( zc1 - ys2)*fzq1 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke) = t2
                    !dom(ib)%uoo(ieq,jjj,ke) = t2
				endif
			elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
				if( ( zc1 - ys2)*fzq1 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke) = t2
                    !dom(ib)%uoo(ieq,jjj,ke) = t2
				endif
		! There  may be an issue			
			else
				call setMirror_u(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
                !if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke) = t2
                !dom(ib)%uoo(ieq,jjj,ke) = t2
			endif
			!endif!12345 
			!
			!
	!	! case a.2.1.2  Checking if u(ieq,jjj,ke2) is above cn4-cn6 
			!12345 if(dom(ib)%mucxold(ieq,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
			if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
				if( ( zc2 - ys2)*fzq1 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke2) = t2
                    !dom(ib)%uoo(ieq,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
				if( ( zc2 - ys2)*fzq1 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke2) = t2
                    !dom(ib)%uoo(ieq,jjj,ke2) = t2
				endif
	!		elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too
	!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
	!			if ( ( zc2 - ys2)*fzq1 .lt. margin) then
	!			call setMirror_u(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
    !            !if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke2) = t2
    !            !dom(ib)%uoo(ieq,jjj,ke2) = t2
	!			endif
	! There  may be an issue			
			else
				call setMirror_u(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
                !if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke2) = t2
                !dom(ib)%uoo(ieq,jjj,ke2) = t2
			endif
			!endif!12345 
			!
			!
	! case a.1.1.2	 Checking if u(ieq,jjj,ke3) is above cn4-cn6
			!12345 if(dom(ib)%mucxold(ieq,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
				!if(1) then	! checking if this cell has already been flagged
			if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
				if( ( zc3 - ys2)*fzq1 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke3) = t2
                    !dom(ib)%uoo(ieq,jjj,ke3) = t2
				endif
			elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
				if( ( zc3 - ys2)*fzq1 .lt. margin) then
					call setMirror_u(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke3) = t2
                    !dom(ib)%uoo(ieq,jjj,ke3) = t2
				endif
	!		elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn4 pierced the East face too
	!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
	!			if ( ( zc3 - ys2)*fzq1 .lt. margin) then
	!			call setMirror_u(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
	!			!if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke3) = t2
	!			endif
	! There  may be an issue			
			else
				call setMirror_u(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
                !if(fieldF.eq.1) dom(ib)%ustar(ieq,jjj,ke3) = t2
                !dom(ib)%uoo(ieq,jjj,ke3) = t2
			endif
			!endif!12345 
			!
			!
		! WARNING A	
		!else	! The East face has not been pierced 
			flag1 = 1
			!
		endif !!! FINISHED CHECKING FACE E
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S
		!
		!12345 if(dom(ib)%mucxold(is,jjj,ke).eq.0) then	! checking if this cell has already been flagged
        !if(1) then	! checking if this cell has already been flagged
        !   1 1       -1 -1      -1 -1      1 1
		if ( (ndsx(3) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
		! 1q	if pierced  ./	ndsx(3) < as	fx > 0	pass
		! 2q		||		.\	ndsx(3) > as	fx < 0	pass
		! 3q		||		/*	ndsx(3) > as	fx < 0	pass
		! 4q		||		\*	ndsx(3) < as	fx > 0	pass
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is,jjj,ke) is bellow cn3-cn
			if( ( zc1 - ys)*fz .gt. -margin ) then
				! 1q	if inside   ./	zc1 > ys	fz > 0	pass
				! 2q		||  	.\	zc1 < ys	fz < 0	pass
				! 3q		||	    /*	zc1 < ys	fz < 0	pass
				! 4q		||	    \*	zc1 > ys	fz > 0	pass
				if ( ( ndsx(5) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					! 1q	if pierced  twice	/*	ndsx(5) > as	fx > 0	pass
					! 2q		||				\*	ndsx(5) < as	fx < 0	pass
					! 3q		||				./	ndsx(5) < as	fx < 0	pass
					! 4q		||				.\	ndsx(5) > as	fx > 0	pass
					if( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if inside   /*	zc1 < ys2	fz > 0	pass
						! 2q		||	   	\*	zc1 > ys2	fz < 0	pass
						! 3q		||	   	./	zc1 > ys2	fz < 0	pass
						! 4q		||	   	.\	zc1 < ys2	fz > 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q	    always      	\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q	    always      	_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  again	*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*\	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 /
					!
					! 2q	 |.
					!		 /
					!
					!		/
					! 3q	|*
					!
					!		/
                    ! 4q   *|
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                    !dom(ib)%uoo(is,jjj,ke) = t2
                    !endif
				endif		
			endif
			!				
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is,jjj,ke) is bellow cn3-cn5 
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(7) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
                    if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
            	        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
            	        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
            	        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
            	        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	    !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                    !dom(ib)%uoo(is,jjj,ke) = t2
                    !endif
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is,jjj,ke) is bellow cn5-cn7 
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(9) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(as-ndsx(9))/(ndsx(7)-ndsx(9))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
						!dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
                    if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2	
                    !dom(ib)%uoo(is,jjj,ke) = t2
                    !endif
				endif
			endif ! zc1
        else ! Face S has not been pierces so far
				!	1q	*|      is = iii-1
				!	2q	 |*     is = iii
				!	3q	 |.     is = iii
				!	4q	.|      is = iii-1
				if ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q		always  		\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q		always  		_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q	
                        ! debug
                        write(*,*)  "ndsx2"
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*/	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
                    endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2
                        !dom(ib)%uoo(is,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 |
					!
					! 2q	 |.
					!		 |
					!
					!		 |
					! 3q	 |*
					!
					!		 |
                    ! 4q	*|
                    if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_u(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is,jjj,ke) = t2	
                    !dom(ib)%uoo(is,jjj,ke) = t2
                    endif
				endif
		endif	 ! ndsx(3)! Finished Check of Face S2 ke
		!endif!12345
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2
		!
		!12345 if(dom(ib)%mucxold(is2,jjj,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
		! 1q	if pierced  ./	ndsx(3) < as2	fxq2 > 0	pass
		! 2q		||		./	ndsx(3) < as2	fxq2 > 0	pass
		! 3q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
		! 4q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjj,ke) is2 bellow cn3-cn
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				! 1q	if inside   ./	zc1 > ys	fzq2 > 0	pass
				! 2q		||  	./	zc1 > ys	fzq2 > 0	pass
				! 3q		||	    /*	zc1 < ys	fzq2 < 0	pass
				! 4q		||	    /*	zc1 < ys	fzq2 < 0	pass
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					! 1q	if pierced  twice	/*	ndsx(5) > as2	fxq2 > 0	pass
					! 2q		||				/*	ndsx(5) > as2	fxq2 > 0	pass
					! 3q		||				./	ndsx(5) < as2	fxq2 < 0	pass
					! 4q		||				./	ndsx(5) < as2	fxq2 < 0	pass
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if inside   /*	zc1 < ys2	fzq2 > 0	pass
						! 2q		||	   	/*	zc1 < ys2	fzq2 > 0	pass
						! 3q		||	   	./	zc1 > ys2	fzq2 < 0	pass
						! 4q		||	   	./	zc1 > ys2	fzq2 < 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
                        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
					! 2q	if pierced  again	*\	ndsx(2) < as2	fxq2 > 0	pass
					! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
					! 4q	if pierced  again	\.	ndsx(2) > as2	fxq2 < 0	pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q
						! 2q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 3q
						! 4q	if pierced  again	\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
                        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  again	*\	ndsx(4) < as2	fxq2 > 0	pass
					! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
					! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
						! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
						! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
                        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
                        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 /
					!
					! 2q	.|
					!		 /
					!
					!		/
					! 3q	|*
					!
					!		/
					! 4q	|*
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
                    !dom(ib)%uoo(is2,jjj,ke) = t2
				endif		
			endif
			!				
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is2,jjj,ke) is2 bellow cn3-cn5 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
            	        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
            	        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
            	        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
            	        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	    !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
            	    !dom(ib)%uoo(is2,jjj,ke) = t2
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjj,ke) is2 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
                        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
                        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
                        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2	
                    !dom(ib)%uoo(is2,jjj,ke) = t2
				endif				
			endif ! zc1
		else ! Face S has not been pierces so far
				!	1q	*|
				!	2q	*|
				!	3q	|.
				!	4q	|.
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
					! 2q	if pierced  		*\	ndsx(2) < as2	fxq2 > 0	pass
					! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
					! 4q	if pierced  		\.	ndsx(2) > as2	fxq2 < 0	pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q
						! 2q	if pierced  	*\	zc1 < ys2	fzq2 > 0	pass
						! 3q
						! 4q	if pierced  	\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
                        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as2	fxq2 > 0	pass
					! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
					! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
						! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
						! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
                        !dom(ib)%uoo(is2,jjj,ke) = t2
                    endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2
                        !dom(ib)%uoo(is2,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 |
					!
					! 2q	.|
					!		 |
					!
					!		|
					! 3q	|*
					!
					!		|
					! 4q	|*
					call setMirror_u(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke) = t2	
                    !dom(ib)%uoo(is2,jjj,ke) = t2
				endif
		endif	 ! ndsx(3)! Finis2hed Check of Face S2 ke
		!endif!12345 
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2 ke2
		!
		!12345 if(dom(ib)%mucxold(is2,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
		!!! WARNING !!!			
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
		!!! END !!!								
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
			! There  may be an is2sue			
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                    !dom(ib)%uoo(is2,jjj,ke2) = t2
				endif		
			endif				
		else	! The the West face has not yet been pierced	
			if ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
				! case b.2.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn3-cn5 
				if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
		!!! WARNING !!!			
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
		!!! END !!!						
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
			! There  may be an is2sue			
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                    !dom(ib)%uoo(is2,jjj,ke2) = t2
				endif		
				endif
		
			else	! The Face S has not been pierced so far	
			if ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
		!!! WARNING !!!			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
		!!! END !!!	
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
		! There  may be an is2sue			
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2	
                    !dom(ib)%uoo(is2,jjj,ke2) = t2
				endif				
			endif
			else ! Face S has not been pierces so far
				!!!!!!!!!!!! 
				! fxq2	 1 1	-1 1	-1-1	-1-1
				! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
				! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
				! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				!
				!
				! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
                    endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2
                        !dom(ib)%uoo(is2,jjj,ke2) = t2
					endif
				else
					call setMirror_u(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%ustar(is2,jjj,ke2) = t2	
                    !dom(ib)%uoo(is2,jjj,ke2) = t2
		        endif
				!!!!!!!!!!!!
			endif	! ndsx(7)
			endif	! ndsx(5)
		endif	! ndsx(3) ! Finis2hed Check of Face S2 ke2
		!endif!12345 
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke
		!
		!12345 if(dom(ib)%mucxold(is3,jjj,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		 if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
     	    ! case b.1.1.1  Checking if u(is3,jjj,ke) is3 bellow cn3-cn
     	    if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
     	            if( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
				 elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
     	        else
     	            call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	            !dom(ib)%uoo(is3,jjj,ke) = t2
     	        endif		
     	    endif				
     	! The the West face has not yet been pierced	
		 elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
     	    ! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn3-cn5 
     	    if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				 if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
     	            if( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
				 elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
     	        else
     	            call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	            !dom(ib)%uoo(is3,jjj,ke) = t2
     	        endif		
     	    endif
     	! The Face S has not been pierced so far	
		 elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
     	    ! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn5-cn7 
     	    if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
     	        else
     	            call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2	
     	            !dom(ib)%uoo(is3,jjj,ke) = t2
     	        endif
     	    endif
		 elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
     	    ! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn5-cn7 
     	    if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
				 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
				 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
     	            if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	                call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	                !dom(ib)%uoo(is3,jjj,ke) = t2
     	            endif
     	        else
     	            call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2	
     	            !dom(ib)%uoo(is3,jjj,ke) = t2
     	        endif
     	    endif
     	else ! Face S has not been pierces so far
     	    !!!!!!!!!!!! 
     	    ! fxq2	 1 1	-1 1	-1-1	-1-1
     	    ! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
     	    ! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
     	    ! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
     	    ! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
     	    !
     	    !
     	    ! 1q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
     	    ! 2q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
     	    ! 3q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
     	    ! 4q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			 if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
     	        if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	            call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	            !dom(ib)%uoo(is3,jjj,ke) = t2
     	        endif
			 elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
     	        if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	            call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	            !dom(ib)%uoo(is3,jjj,ke) = t2
     	        endif
			 elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
     	        if ( ( zc1 - ys2)*fzq2 .lt. margin) then
     	            call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2
     	            !dom(ib)%uoo(is3,jjj,ke) = t2
     	        endif
     	    else
     	        call setMirror_u(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
     	        !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke) = t2	
     	        !dom(ib)%uoo(is3,jjj,ke) = t2
     	    endif
     	    !!!!!!!!!!!!
     	endif	! ndsx(3) ! Finis3hed Check of Face S3 ke
     	!endif!12345 
     	!
     	!
     	!!!!!!!!!!!!!!!!!!
     	!!! CHECKING FACE S3 ke2
     	!
    	!12345 if(dom(ib)%mucxold(is3,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
    	!if(1) then	! checking if this cell has already been flagged
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
    	    ! case b.1.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn3-cn
    	    if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
    	            if( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
    	        else
    	            call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	            !dom(ib)%uoo(is3,jjj,ke2) = t2
    	        endif		
    	    endif				
    	! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
    	    ! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn3-cn5 
    	    if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
    	            if( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
    	        else
    	            call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	            !dom(ib)%uoo(is3,jjj,ke2) = t2
    	        endif		
    	    endif
    	! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
    	    ! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn5-cn7 
    	    if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
    	        else
    	            call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2	
    	            !dom(ib)%uoo(is3,jjj,ke2) = t2
    	        endif
    	    endif
		elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
    	    ! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn5-cn7 
    	    if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
    	            if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	                call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	                !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	                !dom(ib)%uoo(is3,jjj,ke2) = t2
    	            endif
    	        else
    	            call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2	
    	            !dom(ib)%uoo(is3,jjj,ke2) = t2
    	        endif
    	    endif
    	else ! Face S has not been pierces so far
    	    !!!!!!!!!!!! 
    	    ! fxq2	 1 1	-1 1	-1-1	-1-1
    	    ! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
    	    ! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
    	    ! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
    	    ! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
    	    !
    	    !
    	    ! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
    	    ! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
    	    ! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
    	    ! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
    	        if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	            call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	            !dom(ib)%uoo(is3,jjj,ke2) = t2
    	        endif
			elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
    	        if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	            call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	            !dom(ib)%uoo(is3,jjj,ke2) = t2
    	        endif
			elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
    	        if ( ( zc2 - ys2)*fzq2 .lt. margin) then
    	            call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	            !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2
    	            !dom(ib)%uoo(is3,jjj,ke2) = t2
    	        endif
    	    else
    	        call setMirror_u(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
    	        !if(fieldF.eq.1) dom(ib)%ustar(is3,jjj,ke2) = t2	
    	        !dom(ib)%uoo(is3,jjj,ke2) = t2
    	    endif
    	    !!!!!!!!!!!!
    	endif	! ndsx(3) ! Finis3hed Check of Face S3 ke2
    	!endif!12345 
		!
		!
		!!!!!!!!!!!!!!!!!
		!! CHECKING FACE SE ke4
		!
		!12345 if(dom(ib)%mucxold(ie,jjj,ke4).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
		!	fx,fz					1 1		-1 -1	-1 -1	1 1
		!   fxk4,fzk4				1		-1		-1		1
		if (flagA .eq. 1) then
			!flag2 = 0
			! 1q	ae = dom(ib)%x(iii)		if pierced once		*/
			! 2q	ae = dom(ib)%x(iii-1) 	if pierced once		*\
			! 3q	ae = dom(ib)%x(iii-1) 	if pierced once		/.
			! 4q	ae = dom(ib)%x(iii)		if pierced once		\.
			if ( ( ndsx(4) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(4) > ae	fx > 0	pass
				! 2q		||				\.	ndsx(4) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(4) < ae	fx < 0	pass
				! 2q		||				*\	ndsx(4) > ae	fx > 0	pass
				!
				ys = ndsz(2) + (ndsz(4)-ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
				!
				! case a.1.1.2	 Checking if u(ie,jjj,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif		
				endif
			elseif ( ( ndsx(6) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(6) > ae	fx > 0	pass
				! 4q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 4q		||				*\	ndsx(6) > ae	fx > 0	pass
				!
				ys = ndsz(4) + (ndsz(6)-ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
				!
				! case a.1.1.2	 Checking if u(ie,jjj,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif		
				endif
			else
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
					! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
					! 2q		||				./	ndsx(3) < ae	fx < 0	pass
					! 3q		||				./	ndsx(3) < ae	fx < 0	pass
					! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc4 - ys2)*fz .lt. margin) then
						! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
						! 2q		||				./	ys2 < zc4	fx < 0	pass
						! 3q		||				./	ys2 < zc4	fx < 0	pass
						! 4q		||				/*	ys2 > zc4	fx > 0	pass
						!flag2 = 1
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif
				else
				! setting mirror value
					call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
					!dom(ib)%uoo(ie,jjj,ke4) = t2
				endif
			endif
		endif
		!endif!12345
		!
		!
		!
		!12345 if(dom(ib)%mucxold(ie,jjj,ke4).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
		!	fx,fz					1 1		-1 -1	-1 -1	1 1
		!   fxk4,fzk4				1		-1		-1		1
		if (flagB .eq. 1) then
			!flag2 = 0
			! 1q	ae = dom(ib)%x(iii)		if pierced once		*/
			! 2q	ae = dom(ib)%x(iii-1) 	if pierced once		*\
			! 3q	ae = dom(ib)%x(iii-1) 	if pierced once		/.
			! 4q	ae = dom(ib)%x(iii)		if pierced once		\.
			if ( ( ndsx(6) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(6) > ae	fx > 0	pass
				! 4q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 4q		||				*\	ndsx(6) > ae	fx > 0	pass
				!
				ys = ndsz(4) + (ndsz(6)-ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
				!
				! case a.1.1.2	 Checking if u(ie,jjj,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif		
				endif
			elseif ( ( ndsx(8) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(8) > ae	fx > 0	pass
				! 6q		||				\.	ndsx(8) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(8) < ae	fx < 0	pass
				! 6q		||				*\	ndsx(8) > ae	fx > 0	pass
				!
				ys = ndsz(6) + (ndsz(8)-ndsz(6))*(ae-ndsx(6))/(ndsx(8)-ndsx(6))
				!
				! case a.1.1.2	 Checking if u(ie,jjj,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
							!dom(ib)%uoo(ie,jjj,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif		
				endif
			else
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
					! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
					! 2q		||				./	ndsx(3) < ae	fx < 0	pass
					! 3q		||				./	ndsx(3) < ae	fx < 0	pass
					! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc4 - ys2)*fz .lt. margin) then
						! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
						! 2q		||				./	ys2 < zc4	fx < 0	pass
						! 3q		||				./	ys2 < zc4	fx < 0	pass
						! 4q		||				/*	ys2 > zc4	fx > 0	pass
						!flag2 = 1
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
						!dom(ib)%uoo(ie,jjj,ke4) = t2
					endif
				else
				! setting mirror value
					call setMirror_u(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%ustar(ie,jjj,ke4) = t2
					!dom(ib)%uoo(ie,jjj,ke4) = t2
				endif
			endif
		endif
		!endif!12345
		!
		!
		!
		!
		endif
		!
		endif
!######################################################################
	END SUBROUTINE setQuadrant_u
!######################################################################	


!######################################################################
	SUBROUTINE setMirror_u(vec1,ndsx,ndsz,iq,kq,xq,zq,k)
!######################################################################

			    use imb
			    use mpi
			    use multidata
			    use vars
			    !
			    implicit none
				!
				! temporal variables
				DOUBLE PRECISION:: temp
				!
				! Input valriables
				INTEGER, INTENT(IN):: vec1(8) !vec1(9)
				DOUBLE PRECISION, INTENT(IN):: ndsx(11), ndsz(11)
				!
				! Location of cell face center of ghost cell 
				INTEGER, INTENT(IN):: iq, kq
				DOUBLE PRECISION, INTENT(IN):: xq, zq
				DOUBLE PRECISION:: yq

				! Output variables
				DOUBLE PRECISION, INTENT(OUT):: k

				! Intervace vector for interpoaltion function
				INTEGER::vec2(8)
				DOUBLE PRECISION:: vec3(3) 
				DOUBLE PRECISION:: mirror_v,mirror_w

				! Interfaces
				INTEGER:: nn, ib, ll, iii, jjj, kkk
				! qF: quadrantFlag

				

				! Search loop index
				INTEGER:: dd, bb, cc

				! Location of the neares marker
				DOUBLE PRECISION:: mkx, mkz, mkx2, mkz2, mkx3, mkz3

				! Distances between ghost cell and markers
				DOUBLE PRECISION:: rad1, rad2, radAux

				! Angle of the closts markers to the ghost cell
				DOUBLE PRECISION:: cosTetha1, sinTetha1
				DOUBLE PRECISION:: cosAlpha1, cosAlpha2, tanBetha1
				DOUBLE PRECISION:: alpha1, alpha2, betha1, tetha1

				! Location of mirror point
				DOUBLE PRECISION:: mrx, mry, mrz

				! Indeces of mirror cell centre
				INTEGER:: id,jd, kd				
				
				DOUBLE PRECISION:: origin_x, origin_yc, origin_zc, dx_l, dy_l, dz_l

				! mirror velocities
				INTEGER:: ii, jj
				DOUBLE PRECISION:: mirror_u
				DOUBLE PRECISION:: nx(2),nz(2),uvec(4)
				DOUBLE PRECISION:: dx1, dx2, dz1, dz2
				DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
				DOUBLE PRECISION:: b1(4), b2(3), sol(3), ab(4,3)
				DOUBLE PRECISION:: x1, x2, z1, z2
				DOUBLE PRECISION:: q11, q21, q12, q22, qxz
				DOUBLE PRECISION:: factor1
				DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
				DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
				DOUBLE PRECISION:: bm1(4), bm2(4),sol2(4)

				! Flags
				INTEGER:: flag90, flag1, flag2, qF, M
				DOUBLE PRECISION:: fx, fz

				! safety variables
				DOUBLE PRECISION:: margin

				! writing warnings
				integer:: sn
				character*8 :: chb1
				character*35 :: gf ! file name



			!	if (myrank.eq. master ) then ! The control is passed down to the master processor

				nn  = vec1(1)
				ib  = vec1(2)
				ll  = vec1(3)
				iii = vec1(4)
				jjj = vec1(5)
				kkk = vec1(6)
				qF  = vec1(7) ! this is defined in a function later on
				M   = vec1(8)
				!origin_x = vec1(8)
				!origin_y = vec1(9)
				!origin_zc = vec1(10)
				if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN
					
					IF(imb_block_loc(nn).eq.dom_id(ib)) then

				! lets initialize the mirror velocity
				mirror_u = 0.0d00;

				! Filter for testing
			!	if(qF.eq.1) then
				! if( (qF.eq.1 ).and.(ll.lt.2) ) then
			!	if( (ll.lt.2).and.((qF.eq.1).or.(qF.eq.2)) ) then
			!	if( (ll.lt.2) ) then !.and.((qF.eq.1).or.(qF.eq.2)) ) then					
				if( (ll.lt.2).and.(qF.lt.5) ) then
			!	if( (nn.gt.0).and.(nn .lt. 1321) ) then

				flag90 = 0
				margin = 1.0e-5

				!!! Search loop for closest markers to the velocity cell centre
				mkx = ndsx(1)
				mkz = ndsz(1)
				mkx2 = ndsx(2)
				mkz2 = ndsz(2)
				dd = 2
				bb = dd - 1
				cc = dd

				rad1 = (mkx-xq)**2 + (mkz-zq)**2
				rad2 = (mkx2-xq)**2 + (mkz2-zq)**2

				mkx3 = ndsx(3)
				mkz3 = ndsz(3)
				radAux = (mkx3-xq)**2 + (mkz3-zq)**2
				if (radAux .lt. rad2) then
					mkx2 = mkx
					mkz2 = mkz
					mkx  = mkx3
					mkz  = mkz3
					rad2 = rad1
					rad1 = radAux

					bb = dd + 1
					cc = dd - 1
				endif

				
				do dd = 4, 10, 2

					mkx3 = ndsx(dd)
					mkz3 = ndsz(dd)					
					radAux = (mkx3-xq)**2 + (mkz3-zq)**2										

					if (radAux .lt. rad1) then
						mkx  = mkx2
						mkz  = mkz2
						mkx2 = mkx3
						mkz2 = mkz3						
						rad1 = rad2
						rad2 = radAux
						bb = dd - 2
						cc = dd
					else
						mkx3 = ndsx(dd+1)
						mkz3 = ndsz(dd+1)
						radAux = (mkx3-xq)**2 + (mkz3-zq)**2
						if (radAux .lt. rad2) then
							mkx2 = mkx
							mkz2 = mkz
							mkx  = mkx3
							mkz  = mkz3							
							rad2 = rad1
							rad1 = radAux
							bb = dd + 1
							cc = dd - 1
						endif
					endif
				enddo

				rad1 = sqrt(rad1)
				rad2 = sqrt(rad2)
				

				cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) ! alpha1: angle between U cell centre and segment mk1-mk2
				cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) ! alpha2: angle between U cell centre and segment mk2-mk1
				alpha1 = DACOS(cosAlpha1)*180/piNUm
				alpha2 = DACOS(cosAlpha2)*180/piNum
				! If there is a normal from the velocity cell centre to the surface (segment mk1-mk2) alpha1 < 90 and alpha2 < 90


				tanBetha1 = (mkz2-mkz)/(mkx2-mkx)
				betha1 = abs(DATAN(tanBetha1))*180/piNUm	! lets make betha1


				if( (nn.gt.0).and.(nn.lt.127) ) then
				if (alpha1 .gt. 90) then
					flag90 = 1
					write(6,*) "Warning in mirror_u subroutine!", nn
					write(6,*) "alpha1 greater thant 90: ", alpha1
					write(6,*) ""
					! Update bb and cc
					if (bb .eq. 2) then
						! bb = 2		cc = 4
						bb = bb - 1
						cc = cc - 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb - 2
						cc = cc - 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb + 2
						cc = cc + 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNum

				
				elseif (alpha2 .gt. 90) then
					flag90 = 1
					write(6,*) "Warning in mirror_u subroutine!", nn
					write(6,*) "Warning: alpha2 greater thant 90: ", alpha2
					write(6,*) ""
					! Update bb and redefine the nodes
					if (bb .eq. 1) then
						! bb = 1		cc = 2
						bb = bb + 1
						cc = cc + 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb + 2
						cc = cc + 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb - 2
						cc = cc - 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNum				
				endif
				endif

				if (flag90) then
					write(chb1,'(i6)') nn
					sn=len(trim(adjustl(chb1)))
					gf='w_u_m_alpha'//repeat('0',(6-sn))//trim(adjustl(chb1))
					OPEN(unit = 906, access = "sequential", action = "write",
     &   status = "replace", file = gf, form = "formatted") 

					!	write(6,*) "*** Index, Qudarant ***"
						write(906,*) nn, qF
						write(906,*) ndsx
						write(906,*) ndsz
						write(906,*) iii, kkk, jjj	
						write(906,*) iq, kq
						write(906,*) alpha1, alpha2
						!write(6,*) betha1, tetha1
					! location of P pressure cell centre
						write(906,*) xq, zq
					! location of closest markers
						write(906,*) mkx, mkz
						write(906,*) mkx2, mkz2
						write(906,*) bb, cc		
						write(906,*) ndsx(bb), ndsz(bb)
						write(906,*) ndsx(cc), ndsz(cc)
						!write(6,*) mrx, mrz		
						write(906,*) id, kd
						write(906,*) "==="
						close(906)
					endif

				! redefining quadrant of the neighbouring markers
				qF = quadrant(ndsx(bb), ndsz(bb),ndsx(cc), ndsz(cc),margin)
				!
				dx_l = dom(ib)%dx
				dy_l = dom(ib)%dy
				dz_l = dom(ib)%dz
				!
				origin_x = dom(ib)%x(1)
				origin_yc = dom(ib)%yc(1)
				origin_zc = dom(ib)%zc(1) 
				!
				!
			if (qF.eq.1) then

				tetha1 = alpha1 - betha1 
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point will always be forward of marker1
				mrx = mkx + rad1*cosTetha1
				! mry = ???
				! The mirror point may be above marker1 if betha1 > alpha1
				mrz = mkz - rad1*sinTetha1

			elseif(qF.eq.2) then

				tetha1 =   alpha1 - (90 - betha1) 
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point may be behind maker1 if alpha1 < (90 - betha1)
				mrx = mkx + rad1*sinTetha1

				! mry = ???
				
				! The mirror point will alpway be above marker1
				mrz = mkz + rad1*cosTetha1

			elseif(qF.eq.3) then

				tetha1 = betha1 - alpha1
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point will always be behind marker 1
				mrx = mkx - rad1*cosTetha1
				
				! mry = ???
				
				! The mirror point may be above marker 1 if alpha1 > betha1
				mrz = mkz - rad1*sinTetha1

			elseif(qF.eq.4) then

				tetha1 = 90 - betha1 - alpha1
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! mirror point may be behind or forward of marker 1 if alpha1 > (90 - betha1)
				mrx = mkx + rad1*sinTetha1
				
				! mry = ???

				! mirror point will alway be bellow marker 1
				mrz = mkz - rad1*cosTetha1

			endif

			! Inidices of the mirror u cell
			id = int ( ( mrx - origin_x - margin) /dx_l) + 2 
			!jd = int ( ( mry - origin_yc - margin) /dy_l) + 2
			!if (jd.eq.jjj) then
			!else
			!	write(6,*) "Warning jd is not jjj"
			!endif
			kd = int ( ( mrz - origin_zc - margin) /dz_l) + 2


                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				!!! BILINEAR INTERPOLATION

			uvec(1) = dom(ib)%ucpy(id-1,jjj,kd-1) ! q11
			uvec(2) = dom(ib)%ucpy(id,jjj,kd-1)   ! q21
			uvec(3) = dom(ib)%ucpy(id-1,jjj,kd)   ! q12
			uvec(4) = dom(ib)%ucpy(id,jjj,kd)	   ! q22

			nx(1) = dom(ib)%x(id-1)
			nx(2) = dom(ib)%x(id)
			nz(1) = dom(ib)%zc(kd-1)
			nz(2) = dom(ib)%zc(kd)

		!	mirror_u = bilinear1(nn,nx,nz,uvec,mrx,mrz)
		!	if(nn.eq.126) then
		!		write(6,*) "Mirror u (Bilinear Interpolation: explicit)",mirror_u
		!	endif


			! Alternative (2nd order Least Squares & Cramer's solver)
			!mirror_u = ls_2ndOrder_cramer(nn,nx,nz,uvec,mrx,mrz)
			!if ( nn.eq.70 ) then
			! write(6,*) "Mirror u (2nd order Least Squares: cramer)",nn,mirror_u
			!endif

			!!! LINEAR INTERPOLATION
			!mirror_u = l1(nn,nx,nz,uvec,mrx,mrz)
			!if(nn.lt.127) then
			!	write(6,*) "Mirror u (linear interpolation)", nn, mirror_u
			!endif

			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Alternative (Least Squares & Cramer's solver)
			!mirror_u = ls_cramer(nn,nx,nz,uvec,mrx,mrz)
			!if ( nn.eq.70 ) then
			!	write(6,*) "Mirror u (Least Squares: cramer)", nn, mirror_u
			!endif

			! Alternative: Bilinear Interpoaltion and Cramers solver
		!	mirror_u = bl_cramer(nn,nx,nz,uvec,mrx,mrz)
			!if ( nn.eq.70 ) then
			!	write(6,*) "Mirror u (Bilinear Interpolation: cramer)", nn, mirror_u
			!endif

			!Alternative: deltaFUnction
			vec2(1) = nn	! Node nds(1.5)
			vec2(2) = ib 
			vec2(3) = ll
			vec2(4) = id 
			vec2(5) = jjj
			vec2(6) = kd
			vec2(7) = qF
			vec2(8) = 1 ! fieldFlag for selecting u velocity
			vec3(1) = mrx
			vec3(2) = dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			vec3(3) = mrz
			call interpolationF(vec2,vec3,mirror_u)
			!
			!
			! lets flag this cell as a body cell
			dom(ib)%mucx(iq,jjj,kq) = qF
			!
			! Lets add the necesary information
			yq = dom(ib)%y(jjj) ! dom(ib)%yc(jjj)
			dom(ib)%mucxnn(iq,jjj,kq) = nn  ! nn for u ghost cells
			dom(ib)%mucxib(iq,jjj,kq) = ib  ! ib for u ghost cells
			dom(ib)%mucxll(iq,jjj,kq) = ll  ! ll for u ghost cells
			dom(ib)%mucxi(iq,jjj,kq)  = iq  ! %x  id for u ghost cells centre
			dom(ib)%mucxj(iq,jjj,kq)  = jjj ! %yc id for u ghost cells centre
			dom(ib)%mucxk(iq,jjj,kq)  = kq  ! %z  id for u ghost cells centre
			dom(ib)%mucxx(iq,jjj,kq)  = xq  ! %x  for u ghost cells centre
			dom(ib)%mucxy(iq,jjj,kq)  = yq  ! %yc for u ghost cells centre
			dom(ib)%mucxz(iq,jjj,kq)  = zq  ! %z  for u ghost cells centre
			dom(ib)%mucxmi(iq,jjj,kq) = id  ! %x  id for u mirror point in fluid cells cells
			dom(ib)%mucxmj(iq,jjj,kq) = jjj ! %yc id for u mirror point in fluid cells cells
			dom(ib)%mucxmk(iq,jjj,kq) = kd  ! %z  id for u mirror point in fluid cells cells
			dom(ib)%mucxmx(iq,jjj,kq) = mrx ! %x  for u mirror point in fluid cells
			dom(ib)%mucxmy(iq,jjj,kq) = yq  ! %yc for u mirror point in fluid cells
			dom(ib)%mucxmz(iq,jjj,kq) = mrz ! %z  for u mirror point in fluid cells
			!
			!debug
			!if((nn.gt.9240).and.(nn.lt.(9240+126))) then
			!	write(*,*) "mirror_u"
			!	write(6,*) vec2
			! write(6,*) vec3
			! write(6,*) yq,dom(ib)%mucxy(iq,jjj,kq)
			!	write(6,*) myrank
			!	endif
			!
			!
			!if (rott_loc(nn).eq.1) then
			if(rotating(M).eq..FALSE.) then
				k = - mirror_u
				!k = -1.0d00	
			!elseif (rott_loc(nn).eq.2) then
			elseif(rotating(M).eq..TRUE.) then
				k = 2*U_p - mirror_u  ! moving body
				!k = -1.0d00
			endif

			!debug
		!	if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!	!	write(6,*) nn, k ,rott_loc(nn)
		!		write(6,*) nn, k, M, dom(ib)%mucxold(iq,jjj,kq), "u"
		!	!write(6,*) qF, fieldF, fieldVal
		!	!write(6,*) vec2(1),vec2(2),vec2(3)
		!	!write(6,*) vec2(4),vec2(5),vec2(6)
		!	!write(6,*) vec2(7),vec2(8)
		!	!write(6,*) vec3(1),vec3(2),vec3(3)
		!	!write(6,*) "======================="
		!	endif
			!
			!
		! ! check mirror point for u	
		!	if ( (nn.gt.0).and.(nn.lt.127) ) then
		!		uz1 = abs(0.5d00 - sqrt( (18.00d00-xq)**2 + (10.50d00-zq)**2 ))
		!		uz2 = abs(sqrt( (18.0d00-mrx)**2 + (10.5d00-mrz)**2 ) - 0.5d00)
		!		uz1 = abs(uz1-uz2)
		!	!	write(6,*) nn, iq, kq
		!		write(6,*) nn, uz1
		!	!	write(6,*) alpha1, alpha2
		!	!	write(6,*) betha1, tetha1
		!	endif


			else
				k = 0.0d00
				!k = dom(ib)%ucpy(iq,jjj,kq)
			! Lets add the necesary information
				dom(ib)%mucx(iq,jjj,kq) = qF
				dom(ib)%mucxnn(iq,jjj,kq) = nn  ! nn for u ghost cells
				dom(ib)%mucxib(iq,jjj,kq) = ib  ! ib for u ghost cells
				dom(ib)%mucxll(iq,jjj,kq) = ll  ! ll for u ghost cells
				dom(ib)%mucxi(iq,jjj,kq)  = iq  ! %x  id for u ghost cells centre
				dom(ib)%mucxj(iq,jjj,kq)  = jjj ! %yc id for u ghost cells centre
				dom(ib)%mucxk(iq,jjj,kq)  = kq  ! %z  id for u ghost cells centre
				dom(ib)%mucxx(iq,jjj,kq)  = xq  ! %x  for u ghost cells centre
				dom(ib)%mucxy(iq,jjj,kq)  = yq  ! %yc for u ghost cells centre
				dom(ib)%mucxz(iq,jjj,kq)  = zq  ! %z  for u ghost cells centre
				dom(ib)%mucxmi(iq,jjj,kq) = 0  ! %x  id for u mirror point in fluid cells
				dom(ib)%mucxmj(iq,jjj,kq) = 0 ! %yc id for u mirror point in fluid cells
				dom(ib)%mucxmk(iq,jjj,kq) = 0  ! %z  id for u mirror point in fluid cells
				dom(ib)%mucxmx(iq,jjj,kq) = 0.0d0 ! %x  for u mirror point in fluid cells
				dom(ib)%mucxmy(iq,jjj,kq) = 0.0d0  ! %yc for u mirror point in fluid cells
				dom(ib)%mucxmz(iq,jjj,kq) = 0.0d0 ! %z  for u mirror point in fluid cells

			endif

			endif


			! End k-th processor handling sumbdomain ib??
			endif

			CONTAINS


			!######################################################################
			DOUBLE PRECISION FUNCTION bilinear1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
			DOUBLE PRECISION:: factor1
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			
			factor1 = 1.0d00/( (x2-x1)*(z2-z1) )
							
			m1(1) = x2 - mrx
			m1(2) = mrx - x1
			
			m2(1,1) = q11	! First row, 1st column
			m2(2,1) = q12	! 1 st row, 2 nd column
			m2(1,2) = q21	! 2 nd row,	1 st column
			m2(2,2) = q22	! 2 nd row, 2 nd column
			
			m3(1) = z2 - mrz
			m3(2) = mrz - z1
			
			m4 = matmul(m1,m2)
			
			bilinear1 = factor1*dot_product(m3,m4)
			
			!######################################################################
			END FUNCTION bilinear1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			
			
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = dx1*dx1; a1(5,1) = dz1*dz1; a1(6,1) = dx1*dz1

			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = dx2*dx2; a1(5,2) = dz1*dz1; a1(6,2) = dx2*dz1

			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = dx1*dx1; a1(5,3) = dz2*dz2; a1(6,3) = dx1*dz2

			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = dx2*dx2; a1(5,4) = dz2*dz2; a1(6,4) = dx2*dz2

			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,6)
			
			ls_2ndOrder_cramer = sol(1)
			
			!######################################################################
			END FUNCTION ls_2ndOrder_cramer
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION l1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################

			implicit none

			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			DOUBLE PRECISION:: ux1,uz1,ux2,uz2
			DOUBLE PRECISION:: x1,z1,x2,z2
			DOUBLE PRECISION:: mirror_ux1, mirror_ux2 
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!! LINEAR INTERPOLATION
				! mirror velocity for x = mrx and z = zc(kd) = z1
			!	ux1 = dom(ib)%u(id,jjj,kd)
			!	ux2 = dom(ib)%u(id+1,jjj,kd)
			!	x1 = dom(ib)%x(id)
			!	x2 = dom(ib)%x(id+1)

				! Alternative
			ux1 = uvec(1)	!dom(ib)%u(id,jjj,kd)
			ux2 = uvec(2) 	!dom(ib)%u(id-1,jjj,kd)
			x1 = nx(1) 	!dom(ib)%x(id)
			x2 = nx(2)	!dom(ib)%x(id-1)
			
			mirror_ux1 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = zc(kd-1) = z2				
			!ux1 = dom(ib)%u(id,jjj,kd-1)
			!ux2 = dom(ib)%u(id+1,jjj,kd-1)

			! Alternative
			ux1 = uvec(3)	!dom(ib)%u(id,jjj,kd-1)
			ux2 = uvec(4)	!dom(ib)%u(id-1,jjj,kd-1)

			mirror_ux2 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = mrz
			uz1 = mirror_ux1
			uz2 = mirror_ux2
			z1 = nz(1)	!dom(ib)%zc(kd)
			z2 = nz(2)	!dom(ib)%zc(kd-1)

			l1 = uz1 + (uz2-uz1)*(mrz-z1)/(z2-z1)

			!######################################################################
			END FUNCTION l1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION cosAngle(x1,z1,x2,z2,x3,z3,l12)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: x1,z1,x2,z2,x3,z3,l12
			DOUBLE PRECISION:: x12,z12, x13, l13, z13

			x12 = x2-x1
			z12 = z2-z1
			x13 = x3-x1
			z13 = z3-z1
			l13 = sqrt(x13**2+z13**2)

			cosAngle = (x12*x13 + z12*z13)/(l12*l13)


			!######################################################################
			END FUNCTION cosAngle
			!######################################################################


			!######################################################################
			INTEGER FUNCTION quadrant(cnx,cnz,cnx2,cnz2,margin)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: cnx,cnz,cnx2,cnz2, margin
			INTEGER:: qFlag

										! ( 0, 90 ] First quadrant?
			if ( (cnx2 - cnx) .gt. -margin) then
			if ( (cnz2 - cnz) .gt. margin) then	! Proper way

				qFlag = 1			

			endif
			endif


			! ( 90, 180 ] 2nd quadrant?
			if ( (cnx2 - cnx) .le. -margin) then
			if ( (cnz2 - cnz) .ge. -margin) then

				qFlag = 2

			! End 2nd Quadrant ops
			endif
			endif


			! ( 180, 270 ] 3rd quadrant?
			if ( (cnx2 - cnx) .le. margin) then
			if ( (cnz2 - cnz) .lt. -margin) then

				qFlag = 3

			endif
			endif

			! ( 270, 360 ] 4th quadrant?
			if ( (cnx2 - cnx) .gt. margin) then
			if ( (cnz2 - cnz) .le. margin) then

				qFlag = 4


			endif
			endif		

			quadrant = qFlag

			!######################################################################
			END FUNCTION quadrant
			!######################################################################






!######################################################################
			END SUBROUTINE setMirror_u
!######################################################################



!######################################################################			
	SUBROUTINE setQuadrant_w(vec0,ndsx,ndsz,fieldF)
!######################################################################		
		use imb
		use mpi
		use multidata

		implicit none

		! temporal variables
		DOUBLE PRECISION:: temp, t1, t2

		! Input valriables
		INTEGER, INTENT(IN):: vec0(8)
		INTEGER:: nn, ll, ib, iii,jjj,kkk, qF, M
		INTEGER, INTENT(IN):: fieldF
		DOUBLE PRECISION, INTENT(IN)::ndsx(11),ndsz(11)

		! safety variables
		DOUBLE PRECISION:: margin

		! Intersections
		DOUBLE PRECISION:: ys, ys2

		! Locations of faces
		DOUBLE PRECISION:: as3,as2,as,ae,ae2,ae3

		DOUBLE PRECISION:: cs3,cs2,cs,ce,ce2,ce3		

		DOUBLE PRECISION:: zc0, zc1, zc2, zc3, zc4

		! Indeces of faces
		INTEGER:: ie,ke,ke2,ke3,ke4,ke0
		INTEGER:: is, is2, is3

		! Special variables for avoiding selecting cell outise the geometry in the 2nd and 4th quarters
		INTEGER:: isq, keq, ieq
		DOUBLE PRECISION:: asq, aeq
		INTEGER:: fxq1, fzq1, fxq2, fzq2, fxs3, fzs3, fxk3, fzk3
		!
		! Flags
		INTEGER:: flag1, flag2, flagA, flagB
		DOUBLE PRECISION:: fx, fz
		!
		! Interfaces
		INTEGER:: vec1(8)
		!
		nn  = vec0(1)
		ll  = vec0(2)
		ib  = vec0(3)
		iii = vec0(4)
		jjj = vec0(5)
		kkk = vec0(6)
		qF  = vec0(7)
		 M  = vec0(8)
		 !
		vec1(1) = nn
		vec1(2) = ib
		vec1(3) = ll
		vec1(4) = iii
		vec1(5) = jjj
		vec1(6) = kkk
		vec1(7) = qF
		vec1(8) = M
		!
		margin = 1.0e-5
		!
		!
		!
	!	if (myrank.eq. master ) then ! The control is passed down to the master processor
			if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
				IF(imb_block_loc(nn).eq.dom_id(ib)) then
		!
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 1st quadrant
		!
		if (qF.eq.1) then
			!
            as3 = dom(ib)%xc(iii-3)
            as2 = dom(ib)%xc(iii-2)	
            as = dom(ib)%xc(iii-1) 
		    asq = as
			!
            ae = dom(ib)%xc(iii) 
            ! Warning, check this
			! aeq = ae
			aeq = as
            !
            ae2 = dom(ib)%xc(iii+1)
            ae3 = dom(ib)%xc(iii+2)
            !
            zc0 = dom(ib)%z(kkk-1)	! cell cetre. We want to obtain the mirror value for this cell centre    
            zc1 = dom(ib)%z(kkk)	! cell cetre. We want to obtain the mirror value for this cell centre
            zc2 = dom(ib)%z(kkk+1)	! cell cetre. We want to obtain the mirror value for this cell centre
            zc3 = dom(ib)%z(kkk+2)	! cell cetre. We want to obtain the mirror value for this cell centre
		    zc4 = dom(ib)%z(kkk+3)	! cell cetre. We want to obtain the mirror value for this cell centre		
			!
			!
            ie = iii; ke0 = kkk-1;	ke = kkk
		    ke2 = kkk+1; ke3 = kkk+2; ke4 = kkk+3
			!
            is = iii-1 ; is2 = iii-2; is3 = iii - 3
            isq = is; keq = ke
            ieq = is	
    
            fx = 1.0d00
            fz = 1.0d00
            fxq1 = fx
            fzq1 = fz
            fxq2 = fx
			fzq2 = fz	
            fxs3 = fx
            fzs3 = fz
    
            endif
    
            ! bbbb
    
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Setting parameters for 2nd quadrant
    
            if (qF.eq.2) then
    
                ae3 = dom(ib)%xc(iii-3)
                ae2 = dom(ib)%xc(iii-2)	
    
    
                ae = dom(ib)%xc(iii-1) 
        
                as = dom(ib)%xc(iii) 
                asq = ae
                aeq = ae
    
                as2 = dom(ib)%xc(iii-2)
                as3 = dom(ib)%xc(iii-3)
                
                zc0 = dom(ib)%z(kkk)	! cell cetre. We want to obtain the mirror value for this cell centre    
                zc1 = dom(ib)%z(kkk-1)	! cell cetre. We want to obtain the mirror value for this cell centre
                zc2 = dom(ib)%z(kkk-2)	! cell cetre. We want to obtain the mirror value for this cell centre
                zc3 = dom(ib)%z(kkk-3)	! cell cetre. We want to obtain the mirror value for this cell centre
                zc4 = dom(ib)%z(kkk-4)	! cell cetre. We want to obtain the mirror value for this cell centre				
                
        
                ie = iii-1; ke0 = kkk;	ke = kkk-1
                ke2 = kkk-2; ke3 = kkk-3; ke4 = kkk-4
        
                is = iii; is2 = iii-2; is3 = iii - 3
                isq = is; keq = kkk + 1
                ieq = ie
                    
                fx = -1.0d00
                fz = -1.0d00
                fxq1 = fx
                fzq1 = fz
                fxq2 = -fx
				fzq2 = -fz		
                fxs3 = -fx
                fzs3 = -fz

                endif
    
    
    
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Setting parameters for 3rd quadrant
                    
                if (qF.eq.3) then
    
                    ae3 = dom(ib)%xc(iii-3)
                    ae2 = dom(ib)%xc(iii-2)	
        
        
        
                    ae = dom(ib)%xc(iii-1) 
            
                    as = dom(ib)%xc(iii) 
                    asq = as
                    aeq = as
        
                    as2 = dom(ib)%xc(iii+1)
                    as3 = dom(ib)%xc(iii+2)
    
					zc0 = dom(ib)%z(kkk)	! cell cetre. We want to obtain the mirror value for this cell centre    
                    zc1 = dom(ib)%z(kkk-1)	! cell cetre. We want to obtain the mirror value for this cell centre
                    zc2 = dom(ib)%z(kkk-2)	! cell cetre. We want to obtain the mirror value for this cell centre
                    zc3 = dom(ib)%z(kkk-3)	! cell cetre. We want to obtain the mirror value for this cell centre
                    zc4 = dom(ib)%z(kkk-4)	! cell cetre. We want to obtain the mirror value for this cell centre					
                
            
                    ie = iii-1; ke0 = kkk;	 ke = kkk-1
                    ke2 = kkk-2; ke3 = kkk-3; ke4 = kkk-4
            
                    is = iii; is2 = iii+1; is3 = iii+2
                    isq = is; keq = ke		
                    ieq = is
                            
                !	is = iii; is2 = iii; is3 = iii + 1
    
                    fx = -1.0d00
                    fz = -1.0d00
                    fxq1 = -fx
                    fzq1 = -fz
                    fxq2 = fx
					fzq2 = fz
                    fxs3 = fx
                    fzs3 = fz
                

                    endif			
    
    
    
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Setting parameters for 4th quadrant
                    
                if (qF.eq.4) then
    
                    ae3 = dom(ib)%xc(iii+2)
                    ae2 = dom(ib)%xc(iii+1)	
        
        
        
                    ae = dom(ib)%xc(iii) 
                    
            
                    as = dom(ib)%xc(iii-1) 
                    asq = ae
                    aeq = ae
        
                    as2 = dom(ib)%xc(iii+1)
        
                    as3 = dom(ib)%xc(iii+2)
        
                    zc0 = dom(ib)%z(kkk-1)	! cell cetre. We want to obtain the mirror value for this cell centre    
                    zc1 = dom(ib)%z(kkk)	! cell cetre. We want to obtain the mirror value for this cell centre
                    zc2 = dom(ib)%z(kkk+1)	! cell cetre. We want to obtain the mirror value for this cell centre
                    zc3 = dom(ib)%z(kkk+2)	! cell cetre. We want to obtain the mirror value for this cell centre
                    zc4 = dom(ib)%z(kkk+3)	! cell cetre. We want to obtain the mirror value for this cell centre					
    
            
                    ie = iii; ke0 = kkk-1;	ke = kkk
                    ke2 = kkk+1; ke3 = kkk+2; ke4 = kkk+3
            
                    is = iii-1; is2 = iii+1; is3 = iii+2
                    isq = ie; keq = kkk - 1
                    ieq = ie
            
                    fx = 1.0d00
                    fz = 1.0d00
                    fxq1 = fx
                    fzq1 = fz
                    fxq2 = -fx
					fzq2 = -fz
                    fxs3 = -fx
                    fzs3 = -fz

                    endif
    
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Checking quadrants

		flag1 = 0
		flag2 = 0
		flagA = 0
		flagB = 0

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE E



		if ( ( ndsx(2) -  ae )*fx.gt. -margin ) then	! The East Face is pierced for the FIRTS TIME
			!
			ys = ndsz(1) + (ndsz(2) - ndsz(1))*(ae - ndsx(1))/(ndsx(2) - ndsx(1))
			!
			! case a.1.1.1	 Checking if u(ie,jjj,ke0) is above cn-cn2
			!12345 if(dom(ib)%mwcz(ie,jjj,ke0).eq.0) then	! checking if this cell has already been flagged
			!if(1)  then
			if( ( zc0 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
				endif		
			!endif
			! case a.1.1.2	 Checking if u(ie,jjj,ke0) is above cn-cn2
			!else
				!flag2 = 1
				flagA = 1
		
			endif
			!endif!12345 
			!
			!
			! case a.1.1.1	 Checking if u(ie,jjj,ke) is above cn-cn2
			!12345 if(dom(ib)%mwcz(ie,jjj,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
				endif	
			else
				!flag2 = 1
				flagA = 1	
			endif
			!endif!12345 
			!
			!
			!
		! case a.1.1.2	 Checking if u(ie,jjj,ke2) is above cn-cn2
			!12345 if(dom(ib)%mwcz(ie,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke2) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
				endif		
			endif
			!endif!12345 
			!
			!
			!
			! case a.1.1.2	 Checking if u(ie,jjj,ke3) is above cn-cn2
			!12345 if(dom(ib)%mwcz(ie,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke3) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
				endif		
			endif
			!endif!12345 
			!
			!
		elseif ( ( ndsx(4) - ae )*fx .gt. -margin ) then	! The East face is pierced for the FIRST TIME
			!
		ys = ndsz(2) + (ndsz(4)-ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
		!
			! case a.1.1.1	 Checking if u(ie,jjj,ke0) is above cn2-cn4
	!		!12345 if(dom(ib)%mwcz(ie,jjj,ke0).eq.0) then	! checking if this cell has already been flagged
	!		!if(1) then
	!		if( ( zc0 - ys)*fz .gt. -margin ) then
	!			if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
	!				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
	!				if( ( zc0 - ys2)*fz .lt. margin) then
	!					call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !					!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
    !					if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
	!				endif
	!			elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
	!				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
	!				if( ( zc0 - ys2)*fz .lt. margin) then
	!					call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !					!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
    !                   if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
	!				endif
	!			elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
	!				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))				
	!				if ( ( zc0 - ys2)*fz .lt. margin) then
	!					call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !					!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
    !                   if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
	!				endif
	!	! There  may be an issue			
	!			else
	!				call setMirror_w(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
    !				!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke0) = t2
    !               if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke0) = t2
	!			endif		
	!		!endif
	!		! case a.1.1.2	 Checking if u(ie,jjj,ke0) is above cn2-cn4
	!		!else
	!			!flag2 = 1
	!	
	!		endif
	!		endif!12345 
		!
		!
			! case a.2.1.1	Checking if u(ie,jjj,ke) is above cn2-cn4
			!12345 if(dom(ib)%mwcz(ie,jjj,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke) = t2
				endif			
			else
			!	flag2 = 1
				flagB = 1
			endif
			!endif!12345 
			!
			!
			!
			! case a.2.1.2  Checking if u(ie,jjj,ke2) is above cn2-cn4 
			!12345 if(dom(ib)%mwcz(ie,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke2) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke2) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
					endif
		! There  may be an issue
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke2) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke2) = t2
				endif		
			endif
			!endif!12345 
			!
		! case a.1.1.2	 Checking if u(ie,jjj,ke3) is above cn-cn2
			!12345 if(dom(ib)%mwcz(ie,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( dom(ib)%z(ke3) - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( dom(ib)%z(ke3) - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                        if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_w(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke3) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ie,jjj,ke3) = t2
				endif		
			endif
			!endif!12345 
			!
		else			
			!elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too

	!			! case a.2.1.1	Checking if u(ieq,jjj,ke0) is above cn4-cn6
	!		if(dom(ib)%mwcz(ieq,jjj,ke0).eq.0) then	! checking if this cell has already been flagged
	!		!if(1) then
	!		if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
	!			ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
	!			if( ( dom(ib)%z(ke0) - ys2)*fzq1 .lt. margin) then
	!				call setMirror_w(vec1,ndsx,ndsz,ieq,ke0,aeq,zc0,t2)
    !				!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke0) = t2
    !           if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke0) = t2
	!			endif
	!		elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
	!			ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
	!			if( ( dom(ib)%z(ke0) - ys2)*fzq1 .lt. margin) then
	!				call setMirror_w(vec1,ndsx,ndsz,ieq,ke0,aeq,zc0,t2)
    !				!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke0) = t2
    !           if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke0) = t2
	!			endif
	!	! There  may be an issue			
	!		else
	!			call setMirror_w(vec1,ndsx,ndsz,ieq,ke0,aeq,zc0,t2)
    !			!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke0) = t2
    !           if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke0) = t2
	!		endif
	!		!endif!12345 
			!
			!
			!
				! case a.2.1.1	Checking if u(ieq,jjj,ke) is above cn4-cn6
			!12345 if(dom(ib)%mwcz(ieq,jjj,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
				if( ( dom(ib)%z(ke) - ys2)*fzq1 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke) = t2
				endif
			elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
				if( ( dom(ib)%z(ke) - ys2)*fzq1 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke) = t2
				endif
		! There  may be an issue			
			else
				call setMirror_w(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
                !if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke) = t2
                if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke) = t2
			endif
			!endif!12345 
			!
			!
			!
	!	! case a.2.1.2  Checking if u(ieq,jjj,ke2) is above cn4-cn6 
			!12345 if(dom(ib)%mwcz(ieq,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
				if( ( dom(ib)%z(ke2) - ys2)*fzq1 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke2) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
				if( ( dom(ib)%z(ke2) - ys2)*fzq1 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke2) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke2) = t2
				endif
	!		elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too
	!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
	!			if ( ( dom(ib)%z(ke2) - ys2)*fzq1 .lt. margin) then
	!			call setMirror_w(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
    !            !if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke2) = t2
    !            if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke2) = t2
	!			endif
	! There  may be an issue			
			else
				call setMirror_w(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
                !if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke2) = t2
                if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke2) = t2
			endif		
			!endif!12345 
			!
			!
			! case a.1.1.2	 Checking if u(ieq,jjj,ke3) is above cn4-cn6
			!12345 if(dom(ib)%mwcz(ieq,jjj,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
				if( ( dom(ib)%z(ke3) - ys2)*fzq1 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke3) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke3) = t2
				endif
			elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
				if( ( dom(ib)%z(ke3) - ys2)*fzq1 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke3) = t2
                    if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke3) = t2
				endif
	!		elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn4 pierced the East face too
	!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
	!			if ( ( dom(ib)%z(ke3) - ys2)*fzq1 .lt. margin) then
	!			call setMirror_w(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
    !			!if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke3) = t2
    !           if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke3) = t2
	!			endif													
	! There  may be an issue			
			else
				call setMirror_w(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
                !if(fieldF.eq.1) dom(ib)%wstar(ieq,jjj,ke3) = t2
                if(fieldF.eq.2) dom(ib)%woo(ieq,jjj,ke3) = t2
			endif
			!endif!12345 


		! WARNING A	
		!else	! The East face has not been pierced 
			flag1 = 1

		
		endif !!! FINISHED CHECKING FACE E
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S
		!
		!12345 if(dom(ib)%mwcz(is,jjj,ke).eq.0) then	! checking if this cell has already been flagged
        !if(1) then	! checking if this cell has already been flagged
        !   1 1       -1 -1      -1 -1      1 1
		if ( (ndsx(3) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
		! 1q	if pierced  ./	ndsx(3) < as	fx > 0	pass
		! 2q		||		.\	ndsx(3) > as	fx < 0	pass
		! 3q		||		/*	ndsx(3) > as	fx < 0	pass
		! 4q		||		\*	ndsx(3) < as	fx > 0	pass
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is,jjj,ke) is bellow cn3-cn
			if( ( zc1 - ys)*fz .gt. -margin ) then
				! 1q	if inside   ./	zc1 > ys	fz > 0	pass
				! 2q		||  	.\	zc1 < ys	fz < 0	pass
				! 3q		||	    /*	zc1 < ys	fz < 0	pass
				! 4q		||	    \*	zc1 > ys	fz > 0	pass
				if ( ( ndsx(5) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					! 1q	if pierced  twice	/*	ndsx(5) > as	fx > 0	pass
					! 2q		||				\*	ndsx(5) < as	fx < 0	pass
					! 3q		||				./	ndsx(5) < as	fx < 0	pass
					! 4q		||				.\	ndsx(5) > as	fx > 0	pass
					if( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if inside   /*	zc1 < ys2	fz > 0	pass
						! 2q		||	   	\*	zc1 > ys2	fz < 0	pass
						! 3q		||	   	./	zc1 > ys2	fz < 0	pass
						! 4q		||	   	.\	zc1 < ys2	fz > 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q	    always      	\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q	    always      	_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  again	*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*\	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 /
					!
					! 2q	 |.
					!		 /
					!
					!		/
					! 3q	|*
					!
					!		/
                    ! 4q   *|
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                    !dom(ib)%woo(is,jjj,ke) = t2
                    !endif
				endif		
			endif
			!				
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is,jjj,ke) is bellow cn3-cn5 
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(7) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
                    if( ( zc1 - ys2)*fz .lt. margin) then
                        ! debug
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
            	        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
            	        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
            	        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
            	        !dom(ib)%woo(is,jjj,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	    !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                    !dom(ib)%woo(is,jjj,ke) = t2
                    !endif
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is,jjj,ke) is bellow cn5-cn7 
			if( ( zc1 - ys)*fz .gt. -margin ) then			
				if ( ( ndsx(9) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(as-ndsx(9))/(ndsx(7)-ndsx(9))
                    if( ( zc1 - ys2)*fz .lt. margin) then
                        ! debug
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
            	        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
                    if ( ( zc1 - ys2)*fz .lt. margin) then
                        ! debug!!!!!!
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2	
                    !dom(ib)%woo(is,jjj,ke) = t2
                    !endif
				endif
			endif ! zc1
        else ! Face S has not been pierces so far
				!	1q	*|      is = iii-1
				!	2q	 |*     is = iii
				!	3q	 |.     is = iii
				!	4q	.|      is = iii-1
				if ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q		always  		\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q		always  		_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q	
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*/	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
                    endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2
                        !dom(ib)%woo(is,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 |
					!
					! 2q	 |.
					!		 |
					!
					!		 |
					! 3q	 |*
					!
					!		 |
                    ! 4q	*|
                    if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_w(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is,jjj,ke) = t2	
                    !dom(ib)%woo(is,jjj,ke) = t2
                    endif
				endif
		endif	 ! ndsx(3)! Finished Check of Face S1 ke
		!endif!12345
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2
		!
		!12345 if(dom(ib)%mwcz(is2,jjj,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
		! 1q	if pierced  ./	ndsx(3) < as2	fxq2 > 0	pass
		! 2q		||		./	ndsx(3) < as2	fxq2 > 0	pass
		! 3q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
		! 4q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjj,ke) is2 bellow cn3-cn
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				! 1q	if inside   ./	zc1 > ys	fzq2 > 0	pass
				! 2q		||  	./	zc1 > ys	fzq2 > 0	pass
				! 3q		||	    /*	zc1 < ys	fzq2 < 0	pass
				! 4q		||	    /*	zc1 < ys	fzq2 < 0	pass
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					! 1q	if pierced  twice	/*	ndsx(5) > as2	fxq2 > 0	pass
					! 2q		||				/*	ndsx(5) > as2	fxq2 > 0	pass
					! 3q		||				./	ndsx(5) < as2	fxq2 < 0	pass
					! 4q		||				./	ndsx(5) < as2	fxq2 < 0	pass
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if inside   /*	zc1 < ys2	fzq2 > 0	pass
						! 2q		||	   	/*	zc1 < ys2	fzq2 > 0	pass
						! 3q		||	   	./	zc1 > ys2	fzq2 < 0	pass
						! 4q		||	   	./	zc1 > ys2	fzq2 < 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
                        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
					! 2q	if pierced  again	*\	ndsx(2) < as2	fxq2 > 0	pass
					! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
					! 4q	if pierced  again	\.	ndsx(2) > as2	fxq2 < 0	pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q
						! 2q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 3q
						! 4q	if pierced  again	\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
                        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  again	*\	ndsx(4) < as2	fxq2 > 0	pass
					! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
					! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
						! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
						! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
                        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
                        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 /
					!
					! 2q	.|
					!		 /
					!
					!		/
					! 3q	|*
					!
					!		/
					! 4q	|*
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
                    !dom(ib)%woo(is2,jjj,ke) = t2
				endif		
			endif
			!				
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is2,jjj,ke) is2 bellow cn3-cn5 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
            	        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
            	        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
            	        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
            	        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	    !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
            	    !dom(ib)%woo(is2,jjj,ke) = t2
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjj,ke) is2 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
                        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
                        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
                        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2	
                    !dom(ib)%woo(is2,jjj,ke) = t2
				endif				
			endif ! zc1
		else ! Face S has not been pierces so far
				!	1q	*|
				!	2q	*|
				!	3q	|.
				!	4q	|.
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
					! 2q	if pierced  		*\	ndsx(2) < as2	fxq2 > 0	pass
					! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
					! 4q	if pierced  		\.	ndsx(2) > as2	fxq2 < 0	pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q
						! 2q	if pierced  	*\	zc1 < ys2	fzq2 > 0	pass
						! 3q
						! 4q	if pierced  	\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
                        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as2	fxq2 > 0	pass
					! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
					! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
						! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
						! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
                        !dom(ib)%woo(is2,jjj,ke) = t2
                    endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2
                        !dom(ib)%woo(is2,jjj,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 |
					!
					! 2q	.|
					!		 |
					!
					!		|
					! 3q	|*
					!
					!		|
					! 4q	|*
					call setMirror_w(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke) = t2	
                    !dom(ib)%woo(is2,jjj,ke) = t2
				endif
		endif	 ! ndsx(3)! Finis2hed Check of Face S2 ke
		!endif!12345 
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2 ke2
		!
		!12345 if(dom(ib)%mwcz(is2,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
		!!! WARNING !!!			
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
		!!! END !!!								
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
			! There  may be an is2sue			
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                    !dom(ib)%woo(is2,jjj,ke2) = t2
				endif		
			endif				
		else	! The the West face has not yet been pierced	
			if ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
				! case b.2.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn3-cn5 
				if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
		!!! WARNING !!!			
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
		!!! END !!!						
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
			! There  may be an is2sue			
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                    !dom(ib)%woo(is2,jjj,ke2) = t2
				endif		
				endif
		
			else	! The Face S has not been pierced so far	
			if ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjj,ke2) is2 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
		!!! WARNING !!!			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
		!!! END !!!	
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
		! There  may be an is2sue			
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2	
                    !dom(ib)%woo(is2,jjj,ke2) = t2
				endif				
			endif
			else ! Face S has not been pierces so far
				!!!!!!!!!!!! 
				! fxq2	 1 1	-1 1	-1-1	-1-1
				! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
				! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
				! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				!
				!
				! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
                    endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2
                        !dom(ib)%woo(is2,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is2,jjj,ke2) = t2	
                    !dom(ib)%woo(is2,jjj,ke2) = t2
		        endif
				!!!!!!!!!!!!
			endif	! ndsx(7)
			endif	! ndsx(5)
		endif	! ndsx(3) ! Finis2hed Check of Face S2 ke2
		!endif!12345 
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke
		!
		!12345 if(dom(ib)%mwcz(is3,jjj,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is3,jjj,ke) is3 bellow cn3-cn
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                    !dom(ib)%woo(is3,jjj,ke) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn3-cn5 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                    !dom(ib)%woo(is3,jjj,ke) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2	
                    !dom(ib)%woo(is3,jjj,ke) = t2
				endif
			endif
		elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is3,jjj,ke) is3 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                        !dom(ib)%woo(is3,jjj,ke) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2	
                    !dom(ib)%woo(is3,jjj,ke) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                    !dom(ib)%woo(is3,jjj,ke) = t2
                endif
			elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                    !dom(ib)%woo(is3,jjj,ke) = t2
				endif
			elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2
                    !dom(ib)%woo(is3,jjj,ke) = t2
				endif
			else
				call setMirror_w(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke) = t2	
                !dom(ib)%woo(is3,jjj,ke) = t2
		    endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis3hed Check of Face S3 ke
		!endif!12345 
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke2
		!
		!12345 if(dom(ib)%mwcz(is3,jjj,ke2).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                    !dom(ib)%woo(is3,jjj,ke2) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn3-cn5 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                    !dom(ib)%woo(is3,jjj,ke2) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2	
                    !dom(ib)%woo(is3,jjj,ke2) = t2
				endif
			endif
		elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is3,jjj,ke2) is3 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                        !dom(ib)%woo(is3,jjj,ke2) = t2
					endif
				else
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2	
                    !dom(ib)%woo(is3,jjj,ke2) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                    !dom(ib)%woo(is3,jjj,ke2) = t2
                endif
			elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                    !dom(ib)%woo(is3,jjj,ke2) = t2
				endif
			elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2
                    !dom(ib)%woo(is3,jjj,ke2) = t2
				endif
			else
				call setMirror_w(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                !if(fieldF.eq.1) dom(ib)%wstar(is3,jjj,ke2) = t2	
                !dom(ib)%woo(is3,jjj,ke2) = t2
		    endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis3hed Check of Face S3 ke2
		!endif!12345 
		!
		!
		!!!!!!!!!!!!!!!!!
		!! CHECKING FACE SE ke4
		!
		!12345 if(dom(ib)%mwcz(ie,jjj,ke4).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
		!	fx,fz					1 1		-1 -1	-1 -1	1 1
		!   fxk4,fzk4				1		-1		-1		1
		if (flagA .eq. 1) then
			!flag2 = 0
			! 1q	ae = dom(ib)%x(iii)		if pierced once		*/
			! 2q	ae = dom(ib)%x(iii-1) 	if pierced once		*\
			! 3q	ae = dom(ib)%x(iii-1) 	if pierced once		/.
			! 4q	ae = dom(ib)%x(iii)		if pierced once		\.
			if ( ( ndsx(4) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(4) > ae	fx > 0	pass
				! 2q		||				\.	ndsx(4) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(4) < ae	fx < 0	pass
				! 2q		||				*\	ndsx(4) > ae	fx > 0	pass
				!
				ys = ndsz(2) + (ndsz(4)-ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
				!
				! case a.1.1.2	 Checking if u(ie,jjj,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif		
				endif
			elseif ( ( ndsx(6) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(6) > ae	fx > 0	pass
				! 4q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 4q		||				*\	ndsx(6) > ae	fx > 0	pass
				!
				ys = ndsz(4) + (ndsz(6)-ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
				!
				! case a.1.1.2	 Checking if u(ie,jjj,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif		
				endif
			else
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
					! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
					! 2q		||				./	ndsx(3) < ae	fx < 0	pass
					! 3q		||				./	ndsx(3) < ae	fx < 0	pass
					! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc4 - ys2)*fz .lt. margin) then
						! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
						! 2q		||				./	ys2 < zc4	fx < 0	pass
						! 3q		||				./	ys2 < zc4	fx < 0	pass
						! 4q		||				/*	ys2 > zc4	fx > 0	pass
						!flag2 = 1
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif
				else
				! setting mirror value
					call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
					!dom(ib)%woo(ie,jjj,ke4) = t2
				endif
			endif
		endif
		!endif!12345
		!
		!
		!
		!12345 if(dom(ib)%mwcz(ie,jjj,ke4).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
		!	fx,fz					1 1		-1 -1	-1 -1	1 1
		!   fxk4,fzk4				1		-1		-1		1
		if (flagB .eq. 1) then
			!flag2 = 0
			! 1q	ae = dom(ib)%x(iii)		if pierced once		*/
			! 2q	ae = dom(ib)%x(iii-1) 	if pierced once		*\
			! 3q	ae = dom(ib)%x(iii-1) 	if pierced once		/.
			! 4q	ae = dom(ib)%x(iii)		if pierced once		\.
			if ( ( ndsx(6) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(6) > ae	fx > 0	pass
				! 4q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 4q		||				*\	ndsx(6) > ae	fx > 0	pass
				!
				ys = ndsz(4) + (ndsz(6)-ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
				!
				! case a.1.1.2	 Checking if u(ie,jjj,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif		
				endif
			elseif ( ( ndsx(8) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(8) > ae	fx > 0	pass
				! 6q		||				\.	ndsx(8) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(8) < ae	fx < 0	pass
				! 6q		||				*\	ndsx(8) > ae	fx > 0	pass
				!
				ys = ndsz(6) + (ndsz(8)-ndsz(6))*(ae-ndsx(6))/(ndsx(8)-ndsx(6))
				!
				! case a.1.1.2	 Checking if u(ie,jjj,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
							!dom(ib)%woo(ie,jjj,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif		
				endif
			else
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
					! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
					! 2q		||				./	ndsx(3) < ae	fx < 0	pass
					! 3q		||				./	ndsx(3) < ae	fx < 0	pass
					! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc4 - ys2)*fz .lt. margin) then
						! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
						! 2q		||				./	ys2 < zc4	fx < 0	pass
						! 3q		||				./	ys2 < zc4	fx < 0	pass
						! 4q		||				/*	ys2 > zc4	fx > 0	pass
						!flag2 = 1
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif
				elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
						!dom(ib)%woo(ie,jjj,ke4) = t2
					endif
				else
				! setting mirror value
					call setMirror_w(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
					!if(fieldF.eq.1) dom(ib)%wstar(ie,jjj,ke4) = t2
					!dom(ib)%woo(ie,jjj,ke4) = t2
				endif
			endif
		endif
		!endif!12345
		!!
		!
		!
		endif
		!
		endif

!######################################################################
	END SUBROUTINE setQuadrant_w
!######################################################################

!######################################################################
	SUBROUTINE setMirror_w(vec1,ndsx,ndsz,iq,kq,xq,zq,k)
!######################################################################
				!
		    	use imb
		    	use mpi
		        use multidata
		        use vars
		    	!
		    	implicit none
		    	!
		    	! temporal variables
		    	DOUBLE PRECISION:: temp
		    	!
		    	! Input valriables
		    	INTEGER, INTENT(IN):: vec1(8) !vec1(9)
		    	DOUBLE PRECISION, INTENT(IN):: ndsx(11), ndsz(11)
		    	!
		    	! Location of cell face center of ghost cell 
		    	INTEGER, INTENT(IN):: iq, kq
		        DOUBLE PRECISION, INTENT(IN):: xq, zq
		        DOUBLE PRECISION:: yq
		    	!
		    	! Output variables
		    	DOUBLE PRECISION, INTENT(OUT):: k
		    	!
		    	! Interfaces
		    	INTEGER:: nn, ib, ll, iii, jjj, kkk
		    	INTEGER::  qF, M
		    	! qF: quadrantFlag
		    	!
		    	! Search loop index
		    	INTEGER:: dd, bb, cc
		    	!
		    	! Location of the neares marker
		    	DOUBLE PRECISION:: mkx, mkz, mkx2, mkz2, mkx3, mkz3
		    	!
		    	! Distances between ghost cell and markers
		    	DOUBLE PRECISION:: rad1, rad2, radAux
		    	!
		    	! Angle of the closts markers to the ghost cell
		    	DOUBLE PRECISION:: cosTetha1, sinTetha1
		    	DOUBLE PRECISION:: cosAlpha1, cosAlpha2, tanBetha1
		    	DOUBLE PRECISION:: alpha1, alpha2, betha1, tetha1
		    	!
		    	! Location of mirror point
		    	DOUBLE PRECISION:: mrx, mry, mrz
		    	!
		    	! Indeces of mirror cell centre
		    	INTEGER:: id,jd, kd
		    	!
			    DOUBLE PRECISION:: origin_xc, origin_yc, origin_z
			    DOUBLE PRECISION::dx_l, dy_l, dz_l
		    	!
		    	! mirror velocities
		    	Integer:: ii, jj
		    	DOUBLE PRECISION:: mirror_w
		    	DOUBLE PRECISION:: nx(2),nz(2),wvec(4)
		    	INTEGER:: vec2(8)
		    	DOUBLE PRECISION:: vec3(3)
		    	!
		    	! Flags
		    	INTEGER:: flag90, flag1, flag2
		    	DOUBLE PRECISION:: fx, fz
		    	!
		    	! safety variables
		    	DOUBLE PRECISION:: margin
				!
				! writing warnings
				integer:: sn
				character*8 :: chb1
				character*35 :: gf ! file name
				!
				!
				!
				!if (myrank.eq. master ) then ! The control is passed down to the master processor
		        nn  = vec1(1)
		        ib  = vec1(2)
		        ll  = vec1(3)
		        iii = vec1(4)
		        jjj = vec1(5)
		        kkk = vec1(6)
		        qF  = vec1(7) ! this is defined in a finction later
		        M   =  vec1(8)
		        !
		    if(imbinblock_loc(dom_id(ib)+1).NE.0) then	! Filtering out procesors that do not 
															! have accesss to the domain where the 
			    if(imb_block_loc(nn).eq.dom_id(ib)) then
				!
				!origin_xc = vec1(8)
				!origin_y = vec1(9)
				!origin_z = vec1(10)
				!
				! Filter for testing
				! if( (qF.eq.1 ).and.(ll.lt.2) ) then
				!if( (ll.lt.2).and.((qF.eq.1).or.(qF.eq.2)) ) then
			    if( (ll.lt.2) ) then !.and.((qF.eq.1).or.(qF.eq.2)) ) then					
				!
				flag90 = 0
				margin = 1.0e-5
				!
				!!! Search loop for closest markers to the velocity cell centre
				mkx = ndsx(1)
				mkz = ndsz(1)
				mkx2 = ndsx(2)
				mkz2 = ndsz(2)
				dd = 2
				bb = dd - 1
				cc = dd

				rad1 = (mkx-xq)**2 + (mkz-zq)**2
				rad2 = (mkx2-xq)**2 + (mkz2-zq)**2

				mkx3 = ndsx(3)
				mkz3 = ndsz(3)
				radAux = (mkx3-xq)**2 + (mkz3-zq)**2
				if (radAux .lt. rad2) then
					mkx2 = mkx
					mkz2 = mkz
					mkx  = mkx3
					mkz  = mkz3
					rad2 = rad1
					rad1 = radAux

					bb = dd + 1
					cc = dd - 1
				endif

				
				do dd = 4, 10, 2

					mkx3 = ndsx(dd)
					mkz3 = ndsz(dd)					
					radAux = (mkx3-xq)**2 + (mkz3-zq)**2										

					if (radAux .lt. rad1) then
						mkx  = mkx2
						mkz  = mkz2
						mkx2 = mkx3
						mkz2 = mkz3	
						rad1 = rad2
						rad2 = radAux
						bb = dd - 2
						cc = dd
					else
						mkx3 = ndsx(dd+1)
						mkz3 = ndsz(dd+1)
						radAux = (mkx3-xq)**2 + (mkz3-zq)**2
						if (radAux .lt. rad2) then
							mkx2 = mkx
							mkz2 = mkz
							mkx  = mkx3
							mkz  = mkz3	
							rad2 = rad1
							rad1 = radAux
							bb = dd + 1
							cc = dd - 1
						endif
					endif
				enddo

				rad1 = sqrt(rad1)
				rad2 = sqrt(rad2)
				

				cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) ! alpha1: angle between U cell centre and segment mk1-mk2
				cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) ! alpha2: angle between U cell centre and segment mk2-mk1
				alpha1 = DACOS(cosAlpha1)*180/piNUm
				alpha2 = DACOS(cosAlpha2)*180/piNum
				! If there is a normal from the velocity cell centre to the surface (segment mk1-mk2) alpha1 < 90 and alpha2 < 90


				if( (nn.gt.0).and.(nn.lt.127) ) then
				if (alpha1 .gt. 90) then
					flag90 = 1
					write(6,*) "Warning in mirror_w subroutine!", nn
					write(6,*) "alpha1 greater thant 90: ", alpha1
					write(6,*) ""
					! Update bb and cc
					if (bb .eq. 2) then
						! bb = 2		cc = 4
						bb = bb - 1
						cc = cc - 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb - 2
						cc = cc - 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb + 2
						cc = cc + 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNum

				
				elseif (alpha2 .gt. 90) then
					flag90 = 1
					write(6,*) "Warning in mirror_w subroutine!", nn
					write(6,*) "Warning: alpha2 greater thant 90: ", alpha2
					write(6,*) ""
					! Update bb and redefine the nodes
					if (bb .eq. 1) then
						! bb = 1		cc = 2
						bb = bb + 1
						cc = cc + 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb + 2
						cc = cc + 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb - 2
						cc = cc - 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNum				
				endif
				endif

				if (flag90) then
					write(chb1,'(i6)') nn
					sn=len(trim(adjustl(chb1)))
					gf='w_w_m_alpha'//repeat('0',(6-sn))//trim(adjustl(chb1))
					OPEN(unit = 906, access = "sequential", action = "write",
     &   status = "replace", file = gf, form = "formatted") 

					!	write(6,*) "*** Index, Qudarant ***"
						write(906,*) nn, qF
						write(906,*) ndsx
						write(906,*) ndsz
						write(906,*) iii, kkk, jjj	
						write(906,*) iq, kq
						write(906,*) alpha1, alpha2
						!write(6,*) betha1, tetha1
					! location of P pressure cell centre
						write(906,*) xq, zq
					! location of closest markers
						write(906,*) mkx, mkz
						write(906,*) mkx2, mkz2
						write(906,*) bb, cc		
						write(906,*) ndsx(bb), ndsz(bb)
						write(906,*) ndsx(cc), ndsz(cc)
						!write(6,*) mrx, mrz		
						write(906,*) id, kd
						write(906,*) "==="
						close(906)
					endif

				! redefining quadrant of the neighbouring markers
				qF = quadrant(ndsx(bb), ndsz(bb),ndsx(cc), ndsz(cc),margin)
				!
				!
				dx_l = dom(ib)%dx
				dy_l = dom(ib)%dy
				dz_l = dom(ib)%dz
				!
				origin_xc = dom(ib)%xc(1)
				origin_yc = dom(ib)%yc(1)
				origin_z = dom(ib)%z(1)
				!
				!
				!
		    	if (qF.eq.1) then
		    		!
		    		tetha1 = alpha1 - betha1 
		    		cosTetha1 = DCOS(tetha1*piNUm/180)
		    		sinTetha1 = DSIN(tetha1*piNUm/180)
		    		! The mirror point will always be forward of marker1
		    		mrx = mkx + rad1*cosTetha1
		    		! mry = ???
		    		! The mirror point may be above marker1 if betha1 > alpha1
		    		mrz = mkz - rad1*sinTetha1
		    	elseif(qF.eq.2) then
		    		tetha1 =   alpha1 - (90 - betha1) 
		    		cosTetha1 = DCOS(tetha1*piNUm/180)
		    		sinTetha1 = DSIN(tetha1*piNUm/180)
		    		! The mirror point may be behind maker1 if alpha1 < (90 - betha1)
		    		mrx = mkx + rad1*sinTetha1
		    		! mry = ???
		    		! The mirror point will alpway be above marker1
		    		mrz = mkz + rad1*cosTetha1
		    	elseif(qF.eq.3) then
		    		tetha1 = betha1 - alpha1
		    		cosTetha1 = DCOS(tetha1*piNUm/180)
		    		sinTetha1 = DSIN(tetha1*piNUm/180)
		    		! The mirror point will always be behind marker 1
		    		mrx = mkx - rad1*cosTetha1
		    		! mry = ???
		    		! The mirror point may be above marker 1 if alpha1 > betha1
		    		mrz = mkz - rad1*sinTetha1
		    		!
		    	elseif(qF.eq.4) then
		    		!
		    		tetha1 = 90 - betha1 - alpha1
		    		cosTetha1 = DCOS(tetha1*piNUm/180)
		    		sinTetha1 = DSIN(tetha1*piNUm/180)
		    		!
		    		! mirror point may be behind or forward of marker 1 if alpha1 > (90 - betha1)
		    		mrx = mkx + rad1*sinTetha1
		    		! mry = ???
		    		! mirror point will alway be bellow marker 1
		    		mrz = mkz - rad1*cosTetha1
		    		!
		    	endif
		    	!
			! Indices of the mirror W cell
			id = int ( ( mrx - origin_xc - margin) /dx_l) + 2 
			!jd = int ( ( mry - origin_yc - margin) /dy_l) + 2
			kd = int ( ( mrz - origin_z - margin) /dz_l) + 2
			!
                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				!!! BILINEAR INTERPOLATION
			!
			wvec(1) = dom(ib)%wcpy(id-1,jjj,kd-1) ! q11
			wvec(2) = dom(ib)%wcpy(id,jjj,kd-1)   ! q21
			wvec(3) = dom(ib)%wcpy(id-1,jjj,kd)   ! q12
			wvec(4) = dom(ib)%wcpy(id,jjj,kd)	   ! q22
			!
			nx(1) = dom(ib)%xc(id-1)
			nx(2) = dom(ib)%xc(id)
			nz(1) = dom(ib)%z(kd-1)
			nz(2) = dom(ib)%z(kd)
			!
			!mirror_w = bilinear1(nn,nx,nz,wvec,mrx,mrz)
			!if(nn.eq.126) then
			!	write(6,*) "Mirror w (Bilinear Interpolation: explicit)",mirror_w
			!endif

			! Alternative (2nd order Least Squares & Cramer's solver)
			!mirror_w = ls_2ndOrder_cramer(nn,nx,nz,wvec,mrx,mrz)
			!if ( nn.eq.70 ) then
			! write(6,*) "Mirror w (2nd order Least Squares: cramer)",nn,mirror_w
			!endif

			!!! LINEAR INTERPOLATION
			!mirror_w = l1(nn,nx,nz,wvec,mrx,mrz)
			!if(nn.lt.127) then
			!	write(6,*) "Mirror w (linear interpolation)",nn, mirror_w
			!endif

			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!Alternative (Least Squares & Cramer's solver)
			!mirror_w = ls_cramer(nn,nx,nz,wvec,mrx,mrz)
			!if(nn.eq.70) then
			! write(6,*) "Mirror w (Least Squares: cramer)",nn, mirror_w
			!endif

			! Alternative: Bilinear Interpoaltion and Cramer's solver
	!		mirror_w = bl_cramer(nn,nx,nz,wvec,mrx,mrz)
			!if ( nn.eq.70 ) then
			! write(6,*) "Mirror w (Bilinear Interpolation: cramer)", nn, mirror_w
			!endif

			! Alternative: delta functions and mvs
	!		Alternative: deltaFUnction
			vec2(1) = nn	! Node nds(1.5)
			vec2(2) = ib 
			vec2(3) = ll
			vec2(4) = id 
			vec2(5) = jjj
			vec2(6) = kd
			vec2(7) = qF
			vec2(8) = 3 ! fieldFlag for selecting u velocity
			vec3(1) = mrx
			vec3(2) = dom(ib)%y(jjj) ! dom(ib)%yc(jjj) 
			vec3(3) = mrz
			call interpolationF(vec2,vec3,mirror_w)
			!
			!
			!
			!
			! lets flag this cell as a body cell
			dom(ib)%mwcz(iq,jjj,kq) = qF
			!
			! Lets add the necesary information
			yq = dom(ib)%y(jjj) ! dom(ib)%yc(jjj)
			dom(ib)%mwcznn(iq,jjj,kq) = nn  ! nn for w ghost cells
			dom(ib)%mwczib(iq,jjj,kq) = ib  ! ib for w ghost cells
			dom(ib)%mwczll(iq,jjj,kq) = ll  ! ll for w ghost cells
			dom(ib)%mwczi(iq,jjj,kq)  = iq  ! %x  id for w ghost cells centre
			dom(ib)%mwczj(iq,jjj,kq)  = jjj ! %yc id for w ghost cells centre
			dom(ib)%mwczk(iq,jjj,kq)  = kq  ! %z  id for w ghost cells centre
			dom(ib)%mwczx(iq,jjj,kq)  = xq  ! %x  for w ghost cells centre
			dom(ib)%mwczy(iq,jjj,kq)  = yq  ! %yc for w ghost cells centre
			dom(ib)%mwczz(iq,jjj,kq)  = zq  ! %z  for w ghost cells centre
			dom(ib)%mwczmi(iq,jjj,kq) = id  ! %x  id for w mirror point in fluid cells
			dom(ib)%mwczmj(iq,jjj,kq) = jjj ! %yc id for w mirror point in fluid cells
			dom(ib)%mwczmk(iq,jjj,kq) = kd  ! %z  id for w mirror point in fluid cells
			dom(ib)%mwczmx(iq,jjj,kq) = mrx ! %x  for w mirror point in fluid cells
			dom(ib)%mwczmy(iq,jjj,kq) = yq  ! %yc for w mirror point in fluid cells
			dom(ib)%mwczmz(iq,jjj,kq) = mrz ! %z  for w mirror point in fluid cells
			!
			!if (rott_loc(nn).eq.1) then
			  if(rotating(M).eq..FALSE.) then
			    k = - mirror_w ! 
			  	!k = -1.0d00
			  !elseif(rott_loc(nn).eq.2) then
			  elseif(rotating(M).eq..TRUE.) then
				k = 2*W_p - mirror_w !moving body
				!k = -1.0d00
			  endif
			  !
			  !debug
		!	  if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!	  !	write(6,*) nn, k ,rott_loc(nn)
		!	  	write(6,*) nn, k, M, dom(ib)%mwczold(iq,jjj,kq)
		!	  !write(6,*) qF, fieldF, fieldVal
		!	  !write(6,*) vec2(1),vec2(2),vec2(3)
		!	  !write(6,*) vec2(4),vec2(5),vec2(6)
		!	  !write(6,*) vec2(7),vec2(8)
		!	  !write(6,*) vec3(1),vec3(2),vec3(3)
		!	  !write(6,*) "======================="
		!	  endif
			!
			! check mirror point ofr w	
			!	if ( (nn.gt.0).and.(nn.lt.127) ) then
			!		wz1 = abs(0.5d00 - sqrt( (18.00d00-xq)**2 + (10.50d00-zq)**2 ))
			!		wz2 = abs(sqrt( (18.0d00-mrx)**2 + (10.5d00-mrz)**2 ) - 0.5d00)
			!		wz1 = abs(wz1-wz2)
			!	!	write(6,*) nn, iq, kq
			!		write(6,*) nn, wz1
			!	!	write(6,*) alpha1, alpha2
			!	!	write(6,*) betha1, tetha1
			!	endif
			else
		    	k = 0.0d00
				dom(ib)%mwcz(iq,jjj,kq) = qF
				dom(ib)%mwcznn(iq,jjj,kq) = nn  ! nn for w ghost cells
				dom(ib)%mwczib(iq,jjj,kq) = ib  ! ib for w ghost cells
				dom(ib)%mwczll(iq,jjj,kq) = ll  ! ll for w ghost cells
				dom(ib)%mwczi(iq,jjj,kq)  = iq  ! %x  id for w ghost cells centre
				dom(ib)%mwczj(iq,jjj,kq)  = jjj ! %yc id for w ghost cells centre
				dom(ib)%mwczk(iq,jjj,kq)  = kq  ! %z  id for w ghost cells centre
				dom(ib)%mwczx(iq,jjj,kq)  = xq  ! %x  for w ghost cells centre
				dom(ib)%mwczy(iq,jjj,kq)  = yq  ! %yc for w ghost cells centre
				dom(ib)%mwczz(iq,jjj,kq)  = zq  ! %z  for w ghost cells centre
				dom(ib)%mwczmi(iq,jjj,kq) = 0  ! %x  id for w mirror point in fluid cells
				dom(ib)%mwczmj(iq,jjj,kq) = 0 ! %yc id for w mirror point in fluid cells
				dom(ib)%mwczmk(iq,jjj,kq) = 0  ! %z  id for w mirror point in fluid cells
				dom(ib)%mwczmx(iq,jjj,kq) = 0.0d00 ! %x  for w mirror point in fluid cells
				dom(ib)%mwczmy(iq,jjj,kq) = 0.0d00  ! %yc for w mirror point in fluid cells
				dom(ib)%mwczmz(iq,jjj,kq) = 0.0d00 ! %z  for w mirror point in fluid cells
		    endif
			!
			!!! END PROCESOR HANDLING subdomain ib
		    endif
			!
	       endif


			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!!!!!!!!       FUNCTION DECLARATION       !!!!!!!!
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

			CONTAINS

			!######################################################################
			DOUBLE PRECISION FUNCTION bilinear1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
			DOUBLE PRECISION:: factor1
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			
			factor1 = 1.0d00/( (x2-x1)*(z2-z1) )
							
			m1(1) = x2 - mrx
			m1(2) = mrx - x1
			
			m2(1,1) = q11	! First row, 1st column
			m2(2,1) = q12	! 1 st row, 2 nd column
			m2(1,2) = q21	! 2 nd row,	1 st column
			m2(2,2) = q22	! 2 nd row, 2 nd column
			
			m3(1) = z2 - mrz
			m3(2) = mrz - z1
			
			m4 = matmul(m1,m2)
			
			bilinear1 = factor1*dot_product(m3,m4)
			
			!######################################################################
			END FUNCTION bilinear1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Second order Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			
			
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = dx1*dx1; a1(5,1) = dz1*dz1; a1(6,1) = dx1*dz1

			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = dx2*dx2; a1(5,2) = dz1*dz1; a1(6,2) = dx2*dz1

			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = dx1*dx1; a1(5,3) = dz2*dz2; a1(6,3) = dx1*dz2

			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = dx2*dx2; a1(5,4) = dz2*dz2; a1(6,4) = dx2*dz2

			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,6)
			
			ls_2ndOrder_cramer = sol(1)
			
			!######################################################################
			END FUNCTION ls_2ndOrder_cramer
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION l1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################

			implicit none

			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			DOUBLE PRECISION:: ux1,uz1,ux2,uz2
			DOUBLE PRECISION:: x1,z1,x2,z2
			DOUBLE PRECISION:: mirror_ux1, mirror_ux2 
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!! LINEAR INTERPOLATION
				! mirror velocity for x = mrx and z = zc(kd) = z1
			!	ux1 = dom(ib)%u(id,jjj,kd)
			!	ux2 = dom(ib)%u(id+1,jjj,kd)
			!	x1 = dom(ib)%x(id)
			!	x2 = dom(ib)%x(id+1)

				! Alternative
			ux1 = uvec(1)	!dom(ib)%u(id,jjj,kd)
			ux2 = uvec(2) 	!dom(ib)%u(id-1,jjj,kd)
			x1 = nx(1) 	!dom(ib)%x(id)
			x2 = nx(2)	!dom(ib)%x(id-1)
			
			mirror_ux1 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = zc(kd-1) = z2				
			!ux1 = dom(ib)%u(id,jjj,kd-1)
			!ux2 = dom(ib)%u(id+1,jjj,kd-1)

			! Alternative
			ux1 = uvec(3)	!dom(ib)%u(id,jjj,kd-1)
			ux2 = uvec(4)	!dom(ib)%u(id-1,jjj,kd-1)

			mirror_ux2 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)

			! mirror velocity for x = mrx and z = mrz
			uz1 = mirror_ux1
			uz2 = mirror_ux2
			z1 = nz(1)	!dom(ib)%zc(kd)
			z2 = nz(2)	!dom(ib)%zc(kd-1)

			l1 = uz1 + (uz2-uz1)*(mrz-z1)/(z2-z1)


			!######################################################################
			END FUNCTION l1
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION cosAngle(x1,z1,x2,z2,x3,z3,l12)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: x1,z1,x2,z2,x3,z3,l12
			DOUBLE PRECISION:: x12,z12, x13, l13, z13

			x12 = x2-x1
			z12 = z2-z1
			x13 = x3-x1
			z13 = z3-z1
			l13 = sqrt(x13**2+z13**2)

			cosAngle = (x12*x13 + z12*z13)/(l12*l13)


			!######################################################################
			END FUNCTION cosAngle
			!######################################################################


			!######################################################################
			INTEGER FUNCTION quadrant(cnx,cnz,cnx2,cnz2,margin)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: cnx,cnz,cnx2,cnz2, margin
			INTEGER:: qFlag

										! ( 0, 90 ] First quadrant?
			if ( (cnx2 - cnx) .gt. -margin) then
			if ( (cnz2 - cnz) .gt. margin) then	! Proper way

				qFlag = 1			

			endif
			endif


			! ( 90, 180 ] 2nd quadrant?
			if ( (cnx2 - cnx) .le. -margin) then
			if ( (cnz2 - cnz) .ge. -margin) then

				qFlag = 2

			! End 2nd Quadrant ops
			endif
			endif


			! ( 180, 270 ] 3rd quadrant?
			if ( (cnx2 - cnx) .le. margin) then
			if ( (cnz2 - cnz) .lt. -margin) then

				qFlag = 3

			endif
			endif

			! ( 270, 360 ] 4th quadrant?
			if ( (cnx2 - cnx) .gt. margin) then
			if ( (cnz2 - cnz) .le. margin) then

				qFlag = 4


			endif
			endif		

			quadrant = qFlag

			!######################################################################
			END FUNCTION quadrant
			!######################################################################


!######################################################################		
			END SUBROUTINE setMirror_w
!######################################################################


!######################################################################			
	SUBROUTINE setQuadrant_p(nn,ll,ib,ndsx,ndsz,iic,jjc,kkc,qF)
!######################################################################		
		use imb
		use mpi
		use multidata

		implicit none

		! temporal variables
		DOUBLE PRECISION:: temp, t1, t2

		! Input valriables
		INTEGER, INTENT(IN):: nn, ll, ib, iic,jjc,kkc
		INTEGER, INTENT(IN):: qF
		DOUBLE PRECISION, INTENT(IN)::ndsx(11),ndsz(11)

		! safety variables
		DOUBLE PRECISION:: margin

		! Intersections
		DOUBLE PRECISION:: ys, ys2

		! Locations of faces
		DOUBLE PRECISION:: as3,as2,as,ae,ae2,ae3

		DOUBLE PRECISION:: cs3,cs2,cs,ce,ce2,ce3

		DOUBLE PRECISION:: zc0, zc1, zc2, zc3, zc4

		! Indeces of faces
		INTEGER:: ke0,ke,ke2,ke3,ke4
		INTEGER:: ie, is, is2, is3

		! Special variables for avoiding selecting cell outise the geometry in the 2nd and 4th quarters
		INTEGER:: isq, keq, ieq
		DOUBLE PRECISION:: asq, aeq
		INTEGER:: fxq1, fzq1, fxq2, fzq2, fxs3, fzs3, fxk3, fzk3

		
		! Flags
		INTEGER:: flag1, flag2, flagA, flagB
		DOUBLE PRECISION:: fx, fz

		! Interfaces
		INTEGER:: vec1(7)

		vec1(1) = nn
		vec1(2) = ib
		vec1(3) = ll
		vec1(4) = iic
		vec1(5) = jjc
		vec1(6) = kkc
		vec1(7) = qF

		margin = 1.0e-5

		!if (myrank.eq. master ) then ! The control is passed down to the master processor
		if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
			IF(imb_block_loc(nn).eq.dom_id(ib)) then

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 1st quadrant

		if (qF.eq.1) then

		as3 = dom(ib)%xc(iic-3)
		as2 = dom(ib)%xc(iic-2)	
		as = dom(ib)%xc(iic-1) 
		asq = as

		ae = dom(ib)%xc(iic) 
		aeq = as !ae
		
		ae2 = dom(ib)%xc(iic+1)
		ae3 = dom(ib)%xc(iic+2)
		
		cs3 = dom(ib)%z(kkc-3)
		cs2 = dom(ib)%z(kkc-2)
		cs = dom(ib)%z(kkc-1)

		ce = dom(ib)%z(kkc) 
		ce2 = dom(ib)%z(kkc+1)
		ce3 = dom(ib)%z(kkc+2)	

		zc0 = dom(ib)%zc(kkc-1)	! cell cetre. We want to obtain the mirror value for this cell centre
		zc1 = dom(ib)%zc(kkc)	! cell cetre. We want to obtain the mirror value for this cell centre
		zc2 = dom(ib)%zc(kkc+1)	! cell cetre. We want to obtain the mirror value for this cell centre
		zc3 = dom(ib)%zc(kkc+2)	! cell cetre. We want to obtain the mirror value for this cell centre
		zc4 = dom(ib)%zc(kkc+3)	! cell cetre. We want to obtain the mirror value for this cell centre		

		

		ie = iic; ke = kkc; ke0 = kkc-1
		ke2 = kkc+1; ke3 = kkc+2; ke4 = kkc+3

		is = iic-1 ; is2 = iic-2; is3 = iic - 3
		isq = is; keq = ke
		ieq = is	

		fx = 1.0d00
		fz = 1.0d00
		fxq1 = fx
		fzq1 = fz
		fxq2 = fx
		fzq2 = fz
		fxs3 = fx
		fzs3 = fz

		endif

		! bbbb

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 2nd quadrant

		if (qF.eq.2) then

			ae3 = dom(ib)%xc(iic-3)
			ae2 = dom(ib)%xc(iic-2)	
			ae = dom(ib)%xc(iic-1) 
	
			as = dom(ib)%xc(iic) 
			asq = ae
			aeq = ae

			as2 = dom(ib)%xc(iic-2)
			as3 = dom(ib)%xc(iic-3)

			

			cs3 = dom(ib)%z(kkc-3)
			cs2 = dom(ib)%z(kkc-2)
			cs = dom(ib)%z(kkc-1)
	
			ce = dom(ib)%z(kkc) 
			ce2 = dom(ib)%z(kkc+1)
			ce3 = dom(ib)%z(kkc+2)

			zc0 = dom(ib)%zc(kkc+1)	! cell cetre. We want to obtain the mirror value for this cell centre
			zc1 = dom(ib)%zc(kkc)	! cell cetre. We want to obtain the mirror value for this cell centre
			zc2 = dom(ib)%zc(kkc-1)	! cell cetre. We want to obtain the mirror value for this cell centre
			zc3 = dom(ib)%zc(kkc-2)	! cell cetre. We want to obtain the mirror value for this cell centre
			zc4 = dom(ib)%zc(kkc-3)	! cell cetre. We want to obtain the mirror value for this cell centre				
	
			ie = iic-1; ke = kkc; ke0 = kkc+1
			ke2 = kkc-1; ke3 = kkc-2; ke4 = kkc-3
	
			is = iic; is2 = iic-2; is3 = iic - 3
			isq = is; keq = kkc + 1
			ieq = ie
				
			fx = -1.0d00
			fz = -1.0d00
			fxq1 = fx
			fzq1 = fz
			fxq2 = -fx
			fzq2 = -fz		
			fxs3 = -fx
			fzs3 = -fz

			endif



		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 3rd quadrant
				
			if (qF.eq.3) then

				ae3 = dom(ib)%xc(iic-3)
				ae2 = dom(ib)%xc(iic-2)	
				ae = dom(ib)%xc(iic-1) 
		
				as = dom(ib)%xc(iic) 
				asq = as
				aeq = as
	
				as2 = dom(ib)%xc(iic+1)
				as3 = dom(ib)%xc(iic+2)
	
				
	
				cs3 = dom(ib)%z(kkc-3)
				cs2 = dom(ib)%z(kkc-2)
				cs = dom(ib)%z(kkc-1)
		
				ce = dom(ib)%z(kkc) 
				ce2 = dom(ib)%z(kkc+1)
				ce3 = dom(ib)%z(kkc+2)	

				zc0 = dom(ib)%zc(kkc+1)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc1 = dom(ib)%zc(kkc)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc2 = dom(ib)%zc(kkc-1)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc3 = dom(ib)%zc(kkc-2)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc4 = dom(ib)%zc(kkc-3)	! cell cetre. We want to obtain the mirror value for this cell centre					
		
				ie = iic-1; ke = kkc; ke0 = kkc+1
				ke2 = kkc-1; ke3 = kkc-2; ke4 = kkc-3
		
				is = iic; is2 = iic+1; is3 = iic+2
				isq = is; keq = ke		
				ieq = is
						
			!	is = iic; is2 = iic; is3 = iic + 1

				fx = -1.0d00
				fz = -1.0d00
				fxq1 = -fx
				fzq1 = -fz
				fxq2 = fx
				fzq2 = fz
				fxs3 = fx
				fzs3 = fz


				endif



		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Setting parameters for 4th quadrant
				
			if (qF.eq.4) then

				ae3 = dom(ib)%xc(iic+2)
				ae2 = dom(ib)%xc(iic+1)	
	
	
	
				ae = dom(ib)%xc(iic) 
				
		
				as = dom(ib)%xc(iic-1) 
				asq = ae
				aeq = ae
	
				as2 = dom(ib)%xc(iic+1)
	
				as3 = dom(ib)%xc(iic+2)
	
				
	
				cs3 = dom(ib)%z(kkc-3)
				cs2 = dom(ib)%z(kkc-2)
				cs = dom(ib)%z(kkc-1)
		
				ce = dom(ib)%z(kkc) 
				ce2 = dom(ib)%z(kkc+1)
				ce3 = dom(ib)%z(kkc+2)	

				zc0 = dom(ib)%zc(kkc-1)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc1 = dom(ib)%zc(kkc)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc2 = dom(ib)%zc(kkc+1)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc3 = dom(ib)%zc(kkc+2)	! cell cetre. We want to obtain the mirror value for this cell centre
				zc4 = dom(ib)%zc(kkc+3)	! cell cetre. We want to obtain the mirror value for this cell centre					

				ie = iic; ke = kkc; ke0 = kkc-1
				ke2 = kkc+1; ke3 = kkc+2; ke4 = kkc+3
		
				is = iic-1; is2 = iic+1; is3 = iic+2
				isq = ie; keq = kkc - 1
				ieq = ie
		
				fx = 1.0d00
				fz = 1.0d00
				fxq1 = fx
				fzq1 = fz
				fxq2 = -fx
				fzq2 = -fz
				fxs3 = -fx
				fzs3 = -fz
		
				endif

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Checking quadrants

		flag1 = 0
		flag2 = 0

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE E
		if ( ( ndsx(2) -  ae )*fx.gt. -margin ) then	! The East Face is pierced for the FIRTS TIME
			!
			ys = ndsz(1) + (ndsz(2) - ndsz(1))*(ae - ndsx(1))/(ndsx(2) - ndsx(1))
			!
			! case a.1.1.1	 Checking if u(ie,jjc,ke0) is above cn-cn2
			!12345 if(dom(ib)%mpc(ie,jjc,ke0).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( zc0 - ys)*fz .gt. -margin ) then		
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marke0r cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
						!dom(ib)%p(ie,jjc,ke0) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marke0r cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
						!dom(ib)%p(ie,jjc,ke0) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc0 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
						!dom(ib)%p(ie,jjc,ke0) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke0,ae,zc0,t2)
					!dom(ib)%p(ie,jjc,ke0) = t2				
				endif		
			!endif
			! case a.1.1.2	 Checking if u(ie,jjc,ke04) is above cn-cn2
			else
				!flag2 = 1
				flagA = 1
		
			endif
			!endif!12345 
			!
			!
			!
			! case a.1.1.1	 Checking if u(ie,jjc,ke) is above cn-cn2
			!12345 if(dom(ib)%mpc(ie,jjc,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
						!dom(ib)%p(ie,jjc,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
						!dom(ib)%p(ie,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
						!dom(ib)%p(ie,jjc,ke) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
					!dom(ib)%p(ie,jjc,ke) = t2				
				endif		
			!endif
			! case a.1.1.2	 Checking if u(ie,jjc,ke4) is above cn-cn2
			else
				!flag2 = 1
				flagA = 1
		
			endif
			!endif!12345 
			!
			!
			!
		! case a.1.1.2	 Checking if u(ie,jjc,ke2) is above cn-cn2
			!12345 if(dom(ib)%mpc(ie,jjc,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( zc2 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
						!dom(ib)%p(ie,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
						!dom(ib)%p(ie,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
						!dom(ib)%p(ie,jjc,ke2) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
					!dom(ib)%p(ie,jjc,ke2) = t2
				endif		
			endif
			!endif!12345 
			!
			!
			!
			! case a.1.1.2	 Checking if u(ie,jjc,ke3) is above cn-cn2
			!12345 if(dom(ib)%mpc(ie,jjc,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( zc3 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
						!dom(ib)%p(ie,jjc,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
						!dom(ib)%p(ie,jjc,ke3) = t2
					endif
				elseif ( ( ndsx(4) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
						!dom(ib)%p(ie,jjc,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
						!dom(ib)%p(ie,jjc,ke3) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
					!dom(ib)%p(ie,jjc,ke3) = t2
				endif		
			endif
			!endif!12345 
			!
			!
			!
		elseif ( ( ndsx(4) - ae )*fx .gt. -margin ) then	! The East face is pierced for the FIRST TIME
			!
		ys = ndsz(2) + (ndsz(4)-ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
		!
			! case a.2.1.1	Checking if u(ie,jjc,ke) is above cn2-cn4
			!12345 if(dom(ib)%mpc(ie,jjc,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
						!dom(ib)%p(ie,jjc,ke) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
						!dom(ib)%p(ie,jjc,ke) = t2
					endif																											
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
						!dom(ib)%p(ie,jjc,ke) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke,ae,zc1,t2)
					!dom(ib)%p(ie,jjc,ke) = t2
				endif			
			else
				!flag2 = 1
				flagB = 1
			endif
			!endif!12345 
			!
			!
			!
			! case a.2.1.2  Checking if u(ie,jjc,ke2) is above cn2-cn4 
			!12345 if(dom(ib)%mpc(ie,jjc,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( zc2 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
						!dom(ib)%p(ie,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
						!dom(ib)%p(ie,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn6 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
						!dom(ib)%p(ie,jjc,ke2) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke2,ae,zc2,t2)
					!dom(ib)%p(ie,jjc,ke2) = t2
				endif		
			endif
			!endif!12345 
			!
			!
			!
		! case a.1.1.2	 Checking if u(ie,jjc,ke3) is above cn-cn2
			!12345 if(dom(ib)%mpc(ie,jjc,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if( ( zc3 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
						!dom(ib)%p(ie,jjc,ke3) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
						!dom(ib)%p(ie,jjc,ke3) = t2
					endif
				elseif ( ( ndsx(6) - ae )*fx .lt. margin) then	! safety check  in case cn4 pierced the East face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc3 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
						!dom(ib)%p(ie,jjc,ke3) = t2
					endif
		! There  may be an issue			
				else
					call setMirror_p(vec1,ndsx,ndsz,ie,ke3,ae,zc3,t2)
					!dom(ib)%p(ie,jjc,ke3) = t2					
				endif		
			endif
			!endif!12345 
			!
			!
			!
		! WARNING A				
		!else			
		elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too
			!
			! case a.2.1.1	Checking if u(ieq,jjc,ke) is above cn4-cn6
			!12345 if(dom(ib)%mpc(ie,jjc,ke).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
				if( ( zc1 - ys2)*fzq1 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
					!dom(ib)%p(ieq,jjc,ke) = t2
				endif
			elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
				if( ( zc1 - ys2)*fzq1 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
					!dom(ib)%p(ieq,jjc,ke) = t2
				endif
		! There  may be an issue
			else
				call setMirror_p(vec1,ndsx,ndsz,ieq,ke,aeq,zc1,t2)
				!dom(ib)%p(ieq,jjc,ke) = t2
			endif
			!endif!12345 
			!
			!
			!
			! case a.2.1.2  Checking if u(ieq,jjc,ke2) is above cn4-cn6 
			!12345 if(dom(ib)%mpc(ie,jjc,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
				if( ( zc2 - ys2)*fzq1 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					!dom(ib)%p(ieq,jjc,ke2) = t2
				endif
			elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn5 pierces the East face too
				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
				if( ( zc2 - ys2)*fzq1 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
					!dom(ib)%p(ieq,jjc,ke2) = t2
				endif
	!		elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn6 pierced the East face too
	!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
	!			if ( ( zc2 - ys2)*fzq1 .lt. margin) then
				call setMirror_p(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
				!dom(ib)%p(ieq,jjc,ke2) = t2
	!			endif
	! There  may be an issue
			else
				call setMirror_p(vec1,ndsx,ndsz,ieq,ke2,aeq,zc2,t2)
				!dom(ib)%p(ieq,jjc,ke2) = t2
			endif
			!endif!12345 
			!
			!
			!
			! case a.1.1.2	 Checking if u(ieq,jjc,ke3) is above cn4-cn6
			!12345 if(dom(ib)%mpc(ie,jjc,ke3).eq.0) then	! checking if this cell has already been flagged
			!if(1) then
			if ( ( ndsx(3) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(aeq-ndsx(3))/(ndsx(1)-ndsx(3))
				if( ( zc3 - ys2)*fzq1 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					!dom(ib)%p(ieq,jjc,ke3) = t2
				endif
			elseif ( ( ndsx(5) - aeq )*fxq1 .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
				ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(aeq-ndsx(5))/(ndsx(3)-ndsx(5))
				if( ( zc3 - ys2)*fzq1 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
					!dom(ib)%p(ieq,jjc,ke3) = t2
				endif
	!		elseif ( ( ndsx(6) - aeq )*fxq1 .lt. margin) then	! safety check  in case cn4 pierced the East face too
	!			ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(aeq-ndsx(4))/(ndsx(6)-ndsx(4))
	!			if ( ( zc3 - ys2)*fzq1 .lt. margin) then
	!			call setMirror_p(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
	!			dom(ib)%p(ieq,jjc,ke3) = t2
	!			endif
	! There  may be an issue			
			else
				call setMirror_p(vec1,ndsx,ndsz,ieq,ke3,aeq,zc3,t2)
				!dom(ib)%p(ieq,jjc,ke3) = t2				
			endif
			!endif!12345 


		! WARNING A	
		!else	! The East face has not been pierced 
			flag1 = 1

		
		endif !!! FINISHED CHECKING FACE E


		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S
		!
		!12345 if(dom(ib)%mwcz(is,jjc,ke).eq.0) then	! checking if this cell has already been flagged
        !if(1) then	! checking if this cell has already been flagged
        !   1 1       -1 -1      -1 -1      1 1
		if ( (ndsx(3) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
		! 1q	if pierced  ./	ndsx(3) < as	fx > 0	pass
		! 2q		||		.\	ndsx(3) > as	fx < 0	pass
		! 3q		||		/*	ndsx(3) > as	fx < 0	pass
		! 4q		||		\*	ndsx(3) < as	fx > 0	pass
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is,jjc,ke) is bellow cn3-cn
			if( ( zc1 - ys)*fz .gt. -margin ) then
				! 1q	if inside   ./	zc1 > ys	fz > 0	pass
				! 2q		||  	.\	zc1 < ys	fz < 0	pass
				! 3q		||	    /*	zc1 < ys	fz < 0	pass
				! 4q		||	    \*	zc1 > ys	fz > 0	pass
				if ( ( ndsx(5) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					! 1q	if pierced  twice	/*	ndsx(5) > as	fx > 0	pass
					! 2q		||				\*	ndsx(5) < as	fx < 0	pass
					! 3q		||				./	ndsx(5) < as	fx < 0	pass
					! 4q		||				.\	ndsx(5) > as	fx > 0	pass
					if( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if inside   /*	zc1 < ys2	fz > 0	pass
						! 2q		||	   	\*	zc1 > ys2	fz < 0	pass
						! 3q		||	   	./	zc1 > ys2	fz < 0	pass
						! 4q		||	   	.\	zc1 < ys2	fz > 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !dom(ib)%p(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q	    always      	\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q	    always      	_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !dom(ib)%p(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  again	*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*\	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !dom(ib)%p(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !dom(ib)%p(is,jjc,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 /
					!
					! 2q	 |.
					!		 /
					!
					!		/
					! 3q	|*
					!
					!		/
                    ! 4q   *|
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !dom(ib)%p(is,jjc,ke) = t2
                    !endif
				endif		
			endif
			!				
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is,jjc,ke) is bellow cn3-cn5 
			if( ( zc1 - ys)*fz .gt. -margin ) then
				if ( ( ndsx(7) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
                    if( ( zc1 - ys2)*fz .lt. margin) then
                        ! debug
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !dom(ib)%p(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !dom(ib)%p(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !dom(ib)%p(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
            	        !dom(ib)%p(is,jjc,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !dom(ib)%p(is,jjc,ke) = t2
                    !endif
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as)*fx .lt. margin) then	! The West face is pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is,jjc,ke) is bellow cn5-cn7 
			if( ( zc1 - ys)*fz .gt. -margin ) then			
				if ( ( ndsx(9) - as)*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(as-ndsx(9))/(ndsx(7)-ndsx(9))
                    if( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !dom(ib)%p(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
                    if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !dom(ib)%p(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !dom(ib)%p(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !dom(ib)%p(is,jjc,ke) = t2
					endif
                else
                    !if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !dom(ib)%p(is,jjc,ke) = t2
                    !endif
				endif
			endif ! zc1
        else ! Face S has not been pierces so far
				!	1q	*|      is = iii-1
				!	2q	 |*     is = iii
				!	3q	 |.     is = iii
				!	4q	.|      is = iii-1
				if ( ( ndsx(2) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as	fx > 0		not	pass
					! 2q		always  		\_	ndsx(2) < as	fx < 0	    not pass
					! 3q		always			/_	ndsx(2) < as	fx < 0		not pass
					! 4q		always  		_\	ndsx(2) > as	fx > 0	    not pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q
						! 2q
						! 3q
                        ! 4q	
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !dom(ib)%p(is,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as)*fx .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as	fx > 0	pass
					! 2q		||				*/	ndsx(4) > as	fx < 0	pass
					! 3q		||				\.	ndsx(4) > as	fx < 0	pass
					! 4q		||				/.	ndsx(4) < as	fx > 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fz > 0	pass
						! 2q		||				*/	zc1 > ys2	fz < 0	pass
						! 3q		||				\.	zc1 > ys2	fz < 0	pass
						! 4q		||				\.	zc1 < ys2	fz > 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !dom(ib)%p(is,jjc,ke) = t2
                    endif
				elseif ( ( ndsx(6) - as)*fx .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                        !dom(ib)%p(is,jjc,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 |
					!
					! 2q	 |.
					!		 |
					!
					!		 |
					! 3q	 |*
					!
					!		 |
                    ! 4q	*|
                    if( (qF.eq.1).or.(qF.eq.3)) then
					call setMirror_p(vec1,ndsx,ndsz,is,ke,as,zc1,t2)
                    !dom(ib)%p(is,jjc,ke) = t2
                    endif
				endif
		endif	 ! ndsx(3)! Finished Check of Face S1 ke
		!endif!12345
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2
		!
		!12345 if(dom(ib)%mpc(is2,jjc,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
		! 1q	if pierced  ./	ndsx(3) < as2	fxq2 > 0	pass
		! 2q		||		./	ndsx(3) < as2	fxq2 > 0	pass
		! 3q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
		! 4q		||		/*	ndsx(3) > as2	fxq2 < 0	pass
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjc,ke) is2 bellow cn3-cn
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				! 1q	if inside   ./	zc1 > ys	fzq2 > 0	pass
				! 2q		||  	./	zc1 > ys	fzq2 > 0	pass
				! 3q		||	    /*	zc1 < ys	fzq2 < 0	pass
				! 4q		||	    /*	zc1 < ys	fzq2 < 0	pass
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					! 1q	if pierced  twice	/*	ndsx(5) > as2	fxq2 > 0	pass
					! 2q		||				/*	ndsx(5) > as2	fxq2 > 0	pass
					! 3q		||				./	ndsx(5) < as2	fxq2 < 0	pass
					! 4q		||				./	ndsx(5) < as2	fxq2 < 0	pass
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if inside   /*	zc1 < ys2	fzq2 > 0	pass
						! 2q		||	   	/*	zc1 < ys2	fzq2 > 0	pass
						! 3q		||	   	./	zc1 > ys2	fzq2 < 0	pass
						! 4q		||	   	./	zc1 > ys2	fzq2 < 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
					! 2q	if pierced  again	*\	ndsx(2) < as2	fxq2 > 0	pass
					! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
					! 4q	if pierced  again	\.	ndsx(2) > as2	fxq2 < 0	pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q
						! 2q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 3q
						! 4q	if pierced  again	\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  again	*\	ndsx(4) < as2	fxq2 > 0	pass
					! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
					! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
						! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
						! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 /
					!
					! 2q	.|
					!		 /
					!
					!		/
					! 3q	|*
					!
					!		/
					! 4q	|*
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                    !dom(ib)%p(is2,jjc,ke) = t2
				endif		
			endif
			!				
			! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is2,jjc,ke) is2 bellow cn3-cn5 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
            	    !dom(ib)%p(is2,jjc,ke) = t2
				endif		
			endif
		!
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjc,ke) is2 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                    !dom(ib)%p(is2,jjc,ke) = t2
				endif				
			endif ! zc1
		else ! Face S has not been pierces so far
				!	1q	*|
				!	2q	*|
				!	3q	|.
				!	4q	|.
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q		always			_/	ndsx(2) > as2	fxq2 > 0		not	pass
					! 2q	if pierced  		*\	ndsx(2) < as2	fxq2 > 0	pass
					! 3q		always			/_	ndsx(2) < as2	fxq2 < 0		not pass
					! 4q	if pierced  		\.	ndsx(2) > as2	fxq2 < 0	pass
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q
						! 2q	if pierced  	*\	zc1 < ys2	fzq2 > 0	pass
						! 3q
						! 4q	if pierced  	\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					! 1q	if pierced  		*\	ndsx(4) < as2	fxq2 > 0	pass
					! 2q		||				*\	ndsx(4) < as2	fxq2 > 0	pass
					! 3q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					! 4q		||				\.	ndsx(4) > as2	fxq2 < 0	pass
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						! 1q	if pierced  again	*\	zc1 < ys2	fzq2 > 0	pass
						! 2q		||				*\	zc1 < ys2	fzq2 > 0	pass
						! 3q		||				\.	zc1 > ys2	fzq2 < 0	pass
						! 4q		||				\.	zc1 > ys2	fzq2 < 0	pass
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !dom(ib)%p(is2,jjc,ke) = t2
                    endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                        !dom(ib)%p(is2,jjc,ke) = t2
					endif
				else	! Face S has not been pierces so far BUT is inside the inmersed body
					! 1q	.|
					!		 |
					!
					! 2q	.|
					!		 |
					!
					!		|
					! 3q	|*
					!
					!		|
					! 4q	|*
					call setMirror_p(vec1,ndsx,ndsz,is2,ke,as2,zc1,t2)
                    !dom(ib)%p(is2,jjc,ke) = t2
				endif
		endif	 ! ndsx(3)! Finis2hed Check of Face S2 ke
		!endif!12345 
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S2 ke2
		!
		!12345 if(dom(ib)%mpc(is2,jjc,ke2).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
		if ( (ndsx(3) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as2- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is2,jjc,ke2) is2 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
		!!! WARNING !!!			
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
		!!! END !!!								
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
			! There  may be an is2sue			
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !dom(ib)%p(is2,jjc,ke2) = t2
				endif		
			endif				
		else	! The the West face has not yet been pierced	
			if ( (ndsx(5) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as2-ndsx(5))/(ndsx(3)-ndsx(5))	
				! case b.2.1.1  Checking if u(is2,jjc,ke2) is2 bellow cn3-cn5 
				if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as2)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
		!!! WARNING !!!			
				elseif ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(1) + (ndsz(2) - ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
		!!! END !!!						
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
			! There  may be an is2sue			
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !dom(ib)%p(is2,jjc,ke2) = t2
				endif		
				endif
		
			else	! The Face S has not been pierced so far	
			if ( (ndsx(7) - as2)*fxq2 .lt. margin) then	! The West face is2 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as2-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is2,jjc,ke2) is2 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
		!!! WARNING !!!			
				if ( ( ndsx(2) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2=ndsz(1)+(ndsz(2)-ndsz(1))*(as2-ndsx(1))/(ndsx(2)-ndsx(1))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
		!!! END !!!	
				elseif ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
		! There  may be an is2sue			
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !dom(ib)%p(is2,jjc,ke2) = t2
				endif				
			endif
			else ! Face S has not been pierces so far
				!!!!!!!!!!!! 
				! fxq2	 1 1	-1 1	-1-1	-1-1
				! 1q */	ndsx(4)	> as2	but if is2 is pierced *\ 	ndsx(4)	< as2	-> 	fxq2 = 1
				! 2q *\						if is2 is pierced *\	ndsx(4)	< as2	-> 	fxq2 = 1
				! 3q /.	ndsx(4)	< as2	but if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				! 4q \.						if is2 is pierced \.	ndsx(4)	> as2	-> 	fxq2 = -1
				!
				!
				! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
				! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
				if ( ( ndsx(4) - as2)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as2-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
                    endif
				elseif ( ( ndsx(6) - as2)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as2-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                        !dom(ib)%p(is2,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is2,ke2,as2,zc2,t2)
                    !dom(ib)%p(is2,jjc,ke2) = t2
		        endif
				!!!!!!!!!!!!
			endif	! ndsx(7)
			endif	! ndsx(5)
		endif	! ndsx(3) ! Finis2hed Check of Face S2 ke2
		!endif!12345 
		!
		!
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke
		!
		!12345 if(dom(ib)%mpc(is3,jjc,ke).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is3,jjc,ke) is3 bellow cn3-cn
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !dom(ib)%p(is3,jjc,ke) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is3,jjc,ke) is3 bellow cn3-cn5 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marker cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !dom(ib)%p(is3,jjc,ke) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is3,jjc,ke) is3 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !dom(ib)%p(is3,jjc,ke) = t2
				endif
			endif
		elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is3,jjc,ke) is3 bellow cn5-cn7 
			if( ( zc1 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc1 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                        !dom(ib)%p(is3,jjc,ke) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !dom(ib)%p(is3,jjc,ke) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc1 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc1 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !dom(ib)%p(is3,jjc,ke) = t2
                endif
			elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !dom(ib)%p(is3,jjc,ke) = t2
				endif
			elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc1 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                    !dom(ib)%p(is3,jjc,ke) = t2
				endif
			else
				call setMirror_p(vec1,ndsx,ndsz,is3,ke,as3,zc1,t2)
                !dom(ib)%p(is3,jjc,ke) = t2
		    endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis3hed Check of Face S3 ke
		!endif!12345 
		!
		!
		!!!!!!!!!!!!!!!!!!
		!!! CHECKING FACE S3 ke2
		!
		!12345 if(dom(ib)%mpc(is3,jjc,ke2).eq.0) then	! checking if this cell has already been flagged
		!if(1) then	! checking if this cell has already been flagged
		if ( (ndsx(3) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys = ndsz(3) + (ndsz(1) - ndsz(3))*(as3- ndsx(3))/(ndsx(1) - ndsx(3))
			! case b.1.1.1  Checking if u(is3,jjc,ke2) is3 bellow cn3-cn
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(5) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !dom(ib)%p(is3,jjc,ke2) = t2
				endif		
			endif				
		! The the West face has not yet been pierced	
		elseif ( (ndsx(5) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME		
			ys=ndsz(5)+(ndsz(3)-ndsz(5))*(as3-ndsx(5))/(ndsx(3)-ndsx(5))	
			! case b.2.1.1  Checking if u(is3,jjc,ke2) is3 bellow cn3-cn5 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then
				if ( ( ndsx(7) - as3)*fxq2 .gt. -margin ) then ! safety check in case marke2r cn3 pierces the West face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !dom(ib)%p(is3,jjc,ke2) = t2
				endif		
			endif
		! The Face S has not been pierced so far	
		elseif ( (ndsx(7) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(7)+(ndsz(5)-ndsz(7))*(as3-ndsx(7))/(ndsx(5)-ndsx(7))
			! case b.2.1.1  Checking if u(is3,jjc,ke2) is3 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !dom(ib)%p(is3,jjc,ke2) = t2
				endif
			endif
		elseif ( (ndsx(9) - as3)*fxq2 .lt. margin) then	! The West face is3 pierced for the FIRST TIME
			ys=ndsz(9)+(ndsz(7)-ndsz(9))*(as3-ndsx(9))/(ndsx(7)-ndsx(9))
			! case b.2.1.1  Checking if u(is3,jjc,ke2) is3 bellow cn5-cn7 
			if( ( zc2 - ys)*fzq2 .gt. -margin ) then			
				if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
					ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
					ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
					if ( ( zc2 - ys2)*fzq2 .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                        !dom(ib)%p(is3,jjc,ke2) = t2
					endif
				else
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !dom(ib)%p(is3,jjc,ke2) = t2
				endif
			endif
		else ! Face S has not been pierces so far
			!!!!!!!!!!!! 
			! fxq2	 1 1	-1 1	-1-1	-1-1
			! 1q */	ndsx(4)	> as3	but if is3 is pierced *\ 	ndsx(4)	< as3	-> 	fxq2 = 1
			! 2q *\						if is3 is pierced *\	ndsx(4)	< as3	-> 	fxq2 = 1
			! 3q /.	ndsx(4)	< as3	but if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			! 4q \.						if is3 is pierced \.	ndsx(4)	> as3	-> 	fxq2 = -1
			!
			!
			! 1q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 2q 	if pierced *\		 ys2 	> zc2 -	-> 	fzq2 = 1
			! 3q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			! 4q 	if pierced \. 		 ys2 	< zc2 -	-> 	fzq2 = -1
			if ( ( ndsx(4) - as3)*fxq2 .lt. margin) then	! safety check  in case cn4 pierced the West face too
				ys2 = ndsz(2) + (ndsz(4) - ndsz(2))*(as3-ndsx(2))/(ndsx(4)-ndsx(2))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !dom(ib)%p(is3,jjc,ke2) = t2
                endif
			elseif ( ( ndsx(6) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(4) + (ndsz(6) - ndsz(4))*(as3-ndsx(4))/(ndsx(6)-ndsx(4))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !dom(ib)%p(is3,jjc,ke2) = t2
				endif
			elseif ( ( ndsx(8) - as3)*fxq2 .lt. margin) then	! safety check  in case cn6 pierced the West face too
				ys2 = ndsz(6) + (ndsz(8) - ndsz(6))*(as3-ndsx(6))/(ndsx(8)-ndsx(6))
				if ( ( zc2 - ys2)*fzq2 .lt. margin) then
					call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                    !dom(ib)%p(is3,jjc,ke2) = t2
				endif
			else
				call setMirror_p(vec1,ndsx,ndsz,is3,ke2,as3,zc2,t2)
                !dom(ib)%p(is3,jjc,ke2) = t2
		    endif
			!!!!!!!!!!!!
		endif	! ndsx(3) ! Finis3hed Check of Face S3 ke2
		!endif!12345 
		!
		!
		!!!!!!!!!!!!!!!!!
		!! CHECKING FACE SE ke4
		!
		!12345 if(dom(ib)%mpc(ie,jjc,ke4).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
		!	fx,fz					1 1		-1 -1	-1 -1	1 1
		!   fxk4,fzk4				1		-1		-1		1
		if (flagA .eq. 1) then
			!flag2 = 0
			! 1q	ae = dom(ib)%x(iii)		if pierced once		*/
			! 2q	ae = dom(ib)%x(iii-1) 	if pierced once		*\
			! 3q	ae = dom(ib)%x(iii-1) 	if pierced once		/.
			! 4q	ae = dom(ib)%x(iii)		if pierced once		\.
			if ( ( ndsx(4) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(4) > ae	fx > 0	pass
				! 2q		||				\.	ndsx(4) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(4) < ae	fx < 0	pass
				! 2q		||				*\	ndsx(4) > ae	fx > 0	pass
				!
				ys = ndsz(2) + (ndsz(4)-ndsz(2))*(ae-ndsx(2))/(ndsx(4)-ndsx(2))
				!
				! case a.1.1.2	 Checking if u(ie,jjc,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif		
				endif
			elseif ( ( ndsx(6) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(6) > ae	fx > 0	pass
				! 4q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 4q		||				*\	ndsx(6) > ae	fx > 0	pass
				!
				ys = ndsz(4) + (ndsz(6)-ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
				!
				! case a.1.1.2	 Checking if u(ie,jjc,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif		
				endif
			else
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
					! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
					! 2q		||				./	ndsx(3) < ae	fx < 0	pass
					! 3q		||				./	ndsx(3) < ae	fx < 0	pass
					! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc4 - ys2)*fz .lt. margin) then
						! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
						! 2q		||				./	ys2 < zc4	fx < 0	pass
						! 3q		||				./	ys2 < zc4	fx < 0	pass
						! 4q		||				/*	ys2 > zc4	fx > 0	pass
						!flag2 = 1
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif
				else
				! setting mirror value
					call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
					!dom(ib)%p(ie,jjc,ke4) = t2
				endif
			endif
		endif
		!endif!12345
		!
		!
		!
		!12345 if(dom(ib)%mpc(ie,jjc,ke4).eq.0) then	! checking if this cell has already been flagged
			!if(1) then	! checking if this cell has already been flagged
		!	fx,fz					1 1		-1 -1	-1 -1	1 1
		!   fxk4,fzk4				1		-1		-1		1
		if (flagB .eq. 1) then
			!flag2 = 0
			! 1q	ae = dom(ib)%x(iii)		if pierced once		*/
			! 2q	ae = dom(ib)%x(iii-1) 	if pierced once		*\
			! 3q	ae = dom(ib)%x(iii-1) 	if pierced once		/.
			! 4q	ae = dom(ib)%x(iii)		if pierced once		\.
			if ( ( ndsx(6) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(6) > ae	fx > 0	pass
				! 4q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(6) < ae	fx < 0	pass
				! 4q		||				*\	ndsx(6) > ae	fx > 0	pass
				!
				ys = ndsz(4) + (ndsz(6)-ndsz(4))*(ae-ndsx(4))/(ndsx(6)-ndsx(4))
				!
				! case a.1.1.2	 Checking if u(ie,jjc,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif		
				endif
			elseif ( ( ndsx(8) - ae )*fx .lt. margin ) then	! The East face is pierced again
				! 1q	if pierced  twice	*\	ndsx(8) > ae	fx > 0	pass
				! 6q		||				\.	ndsx(8) < ae	fx < 0	pass
				! 3q		||				\.	ndsx(8) < ae	fx < 0	pass
				! 6q		||				*\	ndsx(8) > ae	fx > 0	pass
				!
				ys = ndsz(6) + (ndsz(8)-ndsz(6))*(ae-ndsx(6))/(ndsx(8)-ndsx(6))
				!
				! case a.1.1.2	 Checking if u(ie,jjc,ke4) is above cn-cn2
				if( ( zc4 - ys)*fz .lt. -margin ) then
					! 1q	if pierced  twice	*\	ys > zc4	fx > 0	pass
					! 2q		||				\.	ys < zc4	fx < 0	pass
					! 3q		||				\.	ys < zc4	fx < 0	pass
					! 4q		||				*\	ys > zc4	fx > 0	pass
					if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
						! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
						! 2q		||				./	ndsx(3) < ae	fx < 0	pass
						! 3q		||				./	ndsx(3) < ae	fx < 0	pass
						! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
						ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
						if( ( zc4 - ys2)*fz .lt. margin) then
							! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
							! 2q		||				./	ys2 < zc4	fx < 0	pass
							! 3q		||				./	ys2 < zc4	fx < 0	pass
							! 4q		||				/*	ys2 > zc4	fx > 0	pass
							!flag2 = 1
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
						ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
						if( ( zc4 - ys2)*fz .lt. margin) then
							call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
							!dom(ib)%p(ie,jjc,ke4) = t2
						endif
					else
					! setting mirror value
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif		
				endif
			else
				if ( ( ndsx(3) - ae )*fx .gt. -margin ) then ! safety check in case marker cn1 pierces the East face too
					! 1q	if pierced  		/*	ndsx(3) > ae	fx > 0	pass
					! 2q		||				./	ndsx(3) < ae	fx < 0	pass
					! 3q		||				./	ndsx(3) < ae	fx < 0	pass
					! 4q		||				/*	ndsx(3) > ae	fx > 0	pass
					ys2 = ndsz(3) + (ndsz(1)-ndsz(3))*(ae-ndsx(3))/(ndsx(1)-ndsx(3))
					if( ( zc4 - ys2)*fz .lt. margin) then
						! 1q	if pierced  		/*	ys2 > zc4	fx > 0	pass
						! 2q		||				./	ys2 < zc4	fx < 0	pass
						! 3q		||				./	ys2 < zc4	fx < 0	pass
						! 4q		||				/*	ys2 > zc4	fx > 0	pass
						!flag2 = 1
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(5) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(5) + (ndsz(3)-ndsz(5))*(ae-ndsx(5))/(ndsx(3)-ndsx(5))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(7) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(7) + (ndsz(5)-ndsz(7))*(ae-ndsx(7))/(ndsx(5)-ndsx(7))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif
				elseif ( ( ndsx(9) - ae )*fx .gt. -margin ) then ! safety check in case marker cn3 pierces the East face too
					ys2 = ndsz(9) + (ndsz(7)-ndsz(9))*(ae-ndsx(9))/(ndsx(7)-ndsx(9))
					if( ( zc4 - ys2)*fz .lt. margin) then
						call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
						!dom(ib)%p(ie,jjc,ke4) = t2
					endif
				else
				! setting mirror value
					call setMirror_p(vec1,ndsx,ndsz,ie,ke4,ae,zc4,t2)
					!dom(ib)%p(ie,jjc,ke4) = t2
				endif
			endif
		endif
		!endif!12345
		!
		!
		!
		endif
		!
		endif

!######################################################################
	END SUBROUTINE setQuadrant_p
!######################################################################	 

!######################################################################
	SUBROUTINE setMirror_p(vec1,ndsx,ndsz,iq,kq,xq,zq,k)
!######################################################################

				use imb
				use mpi
				use multidata
				use vars

				implicit none

				! temporal variables
				DOUBLE PRECISION:: temp

				! Input valriables
				INTEGER, INTENT(IN):: vec1(7) !vec1(9)
				DOUBLE PRECISION, INTENT(IN):: ndsx(11), ndsz(11)
				! Location of cell face center of ghost cell 
				INTEGER, INTENT(IN):: iq, kq
				DOUBLE PRECISION, INTENT(IN):: xq, zq
				DOUBLE PRECISION:: yq
				! Output variables
				DOUBLE PRECISION, INTENT(OUT):: k

				! Interfaces
				INTEGER:: nn, ib, ll, iic, jjc, kkc
				DOUBLE PRECISION:: origin_x, origin_y, origin_z
				DOUBLE PRECISION:: origin_xc, origin_yc, origin_zc
				DOUBLE PRECISION:: dx_l, dy_l, dz_l
				! Search loop index
				INTEGER:: dd, bb, cc
				! Location of the nearest marker
				DOUBLE PRECISION:: mkx, mkz, mkx2, mkz2, mkx3, mkz3
				! Distances between ghost cell and markers
				DOUBLE PRECISION:: rad1, rad2, radAux
				! Angle of the closts markers to the ghost cell
				DOUBLE PRECISION:: cosTetha1, sinTetha1
				DOUBLE PRECISION:: cosAlpha1, cosAlpha2, tanBetha1
				DOUBLE PRECISION:: alpha1, alpha2, betha1, tetha1
				! Location of mirror point
				DOUBLE PRECISION:: mrx, mry, mrz
				! Indeces of mirror cell centre
				INTEGER:: id,jd, kd
				! mirror pressure
				INTEGER:: ii, jj
				DOUBLE PRECISION:: mirror_p
				DOUBLE PRECISION:: nx(2),nz(2),pvec(4)
				DOUBLE PRECISION:: dx1, dx2, dz1, dz2
				DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
				DOUBLE PRECISION:: b1(4), b2(3), sol(3), ab(4,3)
				DOUBLE PRECISION:: x1, x2, z1, z2
				DOUBLE PRECISION:: q11, q21, q12, q22, qxz

				! Flags
				INTEGER:: flag90, flag1, flag2, qF

				! safety variables
				DOUBLE PRECISION:: margin				


				! writing warnings
				integer:: sn
				character*8 :: chb1
				character*35 :: gf ! file name


		!		if (myrank.eq. master ) then ! The control is passed down to the master processor

				nn = vec1(1)
				ib = vec1(2)
				ll = vec1(3)
				iic = vec1(4)
				jjc = vec1(5)
				kkc = vec1(6)
				qF = vec1(7) ! this is defined in a finction later

				if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
					IF(imb_block_loc(nn).eq.dom_id(ib)) then

				!origin_xc = vec1(8)
				!origin_yc = vec1(9)
				!origin_zc = vec1(10)

				mirror_p = 0.0d00;
				origin_x = 0.0d00; origin_y = 0.0d00; origin_z = 0.0d00
				origin_xc = 0.0d00; origin_yc = 0.0d00; origin_zc = 0.0d00

				! Filter for testing
			!	if(qF.eq.1) then
				! if( (qF.eq.1 ).and.(ll.lt.2) ) then
			!	if( (ll.lt.2).and.((qF.eq.1).or.(qF.eq.2)) ) then
			!	if( (ll.lt.2) ) then !.and.((qF.eq.1).or.(qF.eq.2)) ) then
				if( (ll.lt.2).and.(qF.lt.5) ) then
			!	if( (nn.gt.0).and.(nn .lt. 1321) ) then

				flag90 = 0
				margin = 1.0e-5

				!!! Search loop for closest markers to the velocity cell centre
				mkx = ndsx(1)
				mkz = ndsz(1)
				mkx2 = ndsx(2)
				mkz2 = ndsz(2)
				dd = 2
				bb = dd - 1
				cc = dd

				rad1 = (mkx-xq)**2 + (mkz-zq)**2
				rad2 = (mkx2-xq)**2 + (mkz2-zq)**2

				mkx3 = ndsx(3)
				mkz3 = ndsz(3)
				radAux = (mkx3-xq)**2 + (mkz3-zq)**2
				if (radAux .lt. rad2) then
					mkx2 = mkx
					mkz2 = mkz
					mkx  = mkx3
					mkz  = mkz3
					rad2 = rad1
					rad1 = radAux

					bb = dd + 1
					cc = dd - 1
				endif

				
				do dd = 4, 10, 2

					mkx3 = ndsx(dd)
					mkz3 = ndsz(dd)					
					radAux = (mkx3-xq)**2 + (mkz3-zq)**2										

					if (radAux .lt. rad1) then
						mkx  = mkx2
						mkz  = mkz2
						mkx2 = mkx3
						mkz2 = mkz3						
						rad1 = rad2
						rad2 = radAux
						bb = dd - 2
						cc = dd
					else
						mkx3 = ndsx(dd+1)
						mkz3 = ndsz(dd+1)
						radAux = (mkx3-xq)**2 + (mkz3-zq)**2
						if (radAux .lt. rad2) then
							mkx2 = mkx
							mkz2 = mkz
							mkx  = mkx3
							mkz  = mkz3							
							rad2 = rad1
							rad1 = radAux
							bb = dd + 1
							cc = dd - 1
						endif
					endif
				enddo

				rad1 = sqrt(rad1)
				rad2 = sqrt(rad2)
				

				cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) ! alpha1: angle between U cell centre and segment mk1-mk2
				cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) ! alpha2: angle between U cell centre and segment mk2-mk1
				alpha1 = DACOS(cosAlpha1)*180/piNUm
				alpha2 = DACOS(cosAlpha2)*180/piNum
				! If there is a normal from the velocity cell centre to the surface (segment mk1-mk2) alpha1 < 90 and alpha2 < 90


				tanBetha1 = (mkz2-mkz)/(mkx2-mkx)
				betha1 = abs(DATAN(tanBetha1))*180/piNUm	! lets make betha1



				if( (nn.gt.0).and.(nn.lt.127) ) then
				if (alpha1 .gt. 90) then
					flag90 = 1
					write(6,*) "Warning in mirror_p subroutine!", nn
					write(6,*) "alpha1 greater thant 90: ", alpha1
					write(6,*) ""
					! Update bb and cc
					if (bb .eq. 2) then
						! bb = 2		cc = 4
						bb = bb - 1
						cc = cc - 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb - 2
						cc = cc - 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb + 2
						cc = cc + 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNum

				
				elseif (alpha2 .gt. 90) then
					flag90 = 1
					write(6,*) "Warning in mirror_p subroutine!", nn
					write(6,*) "Warning: alpha2 greater thant 90: ", alpha2
					write(6,*) ""
					! Update bb and redefine the nodes
					if (bb .eq. 1) then
						! bb = 1		cc = 2
						bb = bb + 1
						cc = cc + 2
					elseif( (-1)**bb .gt. margin ) then
						! example: bb = 4		cc = 6
						bb = bb + 2
						cc = cc + 2
					elseif( (-1)**bb .lt. margin ) then
						! example: bb = 5		cc = 3
						bb = bb - 2
						cc = cc - 2
					endif

					! redifining node locations
					mkx = ndsx(bb)
					mkz = ndsz(bb)
					mkx2 = ndsx(cc)
					mkz2 = ndsz(cc)

					rad1 = sqrt( (mkx-xq)**2 + (mkz-zq)**2 )
					rad2 = sqrt( (mkx2-xq)**2 + (mkz2-zq)**2 )
					cosAlpha1 = cosAngle(mkx,mkz,xq,zq,mkx2,mkz2,rad1) 
					cosAlpha2 = cosAngle(mkx2,mkz2,xq,zq,mkx,mkz,rad2) 
					alpha1 = DACOS(cosAlpha1)*180/piNUm
					alpha2 = DACOS(cosAlpha2)*180/piNum				
				endif
				endif

				if (flag90) then
					write(chb1,'(i6)') nn
					sn=len(trim(adjustl(chb1)))
					gf='w_p_m_alpha'//repeat('0',(6-sn))//trim(adjustl(chb1))
					OPEN(unit = 906, access = "sequential", action = "write",
     &   status = "replace", file = gf, form = "formatted") 

					!	write(6,*) "*** Index, Qudarant ***"
						write(906,*) nn, qF
						write(906,*) ndsx
						write(906,*) ndsz
						write(906,*) iic, kkc, jjc	
						write(906,*) iq, kq
						write(906,*) alpha1, alpha2
						!write(6,*) betha1, tetha1
					! location of P pressure cell centre
						write(906,*) xq, zq
					! location of closest markers
						write(906,*) mkx, mkz
						write(906,*) mkx2, mkz2
						write(906,*) bb, cc		
						write(906,*) ndsx(bb), ndsz(bb)
						write(906,*) ndsx(cc), ndsz(cc)
						!write(6,*) mrx, mrz		
						write(906,*) id, kd
						write(906,*) "==="
						close(906)
					endif
					!
					!
				! redefining quadrant of the neighbouring markers
				qF = quadrant(ndsx(bb), ndsz(bb),ndsx(cc), ndsz(cc),margin)
				!
				!
				dx_l = dom(ib)%dx
				dy_l = dom(ib)%dy
				dz_l = dom(ib)%dz
				!
				origin_xc = dom(ib)%xc(1)
				origin_yc = dom(ib)%yc(1)
				origin_zc = dom(ib)%zc(1) 
				!
				!
				!
			if (qF.eq.1) then
				!
				tetha1 = alpha1 - betha1 
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point will always be forward of marker1
				mrx = mkx + rad1*cosTetha1
				! mry = ???
				! The mirror point may be above marker1 if betha1 > alpha1
				mrz = mkz - rad1*sinTetha1

			elseif(qF.eq.2) then

				tetha1 =   alpha1 - (90 - betha1) 
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point may be behind maker1 if alpha1 < (90 - betha1)
				mrx = mkx + rad1*sinTetha1

				! mry = ???
				
				! The mirror point will alpway be above marker1
				mrz = mkz + rad1*cosTetha1

			elseif(qF.eq.3) then

				tetha1 = betha1 - alpha1
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! The mirror point will always be behind marker 1
				mrx = mkx - rad1*cosTetha1
				
				! mry = ???
				
				! The mirror point may be above marker 1 if alpha1 > betha1
				mrz = mkz - rad1*sinTetha1

			elseif(qF.eq.4) then

				tetha1 = 90 - betha1 - alpha1
				cosTetha1 = DCOS(tetha1*piNUm/180)
				sinTetha1 = DSIN(tetha1*piNUm/180)

				! mirror point may be behind or forward of marker 1 if alpha1 > (90 - betha1)
				mrx = mkx + rad1*sinTetha1
				
				! mry = ???

				! mirror point will alway be bellow marker 1
				mrz = mkz - rad1*cosTetha1

			endif

			! Inidices of the mirror u cell
			id = int ( ( mrx - origin_xc - margin) /dx_l) + 2 
			!jd = int ( ( mry - origin_yc - margin) /dy_l) + 2
			!if (jd.eq.jjc) then
			!else
			!	write(6,*) "Warning jd is not jjc"
			!endif
			kd = int ( ( mrz - origin_zc - margin) /dz_l) + 2


                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				!!! BILINEAR INTERPOLATION

			pvec(1) = dom(ib)%pcpy(id-1,jjc,kd-1) ! q11
			pvec(2) = dom(ib)%pcpy(id,jjc,kd-1)   ! q21
			pvec(3) = dom(ib)%pcpy(id-1,jjc,kd)   ! q12
			pvec(4) = dom(ib)%pcpy(id,jjc,kd)	   ! q22
			!
			nx(1) = dom(ib)%xc(id-1)		! CHECK_AAA
			nx(2) = dom(ib)%xc(id)		! CHECK_AAA
			nz(1) = dom(ib)%zc(kd-1)
			nz(2) = dom(ib)%zc(kd)

		!	mirror_p = bilinear1(nn,nx,nz,pvec,mrx,mrz)
		!	if(nn.eq.126) then
		!		write(6,*) "Mirror p (Bilinear Interpolation: explicit)",mirror_p
		!	endif


			! Alternative (2nd order Least Squares & Cramer's solver)
			!mirror_p = ls_2ndOrder_cramer(nn,nx,nz,pvec,mrx,mrz)
			!if ( nn.eq.70 ) then
			! write(6,*) "Mirror p (2nd order Least Squares: cramer)",nn,mirror_p
			!endif



			!!! LINEAR INTERPOLATION
			!mirror_p = l1(nn,nx,nz,pvec,mrx,mrz)
			!if(nn.eq.70) then
			!	write(6,*) "Mirror p (linear interpolation)", nn, mirror_p
			!endif

			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Alternative (Least Squares & Cramer's solver)
			!mirror_p = ls_cramer(nn,nx,nz,pvec,mrx,mrz)
			!if ( nn.eq.70 ) then
			! write(6,*) "Mirror p (Least Squares: cramer)", nn, mirror_p
			!endif

			! Alternative: Bilinear Interpoaltion and Cramers solver
			mirror_p = bl_cramer(nn,nx,nz,pvec,mrx,mrz)
			!if ( nn.eq.70 ) then
			! write(6,*) "Mirror p (Bilinear Interpolation: cramer)", nn, mirror_p
			!endif
			!
			!
			! lets flag this cell as a body cell
			dom(ib)%mpc(iq,jjc,kq) = qF
			!
			! Lets add the necesary information
			yq = dom(ib)%yc(jjc) ! dom(ib)%yc(jjj)
			dom(ib)%mpcnn(iq,jjc,kq) = nn  ! nn for p ghost cells
			dom(ib)%mpcib(iq,jjc,kq) = ib  ! ib for p ghost cells
			dom(ib)%mpcll(iq,jjc,kq) = ll  ! ll for p ghost cells
			dom(ib)%mpci(iq, jjc,kq)  = iq  ! %x  id for p ghost cells centre
			dom(ib)%mpcj(iq, jjc,kq)  = jjc ! %yc id for p ghost cells centre
			dom(ib)%mpck(iq, jjc,kq)  = kq  ! %z  id for p ghost cells centre
			dom(ib)%mpcx(iq, jjc,kq)  = xq  ! %x  for p ghost cells centre
			dom(ib)%mpcy(iq, jjc,kq)  = yq  ! %yc for p ghost cells centre
			dom(ib)%mpcz(iq, jjc,kq)  = zq  ! %z  for p ghost cells centre
			dom(ib)%mpcmi(iq,jjc,kq) = id  ! %x  id for p mirror point in fluid cells
			dom(ib)%mpcmj(iq,jjc,kq) = jjc ! %yc id for p mirror point in fluid cells
			dom(ib)%mpcmk(iq,jjc,kq) = kd  ! %z  id for p mirror point in fluid cells
			dom(ib)%mpcmx(iq,jjc,kq) = mrx ! %x  for p mirror point in fluid cells
			dom(ib)%mpcmy(iq,jjc,kq) = yq  ! %yc for p mirror point in fluid cells
			dom(ib)%mpcmz(iq,jjc,kq) = mrz ! %z  for p mirror point in fluid cells
			!
			k = mirror_p
			!k = 0.0d00	
			!
			!debug
	!		if((nn.gt.9240).and.(nn.lt.(9240+126))) then
	!		!	write(6,*) nn, k ,rott_loc(nn)
	!			write(6,*) nn, k, dom(ib)%mpcold(iq,jjc,kq), "P"
	!		!write(6,*) qF, fieldF, fieldVal
	!		!write(6,*) vec2(1),vec2(2),vec2(3)
	!		!write(6,*) vec2(4),vec2(5),vec2(6)
	!		!write(6,*) vec2(7),vec2(8)
	!		!write(6,*) vec3(1),vec3(2),vec3(3)
	!		!write(6,*) "======================="
	!		endif
			!
		! ! check mirror point for u	
		!	if ( (nn.gt.0).and.(nn.lt.127) ) then
		!		uz1 = abs(0.5d00 - sqrt( (18.00d00-xq)**2 + (10.50d00-zq)**2 ))
		!		uz2 = abs(sqrt( (18.0d00-mrx)**2 + (10.5d00-mrz)**2 ) - 0.5d00)
		!		uz1 = abs(uz1-uz2)
		!	!	write(6,*) nn, iq, kq
		!		write(6,*) nn, uz1
		!	!	write(6,*) alpha1, alpha2
		!	!	write(6,*) betha1, tetha1
		!	endif


			else

				k = 0.0d00
				dom(ib)%mpc(iq,jjc,kq) = qF
				dom(ib)%mpcnn(iq,jjc,kq) = nn  ! nn for p ghost cells
				dom(ib)%mpcib(iq,jjc,kq) = ib  ! ib for p ghost cells
				dom(ib)%mpcll(iq,jjc,kq) = ll  ! ll for p ghost cells
				dom(ib)%mpci(iq, jjc,kq)  = iq  ! %x  id for p ghost cells
				dom(ib)%mpcj(iq, jjc,kq)  = jjc ! %yc id for p ghost cells
				dom(ib)%mpck(iq, jjc,kq)  = kq  ! %z  id for p ghost cells
				dom(ib)%mpcx(iq, jjc,kq)  = xq  ! %x  for p ghost cells
				dom(ib)%mpcy(iq, jjc,kq)  = yq  ! %yc for p ghost cells
				dom(ib)%mpcz(iq, jjc,kq)  = zq  ! %z  for p ghost cells
				dom(ib)%mpcmi(iq,jjc,kq) = 0  ! %x  id for p mirror cells
				dom(ib)%mpcmj(iq,jjc,kq) = 0 ! %yc id for p mirror cells
				dom(ib)%mpcmk(iq,jjc,kq) = 0  ! %z  id for p mirror cells
				dom(ib)%mpcmx(iq,jjc,kq) = 0.0d00 ! %x  for p mirror cells
				dom(ib)%mpcmy(iq,jjc,kq) = 0.0d00  ! %yc for p mirror cells
				dom(ib)%mpcmz(iq,jjc,kq) = 0.0d00 ! %z  for p mirror cells

			endif

			!!! END PROCESOR HANDLING SUBDOMAIN IB
			endif

			endif

			CONTAINS


			!######################################################################
			DOUBLE PRECISION FUNCTION bilinear1(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
			DOUBLE PRECISION:: factor1
			
			! Bilinear Interpolation (explicit formulation)
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			
			factor1 = 1.0d00/( (x2-x1)*(z2-z1) )
							
			m1(1) = x2 - mrx
			m1(2) = mrx - x1
			
			m2(1,1) = q11	! First row, 1st column
			m2(2,1) = q12	! 1 st row, 2 nd column
			m2(1,2) = q21	! 2 nd row,	1 st column
			m2(2,2) = q22	! 2 nd row, 2 nd column
			
			m3(1) = z2 - mrz
			m3(2) = mrz - z1
			
			m4 = matmul(m1,m2)
			
			bilinear1 = factor1*dot_product(m3,m4)
			
			!######################################################################
			END FUNCTION bilinear1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_cramer(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			
			
			q11 = pvec(1) !dom(ib)%u(id-1,jjc,kd-1)
			q21 = pvec(2) !dom(ib)%u(id,jjc,kd-1)
			q12 = pvec(3) !dom(ib)%u(id-1,jjc,kd)
			q22 = pvec(4) !dom(ib)%u(id,jjc,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = dx1*dx1; a1(5,1) = dz1*dz1; a1(6,1) = dx1*dz1

			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = dx2*dx2; a1(5,2) = dz1*dz1; a1(6,2) = dx2*dz1

			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = dx1*dx1; a1(5,3) = dz2*dz2; a1(6,3) = dx1*dz2

			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = dx2*dx2; a1(5,4) = dz2*dz2; a1(6,4) = dx2*dz2

			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,6)
			
			ls_2ndOrder_cramer = sol(1)
			
			!######################################################################
			END FUNCTION ls_2ndOrder_cramer
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION l1(nn,nx,nz,pvec,mrx,mrz)
			!######################################################################

			implicit none

			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),pvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			DOUBLE PRECISION:: ux1,uz1,ux2,uz2
			DOUBLE PRECISION:: x1,z1,x2,z2
			DOUBLE PRECISION:: mirror_px1, mirror_px2 
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!! LINEAR INTERPOLATION
				! mirror velocity for x = mrx and z = zc(kd) = z1
			!	ux1 = dom(ib)%u(id,jjc,kd)
			!	ux2 = dom(ib)%u(id+1,jjc,kd)
			!	x1 = dom(ib)%x(id)
			!	x2 = dom(ib)%x(id+1)

				! Alternative
			ux1 = pvec(1)	!dom(ib)%u(id,jjc,kd)
			ux2 = pvec(2) 	!dom(ib)%u(id-1,jjc,kd)
			x1 = nx(1) 	!dom(ib)%x(id)
			x2 = nx(2)	!dom(ib)%x(id-1)
			
			mirror_px1 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = zc(kd-1) = z2				
			!ux1 = dom(ib)%u(id,jjc,kd-1)
			!ux2 = dom(ib)%u(id+1,jjc,kd-1)

			! Alternative
			ux1 = pvec(3)	!dom(ib)%u(id,jjc,kd-1)
			ux2 = pvec(4)	!dom(ib)%u(id-1,jjc,kd-1)

			mirror_px2 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = mrz
			uz1 = mirror_px1
			uz2 = mirror_px2
			z1 = nz(1)	!dom(ib)%zc(kd)
			z2 = nz(2)	!dom(ib)%zc(kd-1)

			l1 = uz1 + (uz2-uz1)*(mrz-z1)/(z2-z1)

			!######################################################################
			END FUNCTION l1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION cosAngle(x1,z1,x2,z2,x3,z3,l12)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: x1,z1,x2,z2,x3,z3,l12
			DOUBLE PRECISION:: x12,z12, x13, l13, z13

			x12 = x2-x1
			z12 = z2-z1
			x13 = x3-x1
			z13 = z3-z1
			l13 = sqrt(x13**2+z13**2)

			cosAngle = (x12*x13 + z12*z13)/(l12*l13)


			!######################################################################
			END FUNCTION cosAngle
			!######################################################################


			!######################################################################
			INTEGER FUNCTION quadrant(cnx,cnz,cnx2,cnz2,margin)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: cnx,cnz,cnx2,cnz2, margin
			INTEGER:: qFlag

										! ( 0, 90 ] First quadrant?
			if ( (cnx2 - cnx) .gt. -margin) then
			if ( (cnz2 - cnz) .gt. margin) then	! Proper way

				qFlag = 1			

			endif
			endif


			! ( 90, 180 ] 2nd quadrant?
			if ( (cnx2 - cnx) .le. -margin) then
			if ( (cnz2 - cnz) .ge. -margin) then

				qFlag = 2

			! End 2nd Quadrant ops
			endif
			endif


			! ( 180, 270 ] 3rd quadrant?
			if ( (cnx2 - cnx) .le. margin) then
			if ( (cnz2 - cnz) .lt. -margin) then

				qFlag = 3

			endif
			endif

			! ( 270, 360 ] 4th quadrant?
			if ( (cnx2 - cnx) .gt. margin) then
			if ( (cnz2 - cnz) .le. margin) then

				qFlag = 4


			endif
			endif		

			quadrant = qFlag

			!######################################################################
			END FUNCTION quadrant
			!######################################################################






!######################################################################		
			END SUBROUTINE setMirror_p
!######################################################################	 	

!######################################################################	
			subroutine gauss_seidel_solver(ab,n,x)
!######################################################################	

			integer, intent(in):: n 
			DOUBLE PRECISION,dimension(n,n+1),intent(in):: ab
			DOUBLE PRECISION,dimension(n,n+1):: aib
			DOUBLE PRECISION,intent(out),dimension(n,1)::x
			DOUBLE PRECISION::t1
			DOUBLE PRECISION, dimension(1)::t3	! Matrix diagonal

			integer:: ii,jj,kk

			aib = ab

			! Visual checking
			!print*
			!print*, "Matrix AiB is: "
			!call print_matrix2D(aib,n,n+1)


			loop1 : do ii = 1,n-1	! Sweeping matrix a diagomal

				loop2 : do jj = ii+1,n	! sweeping rows

					t1 = aib(jj,ii)

					loop3 : do kk = ii,n+1	! Sweeping columns

						aib(jj,kk) = aib(jj,kk) - aib(ii,kk)*t1/aib(ii,ii)

						! Visual checking
						!print*
						!print*, "Matrix AiB is: "
						!call print_matrix2D(aib,n,n+1)

					end do loop3
				
					! Visual checking
					!print*
					!print*, "Matrix AiB is: "
					!call print_matrix2D(aib,n,n+1)

				end do loop2 

			end do loop1

			!print*
			!print*, "Matrix AiB is: "
			!call print_matrix2D(aib,n,n+1)


			! Lets compute the solution
			do ii = n, 1, -1

				t3 = matmul(aib(ii,1:n),x) ! this matrix multiplication returns a 1d matrix

				x(ii,1) = ( aib(ii,n+1) - t3(1) ) / aib(ii,ii)

			end do

			!print*
			!print*
			!Print*,"Visual checking"
			!print*
			!print*, "Solution vector x is: "
			!call print_matrix1D(x,n)


!######################################################################	
			end subroutine gauss_seidel_solver
!######################################################################	


!######################################################################
			subroutine slice_f(sl,matrix,n,row,col)
!######################################################################
                
            	! subroutine for extracting a submatrix when calculating matrix determinants

            	implicit none
            	integer,intent(in)::n,row,col
            	DOUBLE PRECISION,dimension(n,n),intent(in)::matrix
            	DOUBLE PRECISION,dimension(n-1,n-1),intent(out)::sl	! submatrix
            	logical,dimension(n,n)::mask ! marker

            	mask = .true.
            	mask(row,:) = .false.
            	mask(:,col) = .false.

            	sl = reshape(pack(matrix,mask),(/n-1,n-1/))
!######################################################################
        	end subroutine slice_f
!######################################################################
                
!######################################################################
            subroutine cramer_solver(x,a,b,n)
!######################################################################
                
	! Subroutine to solve a system of linear equations using Cramer's rule
				
	implicit none
				
	integer, intent(in):: n
	DOUBLE PRECISION,intent(in),dimension(n,n):: a ! a contains n+1 matrices
	DOUBLE PRECISION,intent(in),dimension(n):: b
	DOUBLE PRECISION,intent(out),dimension(n,1):: x	
	DOUBLE PRECISION,dimension(n,n,n+1):: a2 ! a contains n+1 matrices
	DOUBLE PRECISION:: det_a1 ! determinant ofthe 1st matrix, the matrix a that containing coeffcients
	integer:: ii

	! FUNCTION Declaration
	!DOUBLE PRECISION,external::det_f
	det_a1 = det_f(a(:,:),n) ! determinant ofthe 1st matrix, the matrix a that containing coeffcients
	if(det_a1.lt.1.00e-5) then
	!	write(6,*) "Warning: Cramer Determinant close to zero"
	endif

	x = 0.0d00
	loop1: do ii = 1,n
		a2(:,:,ii+1) = a(:,:) ! the (ii+1)th matrix is assigned the 1st matrix, the matrix a that containing coeffcients
		a2(:,ii,ii+1) = b ! we replace with column vector b the column of the current (ii+1)th matrix
	!! we apply crammers rule: we divide the determinat of the (ii+1)th matrix by the determinant of the 1st matrix
		x(ii,1) = det_f(a2(:,:,ii+1),n) / det_a1
		!write(6,*) x
	!! calculating first det_a1 saves time when doing calculation because this way, we do not have to evaluate det_f(a(:,:,1),n) in each iteration
	end do loop1
	!x = 0.0d00



	!!!!!! ++++++++++++++++++++ !!!!!!
	!!!!!! Function Declaration !!!!!!
	!!!!!! ++++++++++++++++++++ !!!!!!

		contains
		recursive DOUBLE PRECISION function det_f(matrix,n) result(det)
		! function for calculating matrix determinants
		implicit none
		integer, intent(in):: n
		DOUBLE PRECISION, intent(in), dimension(n,n):: matrix
		DOUBLE PRECISION, dimension(n-1,n-1):: sl !  submatrix
		integer:: ii
		det = 0
		if (n == 1) then
			det = matrix(1,1)
			return

		else if(n == 2) then
			det = matrix(1,1)*matrix(2,2) - matrix(1,2)*matrix(2,1)
			return
       	else
       	! lets sweep the columns of the matrix
       	do ii = 1,n
       	    call slice_f(sl, matrix,n,1,ii)
       	    det = det + ( (-1.0)**(1+ii) )*matrix(1,ii)*det_f(sl,n-1)
       	end do
       	return
       	end if
	
       	end function det_f

						
!######################################################################
	end subroutine cramer_solver
!######################################################################
 



!######################################################################
	SUBROUTINE pressureProbe(pout)
!######################################################################

	    use imb
	    use vars
	    use mpi
	    use multidata
		
	    implicit none

      DOUBLE PRECISION, INTENT(out):: pout(3)
      INTEGER 	:: M,L
	  
		  ! definition of iterators
	  INTEGER :: ib,iii,jjj,kkk,nn,mm,ll, vecID,searchID
	  INTEGER :: iic, jjc, kkc, iicm, jjcm, kkcm
	  ! ib: index for subdomain,
	  ! iii : index for cells along the OX direction
	  ! jjj : index for cells along the OX direction
	  ! kkk : index for cells along the OX direction	
	  ! mm :
	  ! nn : index for nodes belonging to the M-th mody	  
	  ! 
	  INTEGER :: nnStart, nnFinish
	  
	  INTEGER :: is,ie,js,je,ks,ke
	  INTEGER :: i_n_cells ,j_n_cells,k_n_cells
	  
	  DOUBLE PRECISION :: cnx,cny,cnz ! Marker coordinates, cn
	  DOUBLE PRECISION :: coef1, coef2 ! Coefficients for computing pressure force coefficient
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: pcdx, pcdz ! pcdx(M) pressure force coefficinet on the M-th body
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: px, pz ! px(M) Total pressure applied on the M-th body
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: px2, pz2 ! px(M) Total pressure applied on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: pcdx2, pcdz2 ! pcdx(M) pressure force coefficinet on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::fxVecSt,fzVecSt ! fxVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::fxVecSt2,fzVecSt2 ! fxVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:,:) ::pxVecMks,pzVecMks ! pxVecMks(M,mm,nn)
	  DOUBLE PRECISION:: fxk, fzk, fxk2, fzk2, pnn(3)
	  DOUBLE PRECISION:: betha1, tanBetha1, cosBetha1, sinBetha1
	  ! fxVecSt: ox pressure component applied on the  mm-th station of the M-th body
	  ! pxVecMks: ox pressure component applied on the n-th pair of markers at the mm-th station of the M-th body
	  ! fxk : pressure force along the ox direction at markers location nds(1)
	  ! fzk : pressure force along the oz direction at markers location nds(2)
	  ! pnn(1) : pressure at markers location nds(1)
	  ! pnn(2) : pressure at markers location nds(2)

	  ! Boundary Margings
	  DOUBLE PRECISION:: dh, margin,dx_l,dy_l,dz_l,swapTemp
	  ! dh : equivalent grid spacing in 3D
	  ! margin: Boundary Margings
	  INTEGER:: layers2Sweep,mksPS
	  INTEGER:: mksEL, St_k
	  
	  ! ys:  OZ coordinate of the intersection between the face od the pressure cells and the segment linking markers cn and cn2	
	  DOUBLE PRECISION:: origin_xc , origin_yc, origin_zc
	  DOUBLE PRECISION, DIMENSION(3):: ndsx,ndsy,ndsz
	  DOUBLE PRECISION:: ndsl, ndslx, ndsly, ndslz ! Distances between nds(1)) and nds(3)
	  DOUBLE PRECISION:: tempx, tempy, tempz, gamma1 ! Variable for tracking the location of the markers relative to the body centre of gravity
	  INTEGER:: vec1(8), vecm(8)	! Interface vector that stores some input variables for subroutine "get_f"

	  ! Flags
	  INTEGER :: qFlag,flag1, flag2
	  
	  ALLOCATE(pcdx(bodynum), pcdz(bodynum))
	  ALLOCATE(px(bodynum), pz(bodynum) )
	  ALLOCATE(pcdx2(bodynum), pcdz2(bodynum))
	  ALLOCATE(px2(bodynum), pz2(bodynum) )
	  pcdx = 0.0d00; pcdz = 0.0d00
	  px = 0.0d00;	pz = 0.0d00
	  pcdx2 = 0.0d00; pcdz2 = 0.0d00
	  px2 = 0.0d00;	pz2 = 0.0d00
	  coef1 = 1/(0.5*1*(Ubulk**2)*1*0.3) ! coefficient for comparing drag and lift forces with previous results
	  coef2 = 1/(0.5*1*(Ubulk**2)*1)	   ! coefficient for comparing pressure and shear stress values with previous results

	  do M = 1, bodynum	! Sweeping inmersed bodies

	  do ib = 1, nbp ! lets sweep subdomains assigned to the current processor

		!if (myrank.eq.0) then ! The control is passed down to the master processor
	  if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
												  ! markers are located
	   ! lets check if the subdomain has any marker at all
	!   if (imbinblk(ib) .gt. 0 ) then 	! ??? check there may only be 1 maker in the subdomain

			! Bounds for pressure p (NOT INCLUDING GHOST LAYERS)
		is = dom(ib)%isp; ie = dom(ib)%iep
		js = dom(ib)%jsp; je = dom(ib)%jep
		ks = dom(ib)%ksp; ke = dom(ib)%kep
				   
				   ! Including ghost layers:
				   ! is=dom(ib)%isu; ie=dom(ib)%ieu		

	   dx_l = dom(ib)%dx
	   dy_l= dom(ib)%dy
	   dz_l= dom(ib)%dz
	   dh = (dx_l*dy_l*dz_l)**(1.0D00/3)
	   margin = 1.0e-9	!1.0e-5	! Margin for searching if arkers are within the boundaries of a cell

	   origin_xc = dom(ib)%xc(1)
	   origin_yc = dom(ib)%yc(1)
	   origin_zc = dom(ib)%zc(1)
	   
	   ! Bounds for u velocity component (NOT INCLUDING GHOST LAYERS)
	   is=dom(ib)%isu; ie=dom(ib)%ieu
	   js=dom(ib)%jsu; je=dom(ib)%jeu
	   ks=dom(ib)%ksu; ke=dom(ib)%keu
	   
	   i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
	   j_n_cells = dom(ib)%ttc_j
	   k_n_cells = dom(ib)%ttc_k


	   St_k = ibmSt(bodynum)
	   ! allocate(ibmSt(bodynum)) 
	   ! ibmSt : ofr each postion, it stores the number of stations defined in each body
	   ! ibmSt_k = 0	! counter of the total number of stations
	   ! do ii = 1, bodynum
	   ! 	ibmSt_k = ibmSt_k + ibmSt(ii)
	   ! enddo
	   ! allocate(ibmStMkrs(ibmSt_k)) ! for each postion jj, it stores the number of markers in station jj
	   ! ibmStMkrs( (M-1)*ibmSt(M-1) + M*k ) : number of markers at station k for body M
	   ! 
	   ! ibmStMkrs
	   mksPS = ibmStMkrs(ibmSt_k)
	   
	   
	   ! St_k = 0	! counter of the total number of stations
	   ! do ii = 1, bodynum
	   ! 	ibmSt_k = ibmSt_k + ibmSt(ii)
	   ! enddo
	   ! allocate(ibmMkrsEL(ibmSt_k)) ! for each postion jj, it stores the number of markers in the exterior layer in station jj
	   ! ibmMkrsEL( (M-1)*ibmSt(M-1) + M*k ) : number of markers at exterior layer in station k for body M
	   ! 
	   ! ibmMkrsEL
	   mksEL = ibmMkrsEL(ibmSt_k)


	   ALLOCATE(fxVecSt(bodynum,St_k))
	   ALLOCATE(fzVecSt(bodynum,St_k))
	   ALLOCATE(fxVecSt2(bodynum,St_k))
	   ALLOCATE(fzVecSt2(bodynum,St_k))
	   fxVecSt = 0.0d00; fzVecSt = 0.0d00
	   fxVecSt2 = 0.0d00; fzVecSt2 = 0.0d00


	   do mm = 1, St_k	! sweeping stations

	   !layers2Sweep = 20
	   
	   nnFinish = mksEL + (mm-1)*mksPS
	   nnStart = 1 + (mm-1)*mksPS

	   ! Initializing pressure pnn on the link connecting nds1 and nds2
	   fxk = 0.0d00; fzk = 0.0d00
	   fxk2 = 0.0d00; fzk2 = 0.0d00
	   pnn(1) = 0.0d00; pnn(2) = 0.0d00
	   pnn(3) = 0.0d00

	   ! Lets optain pressure at node nds1
	   ll = 1
	   ! Extracting marker coordinates
	   ndsx(1) = nodex_loc(nnStart) 
	   ndsy(1) = nodey_loc(nnStart) 
	   ndsz(1) = nodez_loc(nnStart)
	   !
	   iic = int ( ( ndsx(1) - origin_xc - margin) /dx_l) + 2 
	   jjc = int ( ( ndsy(1) - origin_yc - margin) /dy_l) + 2
	   kkc = int ( ( ndsz(1) - origin_zc - margin) /dz_l) + 2
	   ! Check for not modifying the ghost layer beyoud the boundaries of the control volume
	   if (jjc .lt. js) then
		   jjc = js
	   endif
	   if (jjc .gt. je) then
		   jjc = je
	   endif
	   !
	   vec1(1) = nnStart	! Node nds1
	   vec1(2) = ib 
	   vec1(3) = ll
	   vec1(4) = iic 
	   vec1(5) = jjc 
	   vec1(6) = kkc 
	   vec1(8) = 4
	   !
	   call get_f(vec1,ndsx(1),ndsz(1),pnn(1))


	   !do nn = 1, maxnodeIBS	! sweeping markers
	   do nn = 1+(mm-1)*mksPS, mm*mksPS	!  sweeping markers of each station

		IF(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???

		   if( ( nn.ge.nnStart).and.(nn.le.nnFinish) ) then ! Filtering interior layers

		    	! Extracting marker coordinates
		    		ndsx(1) = nodex_loc(nn) 
		    		ndsy(1) = nodey_loc(nn) 
		    		ndsz(1) = nodez_loc(nn)
		    	! Extrancting coordinates of the neighbouring markers from the same layer
		    	if ( nn .eq. nnFinish) then
		    		! Coordinates of the next markers, cn2
		    		ndsx(2) = nodex_loc(nnStart)
		    		ndsy(2) = nodey_loc(nnStart)
		    		ndsz(2) = nodez_loc(nnStart)
		    	else
		    		! Coordinates of the next markers, cn2
		    		ndsx(2) = nodex_loc(nn+1)
		    		ndsy(2) = nodey_loc(nn+1)
		    		ndsz(2) = nodez_loc(nn+1)
		    	endif
		    		! Coordinates of the previous marker, cn3
		    	ndsx(3) = 0.5*(ndsx(1) + ndsx(2))
		    	ndsy(3) = 0.5*(ndsy(1) + ndsy(2))
		    	ndsz(3) = 0.5*(ndsz(1) + ndsz(2))
		    	!
		    	iic = int ( ( ndsx(2) - origin_xc - margin) /dx_l) + 2 
		    	jjc = int ( ( ndsy(2) - origin_yc - margin) /dy_l) + 2
		    	kkc = int ( ( ndsz(2) - origin_zc - margin) /dz_l) + 2
		    	!
		    	iicm = int ( ( ndsx(3) - origin_xc - margin) /dx_l) + 2 
		    	jjcm = int ( ( ndsy(3) - origin_yc - margin) /dy_l) + 2
		    	kkcm = int ( ( ndsz(3) - origin_zc - margin) /dz_l) + 2
		    	! Check for not modifying the ghost layer beyoud the boundaries of the control volume
		    	if (jjc .lt. js) then
		    		jjc = js
		    	endif
		    	if (jjc .gt. je) then
		    		jjc = je
		    	endif
		    	!
		    	vec1(1) = nn+1	! Node nds(2)
		    	vec1(2) = ib 
		    	vec1(3) = ll
		    	vec1(4) = iic 
		    	vec1(5) = jjc 
		    	vec1(6) = kkc
		    	vec1(8) = 4
		    	!
		    	vecm(1) = nn+1	! Node nds(1.5)
		    	vecm(2) = ib 
		    	vecm(3) = ll
		    	vecm(4) = iicm 
		    	vecm(5) = jjcm
		    	vecm(6) = kkcm
		    	vecm(8) = 4
		    	!
		    	ndslx = (ndsx(1) - ndsx(2))**2
		    	ndsly = (ndsy(1) - ndsy(2))**2
		    	ndslz = (ndsz(1) - ndsz(2))**2
		    	ndsl = sqrt(ndslx+ndsly+ndslz)
		    	!
		    	! ( 0, 90 ] First quadrant?
		    	if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
		    	if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
		    		vec1(7) = 1! qFlag = 1
		    		call get_f(vec1,ndsx(2),ndsz(2),pnn(2))
		    		call get_f(vecm,ndsx(3),ndsz(3),pnn(3))
		    tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
		    betha1 = abs(DATAN(tanBetha1))*180/piNUm	! lets obtain betha1
		    		cosBetha1 = DCOS(betha1*piNUm/180)
		    		sinBetha1 = DSIN(betha1*piNUm/180)
		    		fxk = 0.5*(pnn(1)+pnn(2))
		    		fxk = - fxk*ndsl*dy_l*sinBetha1
		    		!
		    		fxk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fxk2 = - fxk2*ndsl*dy_l*sinBetha1
		    		!
		    		fzk = 0.5*(pnn(1)+pnn(2))
		    		fzk = + fzk*ndsl*dy_l*cosBetha1
		    		!
		    		fzk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fzk2 = + fzk2*ndsl*dy_l*cosBetha1
		    	endif
		    	endif
		    	! ( 90, 180 ] 2nd quadrant?
		    	if ( (ndsx(2) - ndsx(1)) .le. -margin) then
		    	if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
		    		vec1(7) = 2	!qFlag = 2
		    		call get_f(vecm,ndsx(3),ndsz(3),pnn(3))
		    		call get_f(vec1,ndsx(2),ndsz(2),pnn(2))
		    tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
		    betha1 = abs(DATAN(tanBetha1))*180/piNUm	
		    		cosBetha1 = DCOS(betha1*piNUm/180)
		    		sinBetha1 = DSIN(betha1*piNUm/180)
		    		fxk = 0.5*(pnn(1)+pnn(2))
		    		fxk = - fxk*ndsl*dy_l*sinBetha1
		    		!
		    		fxk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fxk2 = - fxk2*ndsl*dy_l*sinBetha1
		    		!
		    		fzk = 0.5*(pnn(1)+pnn(2))
		    		fzk = - fzk*ndsl*dy_l*cosBetha1
		    		!
		    		fzk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fzk2 = - fzk2*ndsl*dy_l*cosBetha1
		    	endif
		    	endif
		    	! ( 180, 270 ] 3rd quadrant?
		    	if ( (ndsx(2) - ndsx(1)) .le. margin) then
		    	if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
		    		vec1(7) = 3	!qFlag = 3
		    		call get_f(vecm,ndsx(3),ndsz(3),pnn(3))
		    		call get_f(vec1,ndsx(2),ndsz(2),pnn(2))
		    tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
		    betha1 = abs(DATAN(tanBetha1))*180/piNUm
		    		cosBetha1 = DCOS(betha1*piNUm/180)
		    		sinBetha1 = DSIN(betha1*piNUm/180)
		    		fxk = 0.5*(pnn(1)+pnn(2))
		    		fxk = fxk*ndsl*dy_l*sinBetha1
		    		!
		    		fxk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fxk2 = fxk2*ndsl*dy_l*sinBetha1
		    		!
		    		fzk = 0.5*(pnn(1)+pnn(2))
		    		fzk = - fzk*ndsl*dy_l*cosBetha1
		    		!
		    		fzk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fzk2 = - fzk2*ndsl*dy_l*cosBetha1
		    	endif
		    	endif
		    	! ( 270, 360 ] 4th quadrant?
		    	if ( (ndsx(2) - ndsx(1)) .gt. margin) then
		    	if ( (ndsz(2) - ndsz(1)) .le. margin) then
		    		vec1(7) = 4	!qFlag = 4
		    		call get_f(vecm,ndsx(3),ndsz(3),pnn(3))
		    		call get_f(vec1,ndsx(2),ndsz(2),pnn(2))
		    tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
		    betha1 = abs(DATAN(tanBetha1))*180/piNUm
		    		cosBetha1 = DCOS(betha1*piNUm/180)
		    		sinBetha1 = DSIN(betha1*piNUm/180)
		    		fxk = 0.5*(pnn(1)+pnn(2))
		    		fxk = fxk*ndsl*dy_l*sinBetha1
		    		!
		    		fxk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fxk2 = fxk2*ndsl*dy_l*sinBetha1
		    		!
		    		fzk = 0.5*(pnn(1)+pnn(2))
		    		fzk = fzk*ndsl*dy_l*cosBetha1
		    		!
		    		fzk2 = (pnn(1)+4*(pnn(3))+pnn(2))/6
		    		fzk2 = fzk2*ndsl*dy_l*cosBetha1
		    	endif
		    	endif
		    	!
     			if((nn.gt.9240).and.(nn.lt.10561)) then
     				tempx = (ndsx(1) - 18.0d00)
     				tempz = (ndsz(1) - 10.5d00)
     				if (vec1(7).eq.3) then
     		gamma1 = - DATAN(tempz/tempx)*180/piNUm
     				elseif (vec1(7).eq.2) then
     		gamma1 = 180 - DATAN(tempz/tempx)*180/piNUm
     				elseif (vec1(7).eq.4) then
     		gamma1 = - DATAN(tempz/tempx)*180/piNUm
     				elseif (vec1(7).eq.1) then
     		gamma1 = -180 - DATAN(tempz/tempx)*180/piNUm
     				endif
	        		write(6,*) nn, gamma1, pnn(1)*coef2
			 !				write(6,*) pnn*coef2
     			!	write(6,*) dom(ib)%u(iic, jjc, kkc), fxk, fzk
     			!	write(6,*) dom(ib)%w(iic, jjc, kkc), fxk2, fzk2
     			endif
     			!
     	!			if(nn.eq.15) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!	write(6,*) dom(ib)%u(iic, jjc, kkc), fxk, fzk
     	!	write(6,*) dom(ib)%w(iic, jjc, kkc), fxk2, fzk2
     	!			endif
     	!			if(nn.eq.45) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!	write(6,*) dom(ib)%u(iic-1, jjc, kkc), fxk, fzk
     	!	write(6,*) dom(ib)%w(iic-1, jjc, kkc), fxk2, fzk2
     	!				endif
     	!			if(nn.eq.62) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!	write(6,*) dom(ib)%u(iic-1, jjc, kkc), fxk, fzk
     	!	write(6,*) dom(ib)%w(iic-1, jjc, kkc), fxk2, fzk2
     	!			endif
     	!			if(nn.eq.77) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!write(6,*) dom(ib)%u(iic-1, jjc, kkc-1), fxk, fzk
     	!write(6,*) dom(ib)%w(iic-1, jjc, kkc-1), fxk2, fzk2
     	!			endif
     	!			if(nn.eq.105) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!write(6,*) dom(ib)%u(iic, jjc, kkc-1), fxk, fzk
     	!write(6,*) dom(ib)%w(iic, jjc, kkc-1), fxk2, fzk2
     	!			endif
     	!			if(nn.eq.126) then
     	!				write(6,*) nn, iic, kkc
     	!				write(6,*) pnn*coef2
     	!	write(6,*) dom(ib)%u(iic, jjc, kkc), fxk, fzk
     	!	write(6,*) dom(ib)%w(iic, jjc, kkc), fxk2, fzk2
     	!			endif
					!
					if ( (mm.eq.1).or.(mm.eq.St_k ) )then
						fxVecSt(M,mm) = 0.5*fxVecSt(M,mm)
						fxVecSt2(M,mm) = 0.5*fxVecSt2(M,mm)
						fzVecSt(M,mm)  = 0.5*fzVecSt(M,mm)
						fzVecSt2(M,mm) = 0.5*fzVecSt2(M,mm)
						!write(6,*) mm, fxVecSt(M,mm), fxVecSt2(M,mm)
					endif
                    ! check !!!
                    fxVecSt(M,mm) = fxVecSt(M,mm) + fxk 
                    fzVecSt(M,mm) = fzVecSt(M,mm) + fzk
                    fxVecSt2(M,mm) = fxVecSt2(M,mm) + fxk2 
                    fzVecSt2(M,mm) = fzVecSt2(M,mm) + fzk2
					!
					! Update of pnn(1)
                    pnn(1) = pnn(2)
	       else
			  ll = 2
	        endif! Filtering interior layers

		 endif	! Ensuring processor ID matches subdomain ID???

		enddo	!  sweeping markers of each station
                    !
		px(M) = px(M) + fxVecSt(M,mm)
		pz(M) = pz(M) + fzVecSt(M,mm)
		px2(M) = px2(M) + fxVecSt2(M,mm)
		pz2(M) = pz2(M) + fzVecSt2(M,mm)
		!

		enddo	! sweeping stations

		DEALLOCATE(fxVecSt,fzVecSt)
		DEALLOCATE(fxVecSt2,fzVecSt2)

	    !p1(1) = px2(M)
	    !p1(2) = 0.0d0
		!p1(3) = pz2(M)
	    pout(1) = px2(M)
	    pout(2) = 0.0d0
	    pout(3) = pz2(M)
	    pcdx(M) = coef1*px(M) 
	    pcdz(M) = coef1*pz(M)
	    pcdx2(M) = coef1*px2(M) 
	    pcdz2(M) = coef1*pz2(M)
	    write(6,*) "px", px(M), px2(M)
	    write(6,*) "pcdx", pcdx(M), pcdx2(M)
	    write(6,*) "pz", pz(M), pz2(M)
	    write(6,*) "pcdz", pcdz(M), pcdz2(M)

	  endif ! Filtering out procesors

	  enddo ! End of the  loop sweeping the domains
		!
		!
	    enddo ! end of the loop sweeping the bodies
		!
		!
	    DEALLOCATE(pcdx, pcdz)
	    DEALLOCATE(px, pz )
	    DEALLOCATE(pcdx2, pcdz2)
	    DEALLOCATE(px2, pz2 )

!######################################################################		
	END SUBROUTINE pressureProbe
!######################################################################	 

!######################################################################
	SUBROUTINE shearStressProbe(shout)
!######################################################################

		use vars
		use imb
		use mpi
	    use multidata
		
		implicit none
		
      DOUBLE PRECISION, INTENT(out):: shout(3)

      INTEGER 	:: M,L
	  
		  ! definition of iterators
	  INTEGER :: ib,iii,jjj,kkk,nn,mm,ll, vecID,searchID
	  INTEGER :: iic, jjc, kkc, iicm, jjcm, kkcm,iiim,jjjm,kkkm

      ! ib: index for subdomain,
	  ! iii : index for cells along the OX direction
	  ! jjj : index for cells along the OX direction
	  ! kkk : index for cells along the OX direction	
	  ! mm :
	  ! nn : index for nodes belonging to the M-th mody	  
	  ! 
	  INTEGER :: nnStart, nnFinish
	  
	  INTEGER :: is,ie,js,je,ks,ke
	  INTEGER :: i_n_cells ,j_n_cells,k_n_cells
	  
	  DOUBLE PRECISION :: cnx,cny,cnz ! Marker coordinates, cn
	  DOUBLE PRECISION :: coef1, coef2 ! Coefficients for computing shear stress force coefficient
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tx, tz ! tx(M) Total shear stress applied on the M-th body
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tx2, tz2 ! tx(M) Total shear stress applied on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tx3, tz3 ! tx(M) Total shear stress applied on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tx4, tz4 ! tx(M) Total shear stress applied on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tcdx, tcdz ! tcdx(M) shear stress force coefficinet on the M-th body
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tcdx2, tcdz2 ! tcdx(M) shear stress force coefficinet on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tcdx3, tcdz3 ! tcdx(M) shear stress force coefficinet on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: tcdx4, tcdz4 ! tcdx(M) shear stress force coefficinet on the M-th body (Simpsom's rule)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::txVecSt,tzVecSt ! txVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::txVecSt2,tzVecSt2 ! txVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::txVecSt3,tzVecSt3 ! txVecSt(M,mm)
	  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) ::txVecSt4,tzVecSt4 ! txVecSt(M,mm)	  
	  DOUBLE PRECISION:: txk, tzk, txk2, tzk2
	  DOUBLE PRECISION:: txk3, tzk3, txk4, tzk4
	  ! txVecSt: ox shear stress component applied on the  mm-th station of the M-th body
	  ! txVecMks: ox shear stress component applied on the n-th pair of markers at the mm-th station of the M-th body
	  ! txk : shear stress force along the ox direction at markers location nds(1)
	  ! tzk : shear stress force along the oz direction at markers location nds(2)
	  DOUBLE PRECISION:: tempx, tempz, gamma1
      
      ! shear stress calculation varaibles
	  DOUBLE PRECISION:: unn(3), vnn(3), wnn(3)
	  ! unn(1) : u velocity value at markers location nds(1)
	  ! unn(2) : u velocity value at markers location nds(2)
	  DOUBLE PRECISION:: dudn(3),dwdn(3),musgs(3),tao(3)
	  DOUBLE PRECISION:: du_dz(3),du_dx(3),dw_dz(3),dw_dx(3)
	  DOUBLE PRECISION:: dudn2(3),dwdn2(3),tao2(3)
	  DOUBLE PRECISION:: yplus,mkx1,mkz1,mkx2,mkz2,mkx3,mkz3
	  DOUBLE PRECISION:: betha1, tanBetha1, sinBetha1, cosBetha1
	  DOUBLE PRECISION:: betha2, tanBetha2, sinBetha2, cosBetha2
	  DOUBLE PRECISION:: betha3, tanBetha3, sinBetha3, cosBetha3
	  DOUBLE PRECISION:: betha4, tanBetha4, sinBetha4, cosBetha4
	  DOUBLE PRECISION:: factor2,v1(3),v2(3),v2m(3)
	  ! v1, v2 : auxiliary vectors for doing a dot porduct

	  ! Boundary Margings
	  DOUBLE PRECISION:: dh, margin,dx_l,dy_l,dz_l,swapTemp
	  ! dh : equivalent grid spacing in 3D
	  ! margin: Boundary Margings
	  INTEGER:: layers2Sweep,mksPS
	  INTEGER:: mksEL, St_k
	  
	  ! ys:  OZ coordinate of the intersection between the face od the shear stress cells and the segment linking markers cn and cn2	
      DOUBLE PRECISION:: origin_xc , origin_yc, origin_zc
	  DOUBLE PRECISION:: origin_x  , origin_y, origin_z
	  DOUBLE PRECISION, DIMENSION(3):: ndsx,ndsy,ndsz
	  DOUBLE PRECISION:: ndsl, ndslx, ndsly, ndslz ! Distances between nds(1)) and nds(3)
	  INTEGER:: vec1(8), vecm(8), vec2(8), vecm2(8)	! Interface vector that stores some input variables for subroutine "get_f"
	  INTEGER:: vec13(8), vec13m(8), vec11(8), vec11m(8)	
	  INTEGER:: vec33(8), vec33m(8), vec31(8), vec31m(8)	

	  ! Flags
	  INTEGER :: qFlag,flag1, flag2
	  
	!  if (myrank.eq. master ) then ! The control is passed down to the master processor

		! Lets print to file for debugging
		! CSV format
87      format(1x, *(g0, " ")) 
        OPEN(unit = 93, access = "sequential", action = "write",
     &   status = "replace", file = "tao1.txt", form = "formatted")

        OPEN(unit = 94, access = "sequential", action = "write",
     &   status = "replace", file = "tao2.txt", form = "formatted")
	 
        OPEN(unit = 95, access = "sequential", action = "write",
     &   status = "replace", file = "dudn.txt", form = "formatted")

        OPEN(unit = 96, access = "sequential", action = "write",
     &   status = "replace", file = "dwdn.txt", form = "formatted")
		
		ALLOCATE(tcdx(bodynum), tcdz(bodynum))
		ALLOCATE(tx(bodynum), tz(bodynum) )
		ALLOCATE(tcdx2(bodynum), tcdz2(bodynum))
		ALLOCATE(tx2(bodynum), tz2(bodynum) )
		ALLOCATE(tcdx3(bodynum), tcdz3(bodynum))
		ALLOCATE(tx3(bodynum), tz3(bodynum) )
		ALLOCATE(tcdx4(bodynum), tcdz4(bodynum))
		ALLOCATE(tx4(bodynum), tz4(bodynum) )
		tx = 0.0d00;	tz = 0.0d00
		tx2 = 0.0d00;	tz2 = 0.0d00
		tx3 = 0.0d00;	tz3 = 0.0d00
		tx4 = 0.0d00;	tz4 = 0.0d00
		tcdx = 0.0d00; tcdz = 0.0d00
		tcdx2 = 0.0d00; tcdz2 = 0.0d00
		tcdx3 = 0.0d00; tcdz3 = 0.0d00
		tcdx4 = 0.0d00; tcdz4 = 0.0d00

		coef1 = 1/(0.5*1*(Ubulk**2)*1*0.3)
		coef2 = 1/(0.5*1*(Ubulk**2)*1)

	    do M = 1, bodynum	! Sweeping inmersed bodies

		   do ib = 1, nbp ! lets sweep subdomains assigned to the current processor
	  
			  !if (myrank.eq.0) then ! The control is passed down to the master processor
		    if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
														! markers are located
			 ! lets check if the subdomain has any marker at all
		     !if (imbinblk(ib) .gt. 0 ) then 	! ??? check there may only be 1 maker in the subdomain
	  
				  ! Bounds for pressure p (NOT INCLUDING GHOST LAYERS)
			  is = dom(ib)%isp; ie = dom(ib)%iep
			  js = dom(ib)%jsp; je = dom(ib)%jep
			  ks = dom(ib)%ksp; ke = dom(ib)%kep
			  !   
				   ! Including ghost layers:
				   ! is=dom(ib)%isu; ie=dom(ib)%ieu		
			  !
			  dx_l = dom(ib)%dx
			  dy_l= dom(ib)%dy
			  dz_l= dom(ib)%dz
			  dh = (dx_l*dy_l*dz_l)**(1.0D00/3)
			  margin = 1.0e-9	!1.0e-5	! Margin for searching if arkers are within the boundaries of a cell
			  !
			  origin_xc = dom(ib)%xc(1)
			  origin_yc = dom(ib)%yc(1)
			  origin_zc = dom(ib)%zc(1)
			  !
			  ! Bounds for u velocity component (NOT INCLUDING GHOST LAYERS)
			  is=dom(ib)%isu; ie=dom(ib)%ieu
			  js=dom(ib)%jsu; je=dom(ib)%jeu
			  ks=dom(ib)%ksu; ke=dom(ib)%keu
			  !
			  i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
			  j_n_cells = dom(ib)%ttc_j
			  k_n_cells = dom(ib)%ttc_k
			  !
			  St_k = ibmSt(bodynum)
			  ! allocate(ibmSt(bodynum)) 
			  ! ibmSt : ofr each postion, it stores the number of stations defined in each body
			  ! St_k = 0	! counter of the total number of stations
			  ! do ii = 1, bodynum
			  ! 	St_k = St_k + ibmSt(ii)
			  ! enddo
			  ! allocate(ibmStMkrs(St_k)) ! for each postion jj, it stores the number of markers in station jj
			  ! ibmStMkrs( (M-1)*ibmSt(M-1) + M*k ) : number of markers at station k for body M
			  ! 
			  ! ibmStMkrs
			  mksPS = ibmStMkrs(ibmSt_k)
			  !
			  ! St_k = 0	! counter of the total number of stations
			  ! do ii = 1, bodynum
			  ! 	St_k = St_k + ibmSt(ii)
			  ! enddo
			  ! allocate(ibmMkrsEL(St_k)) ! for each postion jj, it stores the number of markers in the exterior layer in station jj
			  ! ibmMkrsEL( (M-1)*ibmSt(M-1) + M*k ) : number of markers at exterior layer in station k for body M
			  ! 
			  ! ibmMkrsEL
			  mksEL = ibmMkrsEL(ibmSt_k)
			  !
			  !
			  ! Lets update the fluid velocity derivatives
			  call du_dv_dw_dh_WENO(8)
			  !
			  !
			  ! lets check if the subdomain has any marker at all
			  !if (imbinblk(ib) .gt. 0 ) then 	! ??? check there may only be 1 maker in the subdomain
			  !
			  dx_l = dom(ib)%dx ! 
			  dy_l= dom(ib)%dy
			  dz_l= dom(ib)%dz
			  dh = (dx_l*dy_l*dz_l)**(1.0D00/3)
			  yplus = 1.0d00*dh
			  margin = 1.0e-9	!1.0e-5	! Margin for searching if arkers are within the boundaries of a cell
			  !
			  origin_xc = dom(ib)%xc(1)
			  origin_yc = dom(ib)%yc(1)
			  origin_zc = dom(ib)%zc(1)
			  !
			  origin_x = dom(ib)%x(1)
			  origin_y = dom(ib)%y(1)
			  origin_z = dom(ib)%z(1)
			  !
			  !
			  ! Bounds for u velocity component (NOT INCLUDING GHOST LAYERS)
			  is=dom(ib)%isu; ie=dom(ib)%ieu
			  js=dom(ib)%jsu; je=dom(ib)%jeu
			  ks=dom(ib)%ksu; ke=dom(ib)%keu
			  ! Including ghost layers:
			  ! is=dom(ib)%isu; ie=dom(ib)%ieu
			  !
			  i_n_cells = dom(ib)%ttc_i	! total number number of cells along the OX axis, incuding ghost cells
			  j_n_cells = dom(ib)%ttc_j
			  k_n_cells = dom(ib)%ttc_k
			  !
			  ALLOCATE(txVecSt(bodynum, St_k))
			  ALLOCATE(tzVecSt(bodynum, St_k))
			  ALLOCATE(txVecSt2(bodynum,St_k))
			  ALLOCATE(tzVecSt2(bodynum,St_k))
			  ALLOCATE(txVecSt3(bodynum,St_k))
			  ALLOCATE(tzVecSt3(bodynum,St_k))
			  ALLOCATE(txVecSt4(bodynum,St_k))
			  ALLOCATE(tzVecSt4(bodynum,St_k))
			  txVecSt = 0.0d00; tzVecSt = 0.0d00
			  txVecSt2 = 0.0d00; tzVecSt2 = 0.0d00
			  txVecSt3 = 0.0d00; tzVecSt3 = 0.0d00
			  txVecSt4 = 0.0d00; tzVecSt4 = 0.0d00
			  !
			  !
			  !
			  do mm = 1, St_k	! sweeping stations
				!
				!layers2Sweep = 20
				!
			    nnFinish = mksEL + (mm-1)*mksPS
			    nnStart = 1 + (mm-1)*mksPS
			    !
			    ! Initializing shear stress unn on the link connecting nds1 and nds2
			    txk = 0.0d00; tzk = 0.0d00
			    txk2 = 0.0d00; tzk2 = 0.0d00
			    txk3 = 0.0d00; tzk3 = 0.0d00
			    txk4 = 0.0d00; tzk4 = 0.0d00
			    !
			    !
			    unn(1) = 0.0d00; unn(2) = 0.0d00
			    unn(3) = 0.0d00
			    !
			    wnn(1) = 0.0d00; wnn(2) = 0.0d00
			    wnn(3) = 0.0d00
			    !
			    !
			    du_dz(1) = 0.0d00; du_dz(2) = 0.0d00
			    du_dz(3) = 0.0d00
			    !
			    du_dx(1) = 0.0d00; du_dx(2) = 0.0d00
			    du_dx(3) = 0.0d00
			    !
			    dw_dz(1) = 0.0d00; dw_dz(2) = 0.0d00
			    dw_dz(3) = 0.0d00
			    !
			    dw_dx(1) = 0.0d00; dw_dx(2) = 0.0d00
			    dw_dx(3) = 0.0d00
			    !
			    !
			    tao(1) = 0.0d00; tao(2) = 0.0d00
			    tao(3) = 0.0d00
			    tao2(1) = 0.0d00; tao2(2) = 0.0d00
			    tao2(3) = 0.0d00
				!
				! Lets optain pressure at node nds1
			    ll = 1
				!
    			! Lets optain shear stress at node nds1
    			!
    			! Extracting first couple of marker coordinates
    			ndsx(1) = nodex_loc(nnStart) 
    			ndsy(1) = nodey_loc(nnStart) 
    			ndsz(1) = nodez_loc(nnStart)
    			ndsx(2) = nodex_loc(nnStart+1) 
    			ndsy(2) = nodey_loc(nnStart+1) 
    			ndsz(2) = nodez_loc(nnStart+1)
    	tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
    			betha1 = abs(DATAN(tanBetha1))*180/piNUm	! lets obtain betha1
    			cosBetha1 = DCOS(betha1*piNUm/180)
    			sinBetha1 = DSIN(betha1*piNUm/180)
    			!
    			! ( 0, 90 ] First quadrant?
    			if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
    			if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
    				vec1(7) = 1
    				mkx1 = ndsx(1) + yplus*sinBetha1
    				mkz1 = ndsz(1) - yplus*cosBetha1
    			endif
    			endif
    			! ( 90, 180 ] 2nd quadrant?
    			if ( (ndsx(2) - ndsx(1)) .le. -margin) then
    			if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
    				vec1(7) = 2
    				mkx1 = ndsx(1) + yplus*sinBetha1
    				mkz1 = ndsz(1) + yplus*cosBetha1
    			endif
    			endif
    			! ( 180, 270 ] 3rd quadrant?
    			if ( (ndsx(2) - ndsx(1)) .le. margin) then
    			if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
    				vec1(7) = 3
    				mkx1 = ndsx(1) - yplus*sinBetha1
    				mkz1 = ndsz(1) + yplus*cosBetha1
    			endif
    			endif
    			! ( 270, 360 ] 4th quadrant?
    			if ( (ndsx(2) - ndsx(1)) .gt. margin) then
    			if ( (ndsz(2) - ndsz(1)) .le. margin) then
    				vec1(7) = 4
    				mkx1 = ndsx(1) - yplus*sinBetha1
    				mkz1 = ndsz(1) - yplus*cosBetha1
    			endif
    			endif
    			!
    			iic = int ( ( ndsx(1) - origin_xc - margin) /dx_l) + 2 
    			jjc = int ( ( ndsy(1) - origin_yc - margin) /dy_l) + 2
    			kkc = int ( ( ndsz(1) - origin_zc - margin) /dz_l) + 2
    			!
    			iii = int ( ( ndsx(1) - origin_x - margin) /dx_l) + 2 
    			jjj = int ( ( ndsy(1) - origin_y - margin) /dy_l) + 2
    			kkk = int ( ( ndsz(1) - origin_z - margin) /dz_l) + 2
    			!
    			! Check for not modifying the ghost layer beyoud the boundaries of the control volume
    			if (jjc .lt. js) then
    				jjc = js
    			endif
    			if (jjc .gt. je) then
    				jjc = je
    			endif
    			!
    			! lets obtain velocity component u at local node 1, unn(1)
    			vec1(1) = nnStart	! Node nds1
    			vec1(2) = ib 
    			vec1(3) = ll
    			vec1(4) = iii
    			vec1(5) = jjc
    			vec1(6) = kkc
    			!
    			vec1(8) = 1 ! lets ge u values
    			call get_f(vec1,mkx1,mkz1,unn(1))
    			!
    			! lets obtain velocity component w at local node 1, wnn(1)
    			vec2(1) = nnStart	! Node nds1
    			vec2(2) = ib 
    			vec2(3) = ll
    			vec2(4) = iic 
    			vec2(5) = jjc 
    			vec2(6) = kkk
    			vec2(7) = vec1(7)
    			vec2(8) = 3 ! lets get w values
    			call get_f(vec2,mkx1,mkz1,wnn(1))
    			!
    			!
    			!
    			!
    			! lets obtain velocity component dudz at local node 1, unn(1)
    			vec13(1) = nnStart	! Node nds1
    			vec13(2) = ib 
    			vec13(3) = ll
    			vec13(4) = iii
    			vec13(5) = jjc
    			vec13(6) = kkc
    			vec13(7) = vec1(7)
    			vec13(8) = 10 ! lets ge dudz values
    			call get_f(vec13,ndsx(1),ndsz(1),du_dz(1))
    			! lets obtain velocity component dudx at local node 1, unn(1)
    			vec11(1) = nnStart	! Node nds1
    			vec11(2) = ib 
    			vec11(3) = ll
    			vec11(4) = iii
    			vec11(5) = jjc
    			vec11(6) = kkc
    			vec11(7) = vec1(7)
    			vec11(8) = 11 ! lets ge dudz values
    			call get_f(vec11,ndsx(1),ndsz(1),du_dx(1))
    			!
    			! lets obtain velocity component dwdx at local node 1, wnn(1)
    			vec31(1) = nnStart	! Node nds1
    			vec31(2) = ib 
    			vec31(3) = ll
    			vec31(4) = iic 
    			vec31(5) = jjc 
    			vec31(6) = kkk
    			vec31(7) = vec1(7)
    			vec31(8) = 12 ! lets get dwdx values
    			call get_f(vec31,ndsx(1),ndsz(1),dw_dx(1))
    			! lets obtain velocity component dwdz at local node 1, wnn(1)
    			vec33(1) = nnStart	! Node nds1
    			vec33(2) = ib 
    			vec33(3) = ll
    			vec33(4) = iic 
    			vec33(5) = jjc 
    			vec33(6) = kkk
    			vec33(7) = vec1(7)
    			vec33(8) = 13 ! lets get dwdx values
    			call get_f(vec33,ndsx(1),ndsz(1),dw_dz(1))
				!
				!
		    	! lets obtain the shear stress value at local node 1, tao(1)
		    	if (vec1(7).eq.1) then ! We are in the 1st Quadrant
		    		!dudn(1) = ( unn(1)*cosBetha1 - (-unn(1)*cosBetha1) )/(2*dh)
		    		dudn(1) = unn(1)*cosBetha1/yplus
		    		!dwdn = 0.5*( wnn(1)*sinBetha1 - (-wnn(1)*sinBetha1) )/dh
		    		dwdn(1) = wnn(1)*sinBetha1/yplus
		    		!dwdn(1) = - wnn(1)*sinBetha1/yplus
	!									factor2 = cosBetha1*sinBetha1
    !                            dudn2(1) = + du_dx(1)*cosBetha1*factor2 
    ! &                                     - du_dz(1)*cosBetha1*factor2
    !                            dwdn2(1) = + dw_dx(1)*sinBetha1*factor2
	! &                                     - dw_dz(1)*sinBetha1*factor2
					!
    !                            dudn2(1) = sqrt( (du_dx(1)*cosBetha1)**2 
    ! &                                     + (du_dz(1)*cosBetha1)**2 ) 
    !                            dwdn2(1) = sqrt( (dw_dx(1)*sinBetha1)**2
	! &                                     + (dw_dz(1)*sinBetha1)**2)
    				v1(1) = sinBetha1
    				v1(2) = 0.0d0
    				v1(3) = -cosBetha1
    				v2(1) = du_dx(1)*cosBetha1
    				v2(2) = 0.0d0
    				v2(3) = du_dz(1)*cosBetha1 
    		dudn2(1) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
    				v2(1) = dw_dx(1)*sinBetha1
    				v2(2) = 0.0d00
    				v2(3) = dw_dz(1)*sinBetha1
            dwdn2(1) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
								!	tanBetha2 = (du_dz(1))/(du_dx(1))
								!	betha2 = abs(DATAN(tanBetha2))*180/piNUm	! lets obtain betha1
					!
			 	elseif (vec1(7).eq.2) then ! We are in the 2nd Quadrant
			 		dudn(1) = unn(1)*cosBetha1/yplus
			 		dwdn(1) = - wnn(1)*sinBetha1/yplus

	!									factor2 = cosBetha1*sinBetha1
    !                            dudn2(1) = + du_dx(1)*cosBetha1*factor2 
    ! &                                     - du_dz(1)*cosBetha1*factor2
    !                            dwdn2(1) = - dw_dx(1)*sinBetha1*factor2
	! &                                     + dw_dz(1)*sinBetha1*factor2
					 !
    !                            dudn2(1) = sqrt( (du_dx(1)*cosBetha1)**2 
    ! &                                     + (du_dz(1)*cosBetha1)**2 )
    !                            dwdn2(1) = sqrt( (dw_dx(1)*sinBetha1)**2
    ! &                                     + (dw_dz(1)*sinBetha1)**2)
	    			v1(1) = sinBetha1
	    			v1(2) = 0.0d0
	    			v1(3) = cosBetha1
	    			v2(1) = du_dx(1)*cosBetha1
	    			v2(2) = 0.0d0
	    			v2(3) = du_dz(1)*cosBetha1 
	    	dudn2(1) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
	    			v2(1) = -dw_dx(1)*sinBetha1
	    			v2(2) = 0.0d00
	    			v2(3) = -dw_dz(1)*sinBetha1
		    dwdn2(1) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
				!
				 elseif (vec1(7).eq.3) then ! We are in the 3rd Quadrant
				 	dudn(1) = unn(1)*cosBetha1/yplus
				 	dwdn(1) = wnn(1)*sinBetha1/yplus
	!									factor2 = cosBetha1*sinBetha1
    !                            dudn2(1) = - du_dx(1)*cosBetha1*factor2 
    ! &                                     + du_dz(1)*cosBetha1*factor2
    !                            dwdn2(1) = - dw_dx(1)*sinBetha1*factor2
	! &                                     + dw_dz(1)*sinBetha1*factor2
					 !
    !                            dudn2(1) = sqrt( (du_dx(1)*cosBetha1)**2 
    ! &                                     + (du_dz(1)*cosBetha1)**2 )
    !                            dwdn2(1) = sqrt( (dw_dx(1)*sinBetha1)**2
    ! &                                     + (dw_dz(1)*sinBetha1)**2)
	    			v1(1) = -sinBetha1
	    			v1(2) = 0.0d0
	    			v1(3) = cosBetha1
	    			v2(1) = du_dx(1)*cosBetha1
	    			v2(2) = 0.0d0
	    			v2(3) = du_dz(1)*cosBetha1 
	    	dudn2(1) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
	    			v2(1) = dw_dx(1)*sinBetha1
	    			v2(2) = 0.0d00
	    			v2(3) = dw_dz(1)*sinBetha1
		    dwdn2(1) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
					!
				 elseif (vec1(7).eq.4) then ! We are in the 4th Quadrant
				 	dudn(1) = unn(1)*cosBetha1/yplus
				 	dwdn(1) = - wnn(1)*sinBetha1/yplus
	!									factor2 = cosBetha1*sinBetha1
    !                            dudn2(1) = - du_dx(1)*cosBetha1*factor2 
    ! &                                     + du_dz(1)*cosBetha1*factor2
    !                            dwdn2(1) = + dw_dx(1)*sinBetha1*factor2
	! &                                     - dw_dz(1)*sinBetha1*factor2
					 !
    !                            dudn2(1) = sqrt( (du_dx(1)*cosBetha1)**2 
    ! &                                     + (du_dz(1)*cosBetha1)**2 )
    !                            dwdn2(1) = sqrt( (dw_dx(1)*sinBetha1)**2
    ! &                                     + (dw_dz(1)*sinBetha1)**2)

	    			v1(1) = -sinBetha1
	    			v1(2) = 0.0d0
	    			v1(3) = -cosBetha1
	    			v2(1) = du_dx(1)*cosBetha1
	    			v2(2) = 0.0d0
	    			v2(3) = du_dz(1)*cosBetha1 
	    	dudn2(1) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
	    			v2(1) = -dw_dx(1)*sinBetha1
	    			v2(2) = 0.0d00
	    			v2(3) = -dw_dz(1)*sinBetha1
	    	dwdn2(1) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
				 endif
				 !
				 ! warning : check this dynamic viscosity value
				 musgs(1) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
				 tao(1) = musgs(1)*(dudn(1) + dwdn(1))
				 tao2(1) = musgs(1)*(dudn2(1) + dwdn2(1))
				!
				!
				!
				!
			    do nn = 1+(mm-1)*mksPS, mm*mksPS	!  sweeping markers of each station
				 !
				 IF(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???
				  !
				  if( ( nn.ge.nnStart).and.(nn.le.nnFinish) ) then ! Filtering interior layers
					!
					!
					! Extracting marker coordinates
					ndsx(1) = nodex_loc(nn) 
					ndsy(1) = nodey_loc(nn) 
					ndsz(1) = nodez_loc(nn)
		    		! Extrancting coordinates of the neighbouring markers from the same layer
		    		if ( nn .eq. nnFinish) then
		    			! Coordinates of the next markers, cn2
		    			ndsx(2) = nodex_loc(nnStart)
		    			ndsy(2) = nodey_loc(nnStart)
		    			ndsz(2) = nodez_loc(nnStart)
		    		else
		    			! Coordinates of the next markers, cn2
		    			ndsx(2) = nodex_loc(nn+1)
		    			ndsy(2) = nodey_loc(nn+1)
		    			ndsz(2) = nodez_loc(nn+1)
		    		endif
		    			! Coordinates of cn3, the mid point between cn1 and cn2
		    		ndsx(3) = 0.5*(ndsx(1) + ndsx(2))
		    		ndsy(3) = 0.5*(ndsy(1) + ndsy(2))
		    		ndsz(3) = 0.5*(ndsz(1) + ndsz(2))
		    		!
		    		iic = int ( ( ndsx(2) - origin_xc - margin) /dx_l) + 2
		    		jjc = int ( ( ndsy(2) - origin_yc - margin) /dy_l) + 2
		    		kkc = int ( ( ndsz(2) - origin_zc - margin) /dz_l) + 2
		    		!
		    		iicm = int ( ( ndsx(3) - origin_xc - margin) /dx_l) + 2 
		    		jjcm = int ( ( ndsy(3) - origin_yc - margin) /dy_l) + 2
		    		kkcm = int ( ( ndsz(3) - origin_zc - margin) /dz_l) + 2
		    		!
		    		iii = int ( ( ndsx(2) - origin_x - margin) /dx_l) + 2 
		    		jjj = int ( ( ndsy(2) - origin_y - margin) /dy_l) + 2
		    		kkk = int ( ( ndsz(2) - origin_z - margin) /dz_l) + 2
		    		!
		    		iiim = int ( ( ndsx(3) - origin_x - margin) /dx_l) + 2 
		    		jjjm = int ( ( ndsy(3) - origin_y - margin) /dy_l) + 2
		    		kkkm = int ( ( ndsz(3) - origin_z - margin) /dz_l) + 2
		    		!
		    		! Check for not modifying the ghost layer beyoud the boundaries of the control volume
		    		if (jjc .lt. js) then
		    			jjc = js
		    		endif
		    		if (jjc .gt. je) then
		    			jjc = je
		    		endif
		    		!
		    		! Interface vector for u velocity component at cn2
		    		vec1(1) = nn+1	! Node nds(2)
		    		vec1(2) = ib 
		    		vec1(3) = ll
		    		vec1(4) = iii 
		    		vec1(5) = jjc 
		    		vec1(6) = kkc
		    		vec1(8) = 1 ! lets ge u values
					!
					!
		    		! Interface vector for u velocity component at cn3
		    		vecm(1) = nn+1	! It should be node nds(1.5)
		    		vecm(2) = ib 
		    		vecm(3) = ll
		    		vecm(4) = iiim 
		    		vecm(5) = jjcm
		    		vecm(6) = kkcm
		    		vecm(8) = 1 ! lets ge u values
		    		!
		    		! Interface vector for w velocity component at cn2
		    		vec2(1) = nn+1	! Node nds(2)
		    		vec2(2) = ib 
		    		vec2(3) = ll
		    		vec2(4) = iic 
		    		vec2(5) = jjc 
		    		vec2(6) = kkk
		    		vec2(8) = 3 ! lets ge w values
		    		!
		    		! Interface vector for w velocity component at cn3
		    		vecm2(1) = nn+1	! Node nds(1.5)
		    		vecm2(2) = ib 
		    		vecm2(3) = ll
		    		vecm2(4) = iicm 
		    		vecm2(5) = jjcm
		    		vecm2(6) = kkkm
		    		vecm2(8) = 3 ! lets ge u values
		    		!
		    		!
		    		!
		    	! lets obtain velocity component dudz at local node cn2
		    		vec13(1) = nnStart	! Node nds1
		    		vec13(2) = ib 
		    		vec13(3) = ll
		    		vec13(4) = iii
		    		vec13(5) = jjc
		    		vec13(6) = kkc
		    		vec13(8) = 10 ! lets ge dudz values
		    		!
		    		! lets obtain velocity component dudx at local node cn2
		    		vec11(1) = nnStart	! Node nds1
		    		vec11(2) = ib 
		    		vec11(3) = ll
		    		vec11(4) = iii
		    		vec11(5) = jjc
		    		vec11(6) = kkc
		    		vec11(8) = 11 ! lets ge dudz values
		    		!
		    		! lets obtain velocity component dudz at local node cn3
		    		vec13m(1) = nnStart	! Node nds1
		    		vec13m(2) = ib 
		    		vec13m(3) = ll
		    		vec13m(4) = iiim
		    		vec13m(5) = jjcm
		    		vec13m(6) = kkcm
		    		vec13m(8) = 10 ! lets ge dudz values
		    		!
		    		! lets obtain velocity component dudx at local node cn3
		    		vec11m(1) = nnStart	! Node nds1
		    		vec11m(2) = ib 
		    		vec11m(3) = ll
		    		vec11m(4) = iiim
		    		vec11m(5) = jjcm
		    		vec11m(6) = kkcm
		    		vec11m(8) = 11 ! lets ge dudz values
		    		!
		    		! lets obtain velocity component dwdx at local node cn2
		    		vec31(1) = nnStart	! Node nds1
		    		vec31(2) = ib 
		    		vec31(3) = ll
		    		vec31(4) = iic 
		    		vec31(5) = jjc 
		    		vec31(6) = kkk
		    		vec31(8) = 12 ! lets get dwdx values
		    		!
		    		! lets obtain velocity component dwdz at local node cn2
		    		vec33(1) = nnStart	! Node nds1
		    		vec33(2) = ib 
		    		vec33(3) = ll
		    		vec33(4) = iic 
		    		vec33(5) = jjc 
		    		vec33(6) = kkk
		    		vec33(8) = 13 ! lets get dwdx values
		    		!
		    		! lets obtain velocity component dwdx at local node cn3
		    		vec31m(1) = nnStart	! Node nds1
		    		vec31m(2) = ib 
		    		vec31m(3) = ll
		    		vec31m(4) = iicm
		    		vec31m(5) = jjcm
		    		vec31m(6) = kkkm
		    		vec31m(8) = 12 ! lets get dwdx values
		    		!
		    		! lets obtain velocity component dwdz at local node cn3
		    		vec33m(1) = nnStart	! Node nds1
		    		vec33m(2) = ib 
		    		vec33m(3) = ll
		    		vec33m(4) = iicm
		    		vec33m(5) = jjcm
		    		vec33m(6) = kkkm
		    		vec33m(8) = 13 ! lets get dwdx values
		    		!
		    		! lets compute the spacing between cn2 and cn1
		    		ndslx = (ndsx(1) - ndsx(2))**2
		    		ndsly = (ndsy(1) - ndsy(2))**2
		    		ndslz = (ndsz(1) - ndsz(2))**2
					ndsl = sqrt(ndslx+ndsly+ndslz)
					!
					!
					!
					! ( 0, 90 ] First quadrant?
					if ( (ndsx(2) - ndsx(1)) .gt. -margin) then
						if ( (ndsz(2) - ndsz(1)) .gt. margin) then	! Proper way
							!
					tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
					betha1 = abs(DATAN(tanBetha1))*180/piNUm	! lets obtain betha1
							cosBetha1 = DCOS(betha1*piNUm/180)
							sinBetha1 = DSIN(betha1*piNUm/180)
							!
							vec1(7) = 1! qFlag = 1
							vec2(7) = 1! qFlag = 1
							mkx2 = ndsx(2) + yplus*sinBetha1
							mkz2 = ndsz(2) - yplus*cosBetha1
							call get_f(vec1,mkx2,mkz2,unn(2))
							call get_f(vec2,mkx2,mkz2,wnn(2))
							!
							vecm(7) = 1! qFlag = 1
							vecm2(7)= 1! qFlag = 1
							mkx3 = ndsx(3) + yplus*sinBetha1
							mkz3 = ndsz(3) - yplus*cosBetha1
							call get_f(vecm,mkx3,mkz3,unn(3))
							call get_f(vecm2,mkx3,mkz3,wnn(3))
							!
							dudn(2) = unn(2)*cosBetha1/yplus
							dwdn(2) = wnn(2)*sinBetha1/yplus
							!
							dudn(3) = unn(3)*cosBetha1/yplus
							dwdn(3) = wnn(3)*sinBetha1/yplus
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iicm,jjcm,kkcm)
							tao(2) = musgs(2)*(dudn(2) + dwdn(2))
							!
							musgs(3) = 1/Re !dom(ib)%mu(iicm,jjcm,kkcm)
							tao(3) = musgs(3)*(dudn(3) + dwdn(3))
							!
							! lets intehrates the shear stress along the surface using the trapezoid method
							txk = 0.5*(tao(1)+tao(2))*ndsl*dy_l ! shear stress force parallel to the surface
							txk = txk*cosBetha1 ! shear stress force parallel to OX axis
							!
							! lets intehrates the shear stress along the surface using Simpsom's method
							txk2 = (tao(1)+4*(tao(3))+tao(2))/6
							txk2 = txk2*ndsl*dy_l*cosBetha1
							!
							tzk = 0.5*(tao(1)+tao(2))
							tzk = tzk*ndsl*dy_l*sinBetha1
							!
							tzk2 = (tao(1)+4*(tao(3))+tao(2))/6
							tzk2 = tzk2*ndsl*dy_l*sinBetha1
							!
							vec13(7)  = 1! qFlag = 1
							vec11(7)  = 1! qFlag = 1
							vec33(7)  = 1! qFlag = 1
							vec31(7)  = 1! qFlag = 1
							vec13m(7) = 1! qFlag = 1
							vec11m(7) = 1! qFlag = 1
							vec33m(7) = 1! qFlag = 1
							vec31m(7) = 1! qFlag = 1
							call get_f(vec13,ndsx(2),ndsz(2),du_dz(2))
							call get_f(vec11,ndsx(2),ndsz(2),du_dx(2))
							call get_f(vec13m,ndsx(3),ndsz(3),du_dz(3))
							call get_f(vec11m,ndsx(3),ndsz(3),du_dx(3))
							call get_f(vec31,ndsx(2),ndsz(2),dw_dx(2))
							call get_f(vec33,ndsx(2),ndsz(2),dw_dz(2))
							call get_f(vec31m,ndsx(3),ndsz(3),dw_dx(3))
							call get_f(vec33m,ndsx(3),ndsz(3),dw_dz(3))
							!
!										factor2 = cosBetha1*sinBetha1
!							dudn2(2) = + du_dx(2)*cosBetha1*factor2 
! &                                     - du_dz(2)*cosBetha1*factor2
!							dwdn2(2) = + dw_dx(2)*sinBetha1*factor2
! &                                     - dw_dz(2)*sinBetha1*factor2
!							dudn2(3) = + du_dx(3)*cosBetha1*factor2 
! &                                     - du_dz(3)*cosBetha1*factor2
!							dwdn2(3) = + dw_dx(3)*sinBetha1*factor2
! &                                     - dw_dz(3)*sinBetha1*factor2

!                            dudn2(2) = sqrt( (du_dx(2)*cosBetha1)**2 
! &                                     + (du_dz(2)*cosBetha1)**2 )
!                            dwdn2(2) = sqrt( (dw_dx(2)*sinBetha1)**2
! &                                     + (dw_dz(2)*sinBetha1)**2)
!                            dudn2(3) = sqrt( (du_dx(3)*cosBetha1)**2 
! &                                     + (du_dz(3)*cosBetha1)**2 )
!                            dwdn2(3) = sqrt( (dw_dx(3)*sinBetha1)**2
! &                                     + (dw_dz(3)*sinBetha1)**2)
							v1(1) = sinBetha1
							v1(2) = 0.0d0
							v1(3) = -cosBetha1
							v2(1) = du_dx(2)*cosBetha1
							v2(2) = 0.0d0
							v2(3) = du_dz(2)*cosBetha1 
					dudn2(2) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2(1) = dw_dx(2)*sinBetha1
							v2(2) = 0.0d00
							v2(3) = dw_dz(2)*sinBetha1
					dwdn2(2) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2m(1) = du_dx(3)*cosBetha1
							v2m(2) = 0.0d0
							v2m(3) = du_dz(3)*cosBetha1 
					dudn2(3) =  v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							v2m(1) = dw_dx(3)*sinBetha1
							v2m(2) = 0.0d00
							v2m(3) = dw_dz(3)*sinBetha1
					dwdn2(3) = v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)


							 !
							tao2(2) = musgs(2)*(dudn2(2) + dwdn2(2))
							tao2(3) = musgs(3)*(dudn2(3) + dwdn2(3))
							!
							txk3 = 0.5*(tao2(1)+tao2(2))*ndsl*dy_l ! shear stress force parallel to the surface
							txk3 = txk3*cosBetha1 ! shear stress force parallel to OX axis
							txk4 = (tao2(1)+4*(tao2(3))+tao(2))/6
							txk4 = txk4*ndsl*dy_l*cosBetha1
							tzk3 = 0.5*(tao2(1)+tao2(2))
							tzk3 = tzk3*ndsl*dy_l*sinBetha1
							tzk4 = (tao2(1)+4*(tao2(3))+tao(2))/6
							tzk4 = tzk4*ndsl*dy_l*sinBetha1
							!
						endif
						endif
						! ( 90, 180 ] 2nd quadrant?
						if ( (ndsx(2) - ndsx(1)) .le. -margin) then
						if ( (ndsz(2) - ndsz(1)) .ge. -margin) then
					tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
					betha1 = abs(DATAN(tanBetha1))*180/piNUm	
							cosBetha1 = DCOS(betha1*piNUm/180)
							sinBetha1 = DSIN(betha1*piNUm/180)
							vec1(7) = 2! qFlag = 1
							vecm(7) = 2! qFlag = 1
							vec2(7) = 2! qFlag = 1
							vecm2(7)= 2! qFlag = 1
							mkx2 = ndsx(2) + yplus*sinBetha1
							mkz2 = ndsz(2) + yplus*cosBetha1
							mkx3 = ndsx(3) + yplus*sinBetha1
							mkz3 = ndsz(3) + yplus*cosBetha1
							call get_f(vec1,mkx2,mkz2,unn(2))
							call get_f(vecm,mkx3,mkz3,unn(3))
							call get_f(vec2,mkx2,mkz2,wnn(2))
							call get_f(vecm2,mkx3,mkz3,wnn(3))
							!
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							dudn(2) = unn(2)*cosBetha1/yplus    
							dwdn(2) = - wnn(2)*sinBetha1/yplus
							tao(2) = musgs(2)*(dudn(2) + dwdn(2))
							! warning : check this
							musgs(3) = 1/Re !dom(ib)%mu(iicm,jjcm,kkcm)
							dudn(3) = unn(3)*cosBetha1/yplus    
							dwdn(3) = - wnn(3)*sinBetha1/yplus
							tao(3) = musgs(3)*(dudn(3) + dwdn(3))
							!
							txk = 0.5*(tao(1)+tao(2))
							txk = txk*ndsl*dy_l*cosBetha1
							!
							txk2 = (tao(1)+4*(tao(3))+tao(2))/6
							txk2 = txk2*ndsl*dy_l*cosBetha1
							!
							tzk = 0.5*(tao(1)+tao(2))
							tzk = - tzk*ndsl*dy_l*sinBetha1
							!
							tzk2 = (tao(1)+4*(tao(3))+tao(2))/6
							tzk2 = - tzk2*ndsl*dy_l*sinBetha1
							!
							vec13(7)  = 2
							vec11(7)  = 2
							vec33(7)  = 2
							vec31(7)  = 2
							vec13m(7) = 2
							vec11m(7) = 2
							vec33m(7) = 2
							vec31m(7) = 2
							call get_f(vec13,ndsx(2),ndsz(2),du_dz(2))
							call get_f(vec11,ndsx(2),ndsz(2),du_dx(2))
							call get_f(vec13m,ndsx(3),ndsz(3),du_dz(3))
							call get_f(vec11m,ndsx(3),ndsz(3),du_dx(3))
							call get_f(vec31,ndsx(2),ndsz(2),dw_dx(2))
							call get_f(vec33,ndsx(2),ndsz(2),dw_dz(2))
							call get_f(vec31m,ndsx(3),ndsz(3),dw_dx(3))
							call get_f(vec33m,ndsx(3),ndsz(3),dw_dz(3))
							!
							factor2 = cosBetha1*sinBetha1
!								dudn2(2) = + du_dx(2)*cosBetha1*factor2 
!   &                                     - du_dz(2)*cosBetha1*factor2
!  							dwdn2(2) = - dw_dx(2)*sinBetha1*factor2
!   &                                     + dw_dz(2)*sinBetha1*factor2
!  							dudn2(3) = + du_dx(3)*cosBetha1*factor2 
!   &                                     - du_dz(3)*cosBetha1*factor2
!  							dwdn2(3) = - dw_dx(3)*sinBetha1*factor2
!   &                                     + dw_dz(3)*sinBetha1*factor2

!                              dudn2(2) = sqrt( (du_dx(2)*cosBetha1)**2 
!   &                                     + (du_dz(2)*cosBetha1)**2 )
!                              dwdn2(2) = sqrt( (dw_dx(2)*sinBetha1)**2
!   &                                     + (dw_dz(2)*sinBetha1)**2)
!                              dudn2(3) = sqrt( (du_dx(3)*cosBetha1)**2 
!   &                                     + (du_dz(3)*cosBetha1)**2 )
!                              dwdn2(3) = sqrt( (dw_dx(3)*sinBetha1)**2
!   &                                     + (dw_dz(3)*sinBetha1)**2)

							v1(1) = sinBetha1
							v1(2) = 0.0d0
							v1(3) = cosBetha1
							v2(1) = du_dx(2)*cosBetha1
							v2(2) = 0.0d0
							v2(3) = du_dz(2)*cosBetha1 
					dudn2(2) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2(1) = -dw_dx(2)*sinBetha1
							v2(2) = 0.0d00
							v2(3) = -dw_dz(2)*sinBetha1
					dwdn2(2) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2m(1) = du_dx(3)*cosBetha1
							v2m(2) = 0.0d0
							v2m(3) = du_dz(3)*cosBetha1 
					dudn2(3) =  v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							v2m(1) = -dw_dx(3)*sinBetha1
							v2m(2) = 0.0d00
							v2m(3) = -dw_dz(3)*sinBetha1
					dwdn2(3) = v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)

							!
							tao2(2) = musgs(2)*(dudn2(2) + dwdn2(2))
							tao2(3) = musgs(3)*(dudn2(3) + dwdn2(3))
							!
							txk3 = 0.5*(tao2(1)+tao2(2))*ndsl*dy_l ! shear stress force parallel to the surface
							txk3 = txk3*cosBetha1 ! shear stress force parallel to OX axis
							txk4 = (tao2(1)+4*(tao2(3))+tao(2))/6
							txk4 = txk4*ndsl*dy_l*cosBetha1
							tzk3 = 0.5*(tao2(1)+tao2(2))
							tzk3 = - tzk3*ndsl*dy_l*sinBetha1
							tzk4 = (tao2(1)+4*(tao2(3))+tao(2))/6
							tzk4 = - tzk4*ndsl*dy_l*sinBetha1
							!
						endif
						endif
						! ( 180, 270 ] 3rd quadrant?
						if ( (ndsx(2) - ndsx(1)) .le. margin) then
						if ( (ndsz(2) - ndsz(1)) .lt. -margin) then
					tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
					betha1 = abs(DATAN(tanBetha1))*180/piNUm	
							cosBetha1 = DCOS(betha1*piNUm/180)
							sinBetha1 = DSIN(betha1*piNUm/180)
							vec1(7) = 3! qFlag = 1
							vecm(7) = 3! qFlag = 1
							vec2(7) = 3! qFlag = 1
							vecm2(7)= 3! qFlag = 1
							mkx2 = ndsx(2) - yplus*sinBetha1
							mkz2 = ndsz(2) + yplus*cosBetha1
							mkx3 = ndsx(3) - yplus*sinBetha1
							mkz3 = ndsz(3) + yplus*cosBetha1
							call get_f(vec1,mkx2,mkz2,unn(2))
							call get_f(vecm,mkx3,mkz3,unn(3))
							call get_f(vec2,mkx2,mkz2,wnn(2))
							call get_f(vecm2,mkx3,mkz3,wnn(3))
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							dudn(2) = unn(2)*cosBetha1/yplus    
							dwdn(2) = wnn(2)*sinBetha1/yplus
							tao(2) = musgs(2)*(dudn(2) + dwdn(2))
							! warning : check this
							musgs(3) = 1/Re !dom(ib)%mu(iicm,jjcm,kkcm)
							dudn(3) = unn(3)*cosBetha1/yplus    
							dwdn(3) = wnn(3)*sinBetha1/yplus
							tao(3) = musgs(3)*(dudn(3) + dwdn(3))
							!
							txk = 0.5*(tao(1)+tao(2))
							txk = txk*ndsl*dy_l*cosBetha1
							!
							txk2 = (tao(1)+4*(tao(3))+tao(2))/6
							txk2 = txk2*ndsl*dy_l*cosBetha1
							!
							tzk = 0.5*(tao(1)+tao(2))
							tzk = tzk*ndsl*dy_l*sinBetha1
							!
							tzk2 = (tao(1)+4*(tao(3))+tao(2))/6
							tzk2 = tzk2*ndsl*dy_l*sinBetha1
							!
							vec13(7)  = 3
							vec11(7)  = 3
							vec33(7)  = 3
							vec31(7)  = 3
							vec13m(7) = 3
							vec11m(7) = 3
							vec33m(7) = 3
							vec31m(7) = 3
							call get_f(vec13,ndsx(2),ndsz(2),du_dz(2))
							call get_f(vec11,ndsx(2),ndsz(2),du_dx(2))
							call get_f(vec13m,ndsx(3),ndsz(3),du_dz(3))
							call get_f(vec11m,ndsx(3),ndsz(3),du_dx(3))
							call get_f(vec31,ndsx(2),ndsz(2),dw_dx(2))
							call get_f(vec33,ndsx(2),ndsz(2),dw_dz(2))
							call get_f(vec31m,ndsx(3),ndsz(3),dw_dx(3))
							call get_f(vec33m,ndsx(3),ndsz(3),dw_dz(3))
							!
							factor2 = cosBetha1*sinBetha1
!							dudn2(2) = - du_dx(2)*cosBetha1*factor2 
! &                                     + du_dz(2)*cosBetha1*factor2
!							dwdn2(2) = - dw_dx(2)*sinBetha1*factor2
! &                                     + dw_dz(2)*sinBetha1*factor2
!							dudn2(3) = - du_dx(3)*cosBetha1*factor2 
! &                                     + du_dz(3)*cosBetha1*factor2
!							dwdn2(3) = - dw_dx(3)*sinBetha1*factor2
! &                                     + dw_dz(3)*sinBetha1*factor2
!                             dudn2(2) = sqrt( (du_dx(2)*cosBetha1)**2 
!  &                                     + (du_dz(2)*cosBetha1)**2 )
!                             dwdn2(2) = sqrt( (dw_dx(2)*sinBetha1)**2
!  &                                     + (dw_dz(2)*sinBetha1)**2)
!                             dudn2(3) = sqrt( (du_dx(3)*cosBetha1)**2 
!  &                                     + (du_dz(3)*cosBetha1)**2 )
!                             dwdn2(3) = sqrt( (dw_dx(3)*sinBetha1)**2
!  &                                     + (dw_dz(3)*sinBetha1)**2)
						v1(1) = -sinBetha1
						v1(2) = 0.0d0
						v1(3) = cosBetha1
						v2(1) = du_dx(2)*cosBetha1
						v2(2) = 0.0d0
						v2(3) = du_dz(2)*cosBetha1 
				dudn2(2) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
						v2(1) = dw_dx(2)*sinBetha1
						v2(2) = 0.0d00
						v2(3) = dw_dz(2)*sinBetha1
				dwdn2(2) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
						v2m(1) = du_dx(3)*cosBetha1
						v2m(2) = 0.0d0
						v2m(3) = du_dz(3)*cosBetha1 
				dudn2(3) =  v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
						v2m(1) = 0.0d00 !dw_dx(3)*sinBetha1
						v2m(2) = 0.0d00
						v2m(3) = 0.0d00 !dw_dz(3)*sinBetha1
				dwdn2(3) = v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							 !
							tao2(2) = musgs(2)*(dudn2(2) + dwdn2(2))
							tao2(3) = musgs(3)*(dudn2(3) + dwdn2(3))
							!
							txk3 = 0.5*(tao2(1)+tao2(2))*ndsl*dy_l ! shear stress force parallel to the surface
							txk3 = txk3*cosBetha1 ! shear stress force parallel to OX axis
							txk4 = (tao2(1)+4*(tao2(3))+tao(2))/6
							txk4 = txk4*ndsl*dy_l*cosBetha1
							tzk3 = 0.5*(tao2(1)+tao2(2))
							tzk3 = tzk3*ndsl*dy_l*sinBetha1
							tzk4 = (tao2(1)+4*(tao2(3))+tao(2))/6
							tzk4 = tzk4*ndsl*dy_l*sinBetha1
							!
						endif
						endif
						! ( 270, 360 ] 4th quadrant?
						if ( (ndsx(2) - ndsx(1)) .gt. margin) then
						if ( (ndsz(2) - ndsz(1)) .le. margin) then
					tanBetha1 = (ndsz(2)-ndsz(1))/(ndsx(2)-ndsx(1))
					betha1 = abs(DATAN(tanBetha1))*180/piNUm	
							cosBetha1 = DCOS(betha1*piNUm/180)
							sinBetha1 = DSIN(betha1*piNUm/180)
							vec1(7) = 4! qFlag = 1
							vecm(7) = 4! qFlag = 1
							vec2(7) = 4! qFlag = 1
							vecm2(7)= 4! qFlag = 1
							mkx2 = ndsx(2) - yplus*sinBetha1
							mkz2 = ndsz(2) - yplus*cosBetha1
							mkx3 = ndsx(3) - yplus*sinBetha1
							mkz3 = ndsz(3) - yplus*cosBetha1
							call get_f(vec1,mkx2,mkz2,unn(2))
							call get_f(vecm,mkx3,mkz3,unn(3))
							call get_f(vec2,mkx2,mkz2,wnn(2))
							call get_f(vecm2,mkx3,mkz3,wnn(3))
							! warning : check this
							musgs(2) = 1/Re !dom(ib)%mu(iic,jjc,kkc)
							dudn(2) = unn(2)*cosBetha1/yplus    
							dwdn(2) = - wnn(2)*sinBetha1/yplus
							tao(2) = musgs(2)*(dudn(2) + dwdn(2))
							! warning : check this
							musgs(3) = 1/Re !dom(ib)%mu(iicm,jjcm,kkcm)
							dudn(3) = unn(3)*cosBetha1/yplus    
							dwdn(3) = - wnn(3)*sinBetha1/yplus
							tao(3) = musgs(3)*(dudn(3) + dwdn(3))
							!
							txk = 0.5*(tao(1)+tao(2))
							txk = txk*ndsl*dy_l*cosBetha1
							!
							txk2 = (tao(1)+4*(tao(3))+tao(2))/6
							txk2 = txk2*ndsl*dy_l*cosBetha1
							!
							tzk = 0.5*(tao(1)+tao(2))
							tzk = - tzk*ndsl*dy_l*sinBetha1
							!
							tzk2 = (tao(1)+4*(tao(3))+tao(2))/6
							tzk2 = - tzk2*ndsl*dy_l*sinBetha1
							!
							vec13(7)  = 4
							vec11(7)  = 4
							vec33(7)  = 4
							vec31(7)  = 4
							vec13m(7) = 4
							vec11m(7) = 4
							vec33m(7) = 4
							vec31m(7) = 4
							call get_f(vec13,ndsx(2),ndsz(2),du_dz(2))
							call get_f(vec11,ndsx(2),ndsz(2),du_dx(2))
							call get_f(vec13m,ndsx(3),ndsz(3),du_dz(3))
							call get_f(vec11m,ndsx(3),ndsz(3),du_dx(3))
							call get_f(vec31,ndsx(2),ndsz(2),dw_dx(2))
							call get_f(vec33,ndsx(2),ndsz(2),dw_dz(2))
							call get_f(vec31m,ndsx(3),ndsz(3),dw_dx(3))
							call get_f(vec33m,ndsx(3),ndsz(3),dw_dz(3))
							!
							factor2 = cosBetha1*sinBetha1
!							dudn2(2) = - du_dx(2)*cosBetha1*factor2 
! &                                     + du_dz(2)*cosBetha1*factor2
!							dwdn2(2) = + dw_dx(2)*sinBetha1*factor2
! &                                     - dw_dz(2)*sinBetha1*factor2
!							dudn2(3) = - du_dx(3)*cosBetha1*factor2 
! &                                     + du_dz(3)*cosBetha1*factor2
!							dwdn2(3) = + dw_dx(3)*sinBetha1*factor2
! &                                     - dw_dz(3)*sinBetha1*factor2
!                            dudn2(2) = sqrt( (du_dx(2)*cosBetha1)**2 
! &                                     + (du_dz(2)*cosBetha1)**2 )
!                            dwdn2(2) = sqrt( (dw_dx(2)*sinBetha1)**2
! &                                     + (dw_dz(2)*sinBetha1)**2)
!                            dudn2(3) = sqrt( (du_dx(3)*cosBetha1)**2 
! &                                     + (du_dz(3)*cosBetha1)**2 )
!                            dwdn2(3) = sqrt( (dw_dx(3)*sinBetha1)**2
! &                                     + (dw_dz(3)*sinBetha1)**2)
							v1(1) = -sinBetha1
							v1(2) = 0.0d0
							v1(3) = -cosBetha1
							v2(1) = du_dx(2)*cosBetha1
							v2(2) = 0.0d0
							v2(3) = du_dz(2)*cosBetha1 
					dudn2(2) =  v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2(1) = -dw_dx(2)*sinBetha1
							v2(2) = 0.0d00
							v2(3) = -dw_dz(2)*sinBetha1
					dwdn2(2) = v1(1)*v2(1)+v1(2)*v2(2)+v1(3)*v2(3) !dot_product(v1,v2)
							v2m(1) = du_dx(3)*cosBetha1
							v2m(2) = 0.0d0
							v2m(3) = du_dz(3)*cosBetha1 
					dudn2(3) =  v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							v2m(1) = -dw_dx(3)*sinBetha1
							v2m(2) = 0.0d00
							v2m(3) = -dw_dz(3)*sinBetha1
					dwdn2(3) = v1(1)*v2m(1)+v1(2)*v2m(2)+v1(3)*v2m(3)!dot_product(v1,v2m)
							!
							tao2(2) = musgs(2)*(dudn2(2) + dwdn2(2))
							tao2(3) = musgs(3)*(dudn2(3) + dwdn2(3))
							!
							txk3 = 0.5*(tao2(1)+tao2(2))*ndsl*dy_l ! shear stress force parallel to the surface
							txk3 = txk3*cosBetha1 ! shear stress force parallel to OX axis
							txk4 = (tao2(1)+4*(tao2(3))+tao(2))/6
							txk4 = txk4*ndsl*dy_l*cosBetha1
							tzk3 = 0.5*(tao2(1)+tao2(2))
							tzk3 = - tzk3*ndsl*dy_l*sinBetha1
							tzk4 = (tao2(1)+4*(tao2(3))+tao(2))/6
							tzk4 = - tzk4*ndsl*dy_l*sinBetha1
							!
						endif
						endif
					!
					!
			 		if((nn.gt.9240).and.(nn.lt.10561)) then
			 			tempx = (ndsx(1) - 18.0d00)
			 			tempz = (ndsz(1) - 10.5d00)
			 			if (vec1(7).eq.3) then
			 	gamma1 = - DATAN(tempz/tempx)*180/piNUm
			 			elseif (vec1(7).eq.2) then
			 	gamma1 = 180 - DATAN(tempz/tempx)*180/piNUm
			 			elseif (vec1(7).eq.4) then
			 	gamma1 = - DATAN(tempz/tempx)*180/piNUm
			 			elseif (vec1(7).eq.1) then
			 	gamma1 = -180 - DATAN(tempz/tempx)*180/piNUm
			 			endif
						!
						tanBetha2 = (du_dz(2))/(du_dx(2))
						betha2 = abs(DATAN(tanBetha2))*180/piNUm	! lets obtain betha1
						tanBetha3 = (dw_dz(2))/(dw_dx(2))
						betha3 = abs(DATAN(tanBetha3))*180/piNUm	! lets obtain betha1
						!
						write(6,*) nn, gamma1, tao(1)*coef2
						write(93,87) nn, gamma1, tao(1)*coef2
						write(94,87) nn, gamma1, tao2(1)*coef2
				!write(6,*) gamma1, tao(1)*coef2, tao2(1)*coef2
						!write(6,*) gamma1, dudn(2), dudn2(2)
						!write(6,*) gamma1, dwdn(2), dwdn2(2)
	!		write(95,87) gamma1, abs(90-betha1), betha2, dudn(2), dudn2(2)
	! &,du_dz(2), du_dx(2), tao(1)*coef2, tao2(1)*coef2
		    write(95,87) v1(1), v1(3),v2(1), v2(3), sinBetha1, cosBetha1
		    write(95,87) gamma1, betha1, dudn(2), dudn2(2),du_dx(2), du_dz(2)
! &	du_dx(2)*cosBetha1,du_dz(2)*cosBetha1
! 								tanBetha2 = (dw_dz(2))/(dw_dx(2))
!								betha2 = abs(DATAN(tanBetha2))*180/piNUm	! lets obtain betha1
!		write(96,87) gamma1, abs(90-betha1), betha3, dwdn(2), dwdn2(2)
! &,dw_dz(2), dw_dx(2), tao(1)*coef2, tao2(1)*coef2
		    write(95,87) gamma1, betha1, dwdn(2), dwdn2(2),dw_dx(2), dw_dz(2)
! &	dw_dx(2)*cosBetha1,dw_dz(2)*cosBetha1
			!				write(6,*) pnn*coef2
			!	write(6,*) dom(ib)%u(iic, jjc, kkc), fxk, fzk
			!	write(6,*) dom(ib)%w(iic, jjc, kkc), fxk2, fzk2
					endif
					!
					!
					!
	   				if(nn.eq.15) then
	   					write(6,*) nn, iic, kkc
	   					write(6,*) tao*coef2
	   					write(6,*) unn
	   					write(6,*) wnn
	   		write(6,*) dom(ib)%u(iic, jjc, kkc), txk, tzk
	   		write(6,*) dom(ib)%w(iic, jjc, kkc), txk2, tzk2
	   				endif
	   				if(nn.eq.45) then
	   					write(6,*) nn, iic, kkc
	   					write(6,*) tao*coef2
	   					write(6,*) unn
	   					write(6,*) wnn
	   		write(6,*) dom(ib)%u(iic-1, jjc, kkc), txk, tzk
	   		write(6,*) dom(ib)%w(iic-1, jjc, kkc), txk2, tzk2
	   					endif
	   				if(nn.eq.62) then
	   					write(6,*) nn, iic, kkc
	   					write(6,*) tao*coef2
	   					write(6,*) unn
	   					write(6,*) wnn
	   		write(6,*) dom(ib)%u(iic-1, jjc, kkc), txk, tzk
	   		write(6,*) dom(ib)%w(iic-1, jjc, kkc), txk2, tzk2
	   				endif
	   				if(nn.eq.77) then
	   					write(6,*) nn, iic, kkc
	   					write(6,*) tao*coef2
	   					write(6,*) unn
	   					write(6,*) wnn
	   	write(6,*) dom(ib)%u(iic-1, jjc, kkc-1), txk, tzk
	   	write(6,*) dom(ib)%w(iic-1, jjc, kkc-1), txk2, tzk2
	   				endif
	   				if(nn.eq.105) then
	   					write(6,*) nn, iic, kkc
	   					write(6,*) tao*coef2
	   					write(6,*) unn
	   					write(6,*) wnn
	   	write(6,*) dom(ib)%u(iic, jjc, kkc-1), txk, tzk
	   	write(6,*) dom(ib)%w(iic, jjc, kkc-1), txk2, tzk2
	   				endif
	   				if(nn.eq.126) then
	   					write(6,*) nn, iic, kkc
	   					write(6,*) tao*coef2
	   					write(6,*) unn
	   					write(6,*) wnn
	   		write(6,*) dom(ib)%u(iic, jjc, kkc), txk, tzk
	   		write(6,*) dom(ib)%w(iic, jjc, kkc), txk2, tzk2
	   				endif
					!
					!
		        	!
		        	!	! check !!!
		        	txVecSt(M,mm)  = txVecSt(M,mm)  + txk 
		        	tzVecSt(M,mm)  = tzVecSt(M,mm)  + tzk
		        	txVecSt2(M,mm) = txVecSt2(M,mm) + txk2 
		        	tzVecSt2(M,mm) = tzVecSt2(M,mm) + tzk2
		        	txVecSt3(M,mm) = txVecSt3(M,mm) + txk3 
		        	tzVecSt3(M,mm) = tzVecSt3(M,mm) + tzk3
		        	txVecSt4(M,mm) = txVecSt4(M,mm) + txk4 
		        	tzVecSt4(M,mm) = tzVecSt4(M,mm) + tzk4
					!
		        	!
					! Update of unn(1)
					unn(1)   = unn(2)
					wnn(1)   = wnn(2)
					tao(1)   = tao(2)
					du_dz(1) = du_dz(2)
					du_dx(1) = du_dx(2)
					dw_dz(1) = dw_dz(2)
					dw_dx(1) = dw_dx(2)
					tao2(1)  = tao2(2)
		    		!
		    		!
					!
				  else
					ll = 2
				  endif! Filtering interior layers
				  !
				 endif	! Ensuring processor ID matches subdomain ID???
				 !
			    enddo	!  sweeping markers of each station
				!
				!
				!
				!
				!
				!		! check !!!
				if ( (mm.eq.1).or.(mm.eq.St_k) )then
					txVecSt(M,mm) = 0.5*txVecSt(M,mm)
					txVecSt2(M,mm) = 0.5*txVecSt2(M,mm)
					tzVecSt(M,mm)  = 0.5*tzVecSt(M,mm)
					tzVecSt2(M,mm) = 0.5*tzVecSt2(M,mm)
					!
					txVecSt3(M,mm) = 0.5*txVecSt3(M,mm)
					txVecSt4(M,mm) = 0.5*txVecSt4(M,mm)
					tzVecSt3(M,mm) = 0.5*tzVecSt3(M,mm)
					tzVecSt4(M,mm) = 0.5*tzVecSt4(M,mm)
					!write(6,*) mm, txVecSt(M,mm), txVecSt2(M,mm)
				endif
				!
				tx(M)  = tx(M)  + txVecSt(M,mm)
				tz(M)  = tz(M)  + tzVecSt(M,mm)
				tx2(M) = tx2(M) + txVecSt2(M,mm)
				tz2(M) = tz2(M) + tzVecSt2(M,mm)
				tx3(M) = tx3(M) + txVecSt3(M,mm)
				tz3(M) = tz3(M) + tzVecSt3(M,mm)
				tx4(M) = tx4(M) + txVecSt4(M,mm)
				tz4(M) = tz4(M) + tzVecSt4(M,mm)
				!
				!
				!
			  enddo	! sweeping stations
			  !
			  !
			  DEALLOCATE(txVecSt,tzVecSt)
			  DEALLOCATE(txVecSt2,tzVecSt2)
			  DEALLOCATE(txVecSt3,tzVecSt3)
			  DEALLOCATE(txVecSt4,tzVecSt4)
			  !
		      !
		      !
			  !sh1(1) = tx2(M)
			  !sh1(2) = 0.0d0
			  !sh1(3) = tz2(M)
			  shout(1) = tx2(M)
			  shout(2) = 0.0d0
			  shout(3) = tz2(M)
			  !
			  tcdx(M) = coef1*tx(M) 
			  tcdz(M) = coef1*tz(M)
			  tcdx2(M) = coef1*tx2(M) 
			  tcdz2(M) = coef1*tz2(M)
			  tcdx3(M) = coef1*tx3(M) 
			  tcdz3(M) = coef1*tz3(M)
			  tcdx4(M) = coef1*tx4(M) 
			  tcdz4(M) = coef1*tz4(M)
			  write(6,*) "tx", tx(M), tx2(M)
			  write(6,*) "tcdx", tcdx(M), tcdx2(M)
			  write(6,*) "tz", tz(M), tz2(M)
			  write(6,*) "tcdz", tcdz(M), tcdz2(M)
			  !
			  write(6,*) "tx", tx3(M), tx4(M)
			  write(6,*) "tcdx", tcdx3(M), tcdx4(M)
			  write(6,*) "tz", tz3(M), tz4(M)
			  write(6,*) "tcdz", tcdz3(M), tcdz4(M)
			  !
			  !
	        endif ! Filtering out procesors
		    !
		   enddo ! End of the  loop sweeping the domains
		   !
		   !
		   !
	    enddo ! end of the loop sweeping the bodies
	!endif ! the master processor reliquishes control

	    DEALLOCATE(tcdx, tcdz)
	    DEALLOCATE(tx, tz )
	    DEALLOCATE(tcdx2, tcdz2)
	    DEALLOCATE(tx2, tz2 )
	    DEALLOCATE(tx3, tz3 )
	    DEALLOCATE(tx4, tz4 )
	    DEALLOCATE(tcdx3, tcdz3)
	    DEALLOCATE(tcdx4, tcdz4)
	    !
	    !
	    close(93)
	    close(94)
	    close(95)
	    close(96)

!######################################################################		
	END SUBROUTINE shearStressProbe
!######################################################################	 

!######################################################################
	SUBROUTINE get_f(vec1,ndsx,ndsz,unn)
!######################################################################

        ! Function for obtaining one of the following filed values, u, v, w, p; 
        ! anywhere in the control volume, using interpolation.

				use imb
				use mpi
				use multidata

				implicit none

				! temporal variables
				DOUBLE PRECISION:: temp

				! Input valriables
				INTEGER, INTENT(IN):: vec1(8)
				DOUBLE PRECISION, INTENT(IN):: ndsx, ndsz
				! Location of cell face center of ghost cell 

				! Output variables
				DOUBLE PRECISION, INTENT(OUT):: unn
				! unn:  Pressure in the marker's location

				! Interfaces
				INTEGER:: nn, ib, ll, id, jd, kd, qF, fieldF

				! values for interpoation points
				DOUBLE PRECISION:: fvec(4) ! Pressure in the neighbouring fluid cells used in the interpolation scheme
				DOUBLE PRECISION:: nx(2), nz(2) ! Location of the interpolation points

				! intergace with interpolationF
				INTEGER:: vec2(8)
				DOUBLE PRECISION:: vec3(3)


			!	if (myrank.eq. master ) then ! The control is passed down to the master processor


				nn     = vec1(1)
				ib     = vec1(2)
				ll     = vec1(3)
				id     = vec1(4)
				jd     = vec1(5)
				kd     = vec1(6)
				qF     = vec1(7) ! this is defined in a finction later
                fieldF = vec1(8) ! flag for indicating which field to work with

				if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
					! markers are located

					IF(imb_block_loc(nn).eq.dom_id(ib)) then ! Ensuring processor ID matches subdomain ID???


                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				!!! BILINEAR INTERPOLATION
                   if (fieldF.eq.1) then
		       	 fvec(1) = dom(ib)%u(id-1,jd,kd-1) ! q11
		       	 fvec(2) = dom(ib)%u(id,jd,kd-1)   ! q21
		       	 fvec(3) = dom(ib)%u(id-1,jd,kd)   ! q12
                    fvec(4) = dom(ib)%u(id,jd,kd)	   ! q22
		       	 !fvec(5) = dom(ib)%u(id-1,jd-1,kd-1) ! q11
		       	 !fvec(6) = dom(ib)%u(id,jd-1,kd-1)   ! q21
		       	 !fvec(7) = dom(ib)%u(id-1,jd-1,kd)   ! q12
		       	 !fvec(8) = dom(ib)%u(id,jd-1,kd)	   ! q22
		       	 nx(1) = dom(ib)%x(id-1)
		       	 nx(2) = dom(ib)%x(id)
		       	 nz(1) = dom(ib)%zc(kd-1)
                    nz(2) = dom(ib)%zc(kd)
		       	 !ny(1) = dom(ib)%yc(id)
		       	 !ny(2) = dom(ib)%yc(id-1)
                   elseif(fieldF.eq.2) then
		       	 fvec(1) = dom(ib)%v(id-1,jd,kd-1) ! q11
		       	 fvec(2) = dom(ib)%v(id,jd,kd-1)   ! q21
		       	 fvec(3) = dom(ib)%v(id-1,jd,kd)   ! q12
                    fvec(4) = dom(ib)%v(id,jd,kd)	   ! q22
		       	 !fvec(5) = dom(ib)%v(id-1,jd-1,kd-1) ! q11
		       	 !fvec(6) = dom(ib)%v(id,jd-1,kd-1)   ! q21
		       	 !fvec(7) = dom(ib)%v(id-1,jd-1,kd)   ! q12
		       	 !fvec(8) = dom(ib)%v(id,jd-1,kd)	   ! q22
		       	 nx(1) = dom(ib)%xc(id-1)
		       	 nx(2) = dom(ib)%xc(id)
		       	 nz(1) = dom(ib)%zc(kd-1)
                    nz(2) = dom(ib)%zc(kd)
		       	 !ny(1) = dom(ib)%y(id)
		       	 !ny(2) = dom(ib)%y(id-1)
                   elseif(fieldF.eq.3) then
		       	 fvec(1) = dom(ib)%w(id-1,jd,kd-1) ! q11
		       	 fvec(2) = dom(ib)%w(id,jd,kd-1)   ! q21
		       	 fvec(3) = dom(ib)%w(id-1,jd,kd)   ! q12
                    fvec(4) = dom(ib)%w(id,jd,kd)	   ! q22
		       	 !fvec(5) = dom(ib)%w(id-1,jd-1,kd-1) ! q11
		       	 !fvec(6) = dom(ib)%w(id,jd-1,kd-1)   ! q21
		       	 !fvec(7) = dom(ib)%w(id-1,jd-1,kd)   ! q12
		       	 !fvec(8) = dom(ib)%w(id,jd-1,kd)	   ! q22
		       	 nx(1) = dom(ib)%xc(id-1)
		       	 nx(2) = dom(ib)%xc(id)
		       	 nz(1) = dom(ib)%z(kd-1)
		       	 nz(2) = dom(ib)%z(kd)
		       	 !ny(1) = dom(ib)%yc(id)
			   	 !ny(2) = dom(ib)%yc(id-1)
		     elseif(fieldF.eq.4) then
             	!elseif(fieldF.eq.4) then
			 	fvec(1) = dom(ib)%p(id-1,jd,kd-1) ! q11
			 	fvec(2) = dom(ib)%p(id,jd,kd-1)   ! q21
			 	fvec(3) = dom(ib)%p(id-1,jd,kd)   ! q12
			 	fvec(4) = dom(ib)%p(id,jd,kd)	   ! q22
			 	!fvec(5) = dom(ib)%p(id-1,jd-1,kd-1) ! q11
			 	!fvec(6) = dom(ib)%p(id,jd-1,kd-1)   ! q21
			 	!fvec(7) = dom(ib)%p(id-1,jd-1,kd)   ! q12
			 	!fvec(8) = dom(ib)%p(id,jd-1,kd)	   ! q22
             	nx(1) = dom(ib)%xc(id-1)
			 	nx(2) = dom(ib)%xc(id)
			 	nz(1) = dom(ib)%zc(kd-1)
			 	nz(2) = dom(ib)%zc(kd)
			 	!ny(1) = dom(ib)%yc(id)
			 	!ny(2) = dom(ib)%yc(id-1)
             elseif(fieldF.eq.10) then
				fvec(1) = dom(ib)%dudx(id-1,jd,kd-1) ! q11
				fvec(2) = dom(ib)%dudx(id,jd,kd-1)   ! q21
				fvec(3) = dom(ib)%dudx(id-1,jd,kd)   ! q12
				fvec(4) = dom(ib)%dudx(id,jd,kd)	   ! q22
				nx(1) = dom(ib)%xc(id-1)
				nx(2) = dom(ib)%xc(id)
				nz(1) = dom(ib)%zc(kd-1)
				nz(2) = dom(ib)%zc(kd)
				!ny(1) = dom(ib)%yc(id)
				!ny(2) = dom(ib)%yc(id-1)
				!write(6,*) dom(ib)%dudx(id,jd,kd)
             elseif(fieldF.eq.11) then
				fvec(1) = dom(ib)%dudz(id-1,jd,kd-1) ! q11
				fvec(2) = dom(ib)%dudz(id,jd,kd-1)   ! q21
				fvec(3) = dom(ib)%dudz(id-1,jd,kd)   ! q12
				fvec(4) = dom(ib)%dudz(id,jd,kd)	   ! q22
				nx(1) = dom(ib)%xc(id-1)
				nx(2) = dom(ib)%xc(id)
				nz(1) = dom(ib)%zc(kd-1)
				nz(2) = dom(ib)%zc(kd)
				!ny(1) = dom(ib)%yc(id)
				!ny(2) = dom(ib)%yc(id-1)
             elseif(fieldF.eq.12) then
				fvec(1) = dom(ib)%dwdx(id-1,jd,kd-1) ! q11
				fvec(2) = dom(ib)%dwdx(id,jd,kd-1)   ! q21
				fvec(3) = dom(ib)%dwdx(id-1,jd,kd)   ! q12
				fvec(4) = dom(ib)%dwdx(id,jd,kd)	   ! q22
				nx(1) = dom(ib)%xc(id-1)
				nx(2) = dom(ib)%xc(id)
				nz(1) = dom(ib)%zc(kd-1)
				nz(2) = dom(ib)%zc(kd)
				!ny(1) = dom(ib)%yc(id)
				!ny(2) = dom(ib)%yc(id-1)
             elseif(fieldF.eq.13) then
				fvec(1) = dom(ib)%dwdz(id-1,jd,kd-1) ! q11
				fvec(2) = dom(ib)%dwdz(id,jd,kd-1)   ! q21
				fvec(3) = dom(ib)%dwdz(id-1,jd,kd)   ! q12
				fvec(4) = dom(ib)%dwdz(id,jd,kd)	   ! q22
				nx(1) = dom(ib)%xc(id-1)
				nx(2) = dom(ib)%xc(id)
				nz(1) = dom(ib)%zc(kd-1)
				nz(2) = dom(ib)%zc(kd)
				!ny(1) = dom(ib)%yc(id)
				!ny(2) = dom(ib)%yc(id-1)
            endif
	!		mirror_w = bilinear1(nn,nx,nz,fvec,mkx,mkz)
	!		if(nn.lt.127) then
	!			write(6,*) "Mirror w (Bilinear Interpolation: explicit)", nn, tx
	!		endif


			! Alternative (2nd order Least Squares & Cramer's solver)
	!		mirror_w = ls_2ndOrder_cramer(nn,nx,nz,fvec,mkx,mkz)
	!		if ( nn.lt.127 ) then
	!			write(6,*) "Mirror w (2nd order Least Squares: cramer)", nn, tx
	!		endif


			!!! LINEAR INTERPOLATION
			!mirror_w = l1(nn,nx,nz,fvec,mkx,mkz)
			!if(nn.lt.127) then
			!	write(6,*) "Mirror w (linear interpolation)",nn, tx
			!endif

			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			! Alternative (Least Squares & Cramer's solver)
			!mirror_w = ls_cramer(nn,nx,nz,fvec,mkx,mkz)
			!if(nn.lt.127) then
			!	write(6,*) "Mirror w (Least Squares: cramer)",nn, tx
			!endif

			! Alternative: Bilinear Interpoaltion and Cramer's solver
			if (fieldF.eq.1)  unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			!if (fieldF.eq.2)  unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.3)  unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.4)  unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.10) unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.11) unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.12) unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
			if (fieldF.eq.13) unn = bl_cramer(nn,nx,nz,fvec,ndsx,ndsz)
		!	if ( nn.lt.127 ) then
		!		write(6,*) "Mirror unn (Bilinear Interpolation: cramer)", nn, unn
		!		write(6,*) fvec 
		!		write(6,*) id, jd, kd
		!		write(6,*) ndsx
		!		write(6,*) ndsz
		!		write(6,*) dom(ib)%xc(id), dom(ib)%xc(id-1)
		!		write(6,*) dom(ib)%zc(kd), dom(ib)%zc(kd-1)
		!		write(6,*) "==="
		!		write(6,*)
		!	endif
			!
			!Alternative: deltaFUnction
			if ((fieldF.ge.1).and.(fieldF.le.3)) then
			vec2(1) = nn	! Node nds(1.5)
			vec2(2) = ib 
			vec2(3) = ll
			vec2(4) = id 
			vec2(5) = jd
			vec2(6) = kd
			vec2(7) = qF
			vec2(8) = fieldF ! fieldFlag for selecting u velocity
			!
			vec3(1) = ndsx	!mrx
			vec3(2) = dom(ib)%y(jd) ! dom(ib)%yc(jd)
			vec3(3) = ndsz	!mrz
			!
			!call interpolationF(vec2,vec3,unn)
			!
			endif
			
			endif	! Ensuring processor ID matches subdomain ID???

			!!! END MASTER PROCESOR
			!endif	

			endif ! Filtering out procesors

			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!!!!!!!!       FUNCTION DECLARATION       !!!!!!!!
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

			CONTAINS

			!######################################################################
			DOUBLE PRECISION FUNCTION bilinear1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: m1(2), m2(2,2), m3(2), m4(2)
			DOUBLE PRECISION:: factor1
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			
			factor1 = 1.0d00/( (x2-x1)*(z2-z1) )
							
			m1(1) = x2 - mrx
			m1(2) = mrx - x1
			
			m2(1,1) = q11	! First row, 1st column
			m2(2,1) = q12	! 1 st row, 2 nd column
			m2(1,2) = q21	! 2 nd row,	1 st column
			m2(2,2) = q22	! 2 nd row, 2 nd column
			
			m3(1) = z2 - mrz
			m3(2) = mrz - z1
			
			m4 = matmul(m1,m2)
			
			bilinear1 = factor1*dot_product(m3,m4)
			
			!######################################################################
			END FUNCTION bilinear1
			!######################################################################

			!######################################################################
			DOUBLE PRECISION FUNCTION bl_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Bilinear Interpolation using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: am1(4,4), am2(4,4), am3(4,4)
			DOUBLE PRECISION:: bm1(4), bm2(4),sol(4)
			
			
			
			! Bilinear Interpolation (explicit formulation)
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz
			
			am1(1,1) = 1; am1(2,1) = dx1; am1(3,1) = dz1; am1(4,1) = dx1*dz1
			am1(1,2) = 1; am1(2,2) = dx2; am1(3,2) = dz1; am1(4,2) = dx2*dz1
			am1(1,3) = 1; am1(2,3) = dx1; am1(3,3) = dz2; am1(4,3) = dx1*dz2
			am1(1,4) = 1; am1(2,4) = dx2; am1(3,4) = dz2; am1(4,4) = dx2*dz2
			am2 = TRANSPOSE(am1)
			bm1(1) = q11; bm1(2) = q21
			bm1(3) = q12; bm1(4) = q22
			bm2 = matmul(bm1,am2)
			am3 = matmul(am1,am2)
			
			call cramer_solver(sol,am3,bm2,4)
			
			bl_cramer = sol(1)
			
			!######################################################################
			END FUNCTION bl_cramer
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION ls_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(3,4), a2(4,3), a3(3,3)
			DOUBLE PRECISION:: b1(4), b2(3), sol(3)
			
			
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,3)
			
			ls_cramer = sol(1)
			
			!######################################################################
			END FUNCTION 
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION ls_2ndOrder_cramer(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################
			
			! Second order Least Squares Model using Cramer's solver
			
			
			implicit none
			
			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			
			DOUBLE PRECISION:: x1, x2, z1, z2
			DOUBLE PRECISION:: q11, q21, q12, q22
			DOUBLE PRECISION:: dx1, dx2, dz1, dz2
			DOUBLE PRECISION:: a1(6,4), a2(4,6), a3(6,6)
			DOUBLE PRECISION:: b1(4), b2(6), sol(6)
			
			
			q11 = uvec(1) !dom(ib)%u(id-1,jjj,kd-1)
			q21 = uvec(2) !dom(ib)%u(id,jjj,kd-1)
			q12 = uvec(3) !dom(ib)%u(id-1,jjj,kd)
			q22 = uvec(4) !dom(ib)%u(id,jjj,kd)
			
			x1 = nx(1)	!dom(ib)%x(id-1)
			x2 = nx(2)	!dom(ib)%x(id)
			z1 = nz(1)	!dom(ib)%zc(kd-1)
			z2 = nz(2)	!dom(ib)%zc(kd)
			
			dx1 = x1 - mrx
			dx2 = x2 - mrx
			dz1 = z1 - mrz
			dz2 = z2 - mrz  
			
			
			a1(1,1) = 1; a1(2,1) = dx1; a1(3,1) = dz1
			a1(4,1) = dx1*dx1; a1(5,1) = dz1*dz1; a1(6,1) = dx1*dz1

			a1(1,2) = 1; a1(2,2) = dx2; a1(3,2) = dz1
			a1(4,2) = dx2*dx2; a1(5,2) = dz1*dz1; a1(6,2) = dx2*dz1

			a1(1,3) = 1; a1(2,3) = dx1; a1(3,3) = dz2
			a1(4,3) = dx1*dx1; a1(5,3) = dz2*dz2; a1(6,3) = dx1*dz2

			a1(1,4) = 1; a1(2,4) = dx2; a1(3,4) = dz2
			a1(4,4) = dx2*dx2; a1(5,4) = dz2*dz2; a1(6,4) = dx2*dz2

			a2 = TRANSPOSE(a1)
			b1(1) = q11; b1(2) = q21
			b1(3) = q12; b1(4) = q22
			b2 = matmul(b1,a2)
			a3 = matmul(a1,a2)
			
			
			call cramer_solver(sol,a3,b2,6)
			
			ls_2ndOrder_cramer = sol(1)
			
			!######################################################################
			END FUNCTION ls_2ndOrder_cramer
			!######################################################################



			!######################################################################
			DOUBLE PRECISION FUNCTION l1(nn,nx,nz,uvec,mrx,mrz)
			!######################################################################

			implicit none

			INTEGER, INTENT(IN)::nn
			DOUBLE PRECISION, INTENT(IN):: nx(2), nz(2),uvec(4)
			DOUBLE PRECISION, INTENT(IN):: mrx, mrz
			DOUBLE PRECISION:: ux1,uz1,ux2,uz2
			DOUBLE PRECISION:: x1,z1,x2,z2
			DOUBLE PRECISION:: mirror_ux1, mirror_ux2 
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                !!! LINEAR INTERPOLATION
				! mirror velocity for x = mrx and z = zc(kd) = z1
			!	ux1 = dom(ib)%u(id,jjj,kd)
			!	ux2 = dom(ib)%u(id+1,jjj,kd)
			!	x1 = dom(ib)%x(id)
			!	x2 = dom(ib)%x(id+1)

				! Alternative
			ux1 = uvec(1)	!dom(ib)%u(id,jjj,kd)
			ux2 = uvec(2) 	!dom(ib)%u(id-1,jjj,kd)
			x1 = nx(1) 	!dom(ib)%x(id)
			x2 = nx(2)	!dom(ib)%x(id-1)
			
			mirror_ux1 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)				

			! mirror velocity for x = mrx and z = zc(kd-1) = z2				
			!ux1 = dom(ib)%u(id,jjj,kd-1)
			!ux2 = dom(ib)%u(id+1,jjj,kd-1)

			! Alternative
			ux1 = uvec(3)	!dom(ib)%u(id,jjj,kd-1)
			ux2 = uvec(4)	!dom(ib)%u(id-1,jjj,kd-1)

			mirror_ux2 = ux1 + (ux2-ux1)*(mrx-x1)/(x2-x1)

			! mirror velocity for x = mrx and z = mrz
			uz1 = mirror_ux1
			uz2 = mirror_ux2
			z1 = nz(1)	!dom(ib)%zc(kd)
			z2 = nz(2)	!dom(ib)%zc(kd-1)

			l1 = uz1 + (uz2-uz1)*(mrz-z1)/(z2-z1)


			!######################################################################
			END FUNCTION l1
			!######################################################################


			!######################################################################
			DOUBLE PRECISION FUNCTION cosAngle(x1,z1,x2,z2,x3,z3,l12)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: x1,z1,x2,z2,x3,z3,l12
			DOUBLE PRECISION:: x12,z12, x13, l13, z13

			x12 = x2-x1
			z12 = z2-z1
			x13 = x3-x1
			z13 = z3-z1
			l13 = sqrt(x13**2+z13**2)

			cosAngle = (x12*x13 + z12*z13)/(l12*l13)


			!######################################################################
			END FUNCTION cosAngle
			!######################################################################


			!######################################################################
			INTEGER FUNCTION quadrant(cnx,cnz,cnx2,cnz2,margin)
			!######################################################################

			implicit none

			DOUBLE PRECISION, INTENT(IN):: cnx,cnz,cnx2,cnz2, margin
			INTEGER:: qFlag

										! ( 0, 90 ] First quadrant?
			if ( (cnx2 - cnx) .gt. -margin) then
			if ( (cnz2 - cnz) .gt. margin) then	! Proper way

				qFlag = 1			

			endif
			endif


			! ( 90, 180 ] 2nd quadrant?
			if ( (cnx2 - cnx) .le. -margin) then
			if ( (cnz2 - cnz) .ge. -margin) then

				qFlag = 2

			! End 2nd Quadrant ops
			endif
			endif


			! ( 180, 270 ] 3rd quadrant?
			if ( (cnx2 - cnx) .le. margin) then
			if ( (cnz2 - cnz) .lt. -margin) then

				qFlag = 3

			endif
			endif

			! ( 270, 360 ] 4th quadrant?
			if ( (cnx2 - cnx) .gt. margin) then
			if ( (cnz2 - cnz) .le. margin) then

				qFlag = 4


			endif
			endif		

			quadrant = qFlag

			!######################################################################
			END FUNCTION quadrant
			!######################################################################


!######################################################################		
			END SUBROUTINE get_f
!######################################################################


!##########################################################################
        subroutine du_dv_dw_dh_WENO(ibn)
!##########################################################################
            ! This a modified version of the subroutine rungek_convWENO defined in rungek.for
            ! This lines compute the spatial derivatives of the velocity:
            ! dudx, dudv, dudz
            ! dvdx, dvdv, dvdz
            ! dwdx, dwdv, dwdz

        use vars
        use mpi
	    use multidata
	    use imb
	    implicit none
	    integer, intent(in):: ibn
        integer :: i,j,k
        double precision :: du2dx,dv2dy,dw2dz
        double precision :: duvdx,duvdy,duwdx,duwdz,dvwdy,dvwdz
        double precision :: uijk,vijk,wijk

	!	if (myrank.eq. 0 ) then ! The control is passed down to the master processor
		if(imbinblock_loc(dom_id(ibn)+1).NE.0) THEN	! Filtering out procesors that do not have accesss to the domain where the 
			! markers are located

        call boundu
        call HJ_WENO_dx(1)
        call HJ_WENO_dy(1)
        call HJ_WENO_dz(1)

        !do ibn=1,nbp

           do k=dom(ibn)%ksu,dom(ibn)%keu
              do i=dom(ibn)%isu,dom(ibn)%ieu
				 do j=dom(ibn)%jsu,dom(ibn)%jeu

					if (dom(ibn)%u(i,j,k).gt.0.0) then
						dom(ibn)%dudx(i,j,k) = dom(ibn)%dphi_dxminus(i,j,k)
					else if (dom(ibn)%u(i,j,k).lt.0.0) then
						dom(ibn)%dudx(i,j,k) = dom(ibn)%dphi_dxplus(i,j,k)
					else  
						dom(ibn)%dudx(i,j,k) = 0.0  
					end if
					
					vijk=0.25*(dom(ibn)%v(i,j,k)+dom(ibn)%v(i+1,j,k)+
     &     dom(ibn)%v(i,j-1,k)+dom(ibn)%v(i+1,j-1,k))
					if (vijk.gt.0.0) then
						dom(ibn)%dudy(i,j,k) = dom(ibn)%dphi_dyminus(i,j,k)
					else if (vijk.lt.0.0) then  
						dom(ibn)%dudy(i,j,k) = dom(ibn)%dphi_dyplus(i,j,k)
					else  
						dom(ibn)%dudy(i,j,k) = 0.0   
					end if
					
					wijk=0.25*(dom(ibn)%w(i,j,k)+dom(ibn)%w(i+1,j,k)+
     &     dom(ibn)%w(i,j,k-1)+dom(ibn)%w(i+1,j,k-1))
					if (wijk.gt.0.0) then
						dom(ibn)%dudz(i,j,k) = dom(ibn)%dphi_dzminus(i,j,k)
					else if (wijk.lt.0.0) then 
						dom(ibn)%dudz(i,j,k) = dom(ibn)%dphi_dzplus(i,j,k)
					else 
						dom(ibn)%dudz(i,j,k) = 0.0    
					end if

                 !   du2dx=dom(ibn)%u(i,j,k)*dom(ibn)%dudx(i,j,k)
                 !   duvdy=vijk*dom(ibn)%dudy(i,j,k)
                 !   duwdz=wijk*dom(ibn)%dudz(i,j,k)

  !               dom(ibn)%ustar(i,j,k)=(dom(ibn)%uoo(i,j,k)-
  !   & dt*alfapr*(du2dx+duvdy+duwdz))

                 end do
              end do
           end do
        !end do

        call boundv
        call HJ_WENO_dx(2)
        call HJ_WENO_dy(2)
        call HJ_WENO_dz(2)

        !do ibn=1,nbp

!           do k=dom(ibn)%ksv,dom(ibn)%kev
!              do i=dom(ibn)%isv,dom(ibn)%iev
!				 do j=dom(ibn)%jsv,dom(ibn)%jev
!
!                    uijk=0.25*(dom(ibn)%u(i,j,k)+dom(ibn)%u(i,j+1,k)+
!     &     dom(ibn)%u(i-1,j,k)+dom(ibn)%u(i-1,j+1,k))
!                    if (uijk.gt.0.0) then
!                   dom(ibn)%dvdx(i,j,k) = dom(ibn)%dphi_dxminus(i,j,k)
!                    else if (uijk.lt.0.0) then
!                   dom(ibn)%dvdx(i,j,k) = dom(ibn)%dphi_dxplus(i,j,k)
!                    else  
!                       dom(ibn)%dvdx(i,j,k) = 0.0  
!                    end if             
!
!                    if (dom(ibn)%v(i,j,k).gt.0.0) then
!                    dom(ibn)%dvdy(i,j,k) = dom(ibn)%dphi_dyminus(i,j,k)
!                    else if (dom(ibn)%v(i,j,k).lt.0.0) then  
!                   dom(ibn)%dvdy(i,j,k) = dom(ibn)%dphi_dyplus(i,j,k)
!                    else  
!                       dom(ibn)%dvdy(i,j,k) = 0.0   
!                    end if     
!
!                    wijk=0.25*(dom(ibn)%w(i,j,k)+dom(ibn)%w(i,j+1,k)+
!     &     dom(ibn)%w(i,j,k-1)+dom(ibn)%w(i,j+1,k-1))
!                    if (wijk.gt.0.0) then
!                   dom(ibn)%dvdz(i,j,k) = dom(ibn)%dphi_dzminus(i,j,k)
!                    else if (wijk.lt.0.0) then 
!                   dom(ibn)%dvdz(i,j,k) = dom(ibn)%dphi_dzplus(i,j,k)
!                    else 
!                       dom(ibn)%dvdz(i,j,k) = 0.0    
!                    end if
!
!               !     duvdx=uijk*dom(ibn)%dvdx(i,j,k)
!               !     dv2dy=dom(ibn)%v(i,j,k)*dom(ibn)%dvdy(i,j,k)
!               !     dvwdz=wijk*dom(ibn)%dvdz(i,j,k)
!
!  !               dom(ibn)%vstar(i,j,k)=(dom(ibn)%voo(i,j,k)-
!  !   & dt*alfapr*(duvdx+dv2dy+dvwdz))
!
!                 end do
!              end do
!           end do
!        !end do
!

        call boundw
        call HJ_WENO_dx(3)
        call HJ_WENO_dy(3)
        call HJ_WENO_dz(3)

        !do ibn=1,nbp

           do k=dom(ibn)%ksw,dom(ibn)%kew
              do i=dom(ibn)%isw,dom(ibn)%iew
                 do j=dom(ibn)%jsw,dom(ibn)%jew

                    uijk=0.25*(dom(ibn)%u(i,j,k)+dom(ibn)%u(i,j,k+1)+
     &     dom(ibn)%u(i-1,j,k)+dom(ibn)%u(i-1,j,k+1))
                    if (uijk.gt.0.0) then
                    dom(ibn)%dwdx(i,j,k) = dom(ibn)%dphi_dxminus(i,j,k)
                    else if (uijk.lt.0.0) then
                   dom(ibn)%dwdx(i,j,k) = dom(ibn)%dphi_dxplus(i,j,k)
                    else  
                       dom(ibn)%dwdx(i,j,k) = 0.0  
                    end if             

                    vijk=0.25*(dom(ibn)%v(i,j,k)+dom(ibn)%v(i,j,k+1)+
     &     dom(ibn)%v(i,j-1,k)+dom(ibn)%v(i,j-1,k+1))
                    if (vijk.gt.0.0) then
                   dom(ibn)%dwdy(i,j,k) = dom(ibn)%dphi_dyminus(i,j,k)
                    else if (vijk.lt.0.0) then  
                   dom(ibn)%dwdy(i,j,k) = dom(ibn)%dphi_dyplus(i,j,k)
                    else  
                       dom(ibn)%dwdy(i,j,k) = 0.0   
                    end if     

                    if (dom(ibn)%w(i,j,k).gt.0.0) then
                   dom(ibn)%dwdz(i,j,k) = dom(ibn)%dphi_dzminus(i,j,k)
                    else if (dom(ibn)%w(i,j,k).lt.0.0) then 
                   dom(ibn)%dwdz(i,j,k) = dom(ibn)%dphi_dzplus(i,j,k)
                    else 
                       dom(ibn)%dwdz(i,j,k) = 0.0    
                    end if

                    !duwdx=uijk*dom(ibn)%dwdx(i,j,k)
                    !dvwdy=vijk*dom(ibn)%dwdy(i,j,k)
                    !dw2dz=dom(ibn)%w(i,j,k)*dom(ibn)%dwdz(i,j,k)

  !                  dom(ibn)%wstar(i,j,k)=(dom(ibn)%woo(i,j,k)-
  !   & dt*alfapr*(duwdx+dvwdy+dw2dz))  

                 end do
              end do
           end do

		!end do
		
		endif ! master processor

		return
!######################################################################
        end subroutine du_dv_dw_dh_WENO
!######################################################################

!######################################################################
      SUBROUTINE PartLoc 
!######################################################################
      use vars
      use imb
      use mpi
      use multidata
	  
	  implicit none
      
      INTEGER 	:: M,L,ii,nxdom,nydom,nzdom,tnm,N,nx,ny,nz	  
      DOUBLE PRECISION :: lxdom(idom+1),lydom(jdom+1),lzdom(kdom+1)
	DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::nodex_mas,nodey_mas
	DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::nodez_mas
	INTEGER,ALLOCATABLE,DIMENSION(:)::lag_bod_mas

	! debugging variables
	integer :: missingMarkers
	
		  ! definition of iterators
	  INTEGER :: ib,iii,jjj,kkk,nn, vecID,searchID
	  ! ib: index for subdomain,
	  ! iii : index for cells along the OX direction
	  ! jjj : index for cells along the OX direction
	  ! kkk : index for cells along the OX direction	
	  ! nn : index for nodes belonging to the M-th mody	  
	  ! 
	  INTEGER :: is,ie,js,je,ks,ke,zz
	  INTEGER :: i_n_cells ,j_n_cells,k_n_cells
	  
	  ! Variables for writting to file
	  DOUBLE PRECISION :: as,bs,cs
	  DOUBLE PRECISION :: as2,bs2,cs2
	  DOUBLE PRECISION :: as3,bs3,cs3
	  DOUBLE PRECISION :: ae3,be3,ce3
	  DOUBLE PRECISION :: ae,be,ce	  
	  DOUBLE PRECISION :: cnx,cny,cnz,uc,vc,wc ! Node coordinates and cell velocity components u, v, w
	  INTEGER, ALLOCATABLE, DIMENSION(:) :: matchVec ! vector for checking if a markers has been located in more that 1 fluid cell
	  ! Boundary Margings
	  DOUBLE PRECISION:: dh, margin,dx_l,dy_l,dz_l
	  ! dh : equivalent grid spacing in 3D
	  ! margin: Boundary Margings
	  
	  
       IF(myrank.eq.master)THEN
!Variables used by the master than involve all the markers	
	allocate(lag_bod_mas(maxnodeIBS),nodex_mas(maxnodeIBS))
	allocate(nodey_mas(maxnodeIBS),nodez_mas(maxnodeIBS))
	
	lxdom=0 		; lydom=0 		; lzdom=0
	lxdom(1)=xst 	; lydom(1)=yst 	; lzdom(1)=zst
	do N=2,idom+1
	  lxdom(N)=(xcor(N-2,2)-xcor(N-2,1))+lxdom(N-1)
	enddo
	do N=2,jdom+1
	  lydom(N)=(ycor((N-2)*idom,2)-ycor((N-2)*idom,1))+lydom(N-1)
	enddo
	do N=2,kdom+1
	 lzdom(N)=
     &	 (zcor((N-2)*idom*jdom,2)-zcor((N-2)*idom*jdom,1))+lzdom(N-1)
	enddo

	 imbinblock_loc=0 ; imbinblk=0  	!# Points in each block
	 imb_block=0  				!Block id to which every particle belongs
	 ii=0  ;	tnm=0		
	 nxdom = 0; nydom = 0; nzdom = 0	! ??? Check Why this variables have not been initialized before?????
	do M=1,bodynum  			!Perform this operation to all IB bodies
	    DO L=1,nodes(M)		!Analyze all IB poins of the body.
		ii=ii+1
	  Do nx=1,idom 
	   if( (nodex(M,L)-1.d-11).gt.lxdom(nx) .and. 
     &		(nodex(M,L)-1.d-11).le.lxdom(nx+1) )THEN
		nxdom=nx-1
	 	GOTO 490
	   endif 	
	  Enddo
490	CONTINUE
	  Do ny=1,jdom 
	   if( (nodey(M,L)-1.d-11).gt.lydom(ny) .and. 
     &		(nodey(M,L)-1.d-11).le.lydom(ny+1) )THEN
		nydom=ny-1
	 	GOTO 491
	   endif 	
	  Enddo
491	CONTINUE
	  Do nz=1,kdom 
	   if( (nodez(M,L)-1.d-11).gt.lzdom(nz) .and. 
     &		(nodez(M,L)-1.d-11).le.lzdom(nz+1) )THEN
		nzdom=nz-1
	 	GOTO 492
	   endif 	
	  Enddo
492	CONTINUE
		imb_block(ii)=idom*jdom*nzdom+idom*nydom+nxdom
		imbinblk(imb_block(ii)+1)=imbinblk(imb_block(ii)+1)+1
	    ENDDO
	enddo 

	do L=1,num_domains		!Check in all the domains
	 tnm=tnm+imbinblk(L)
	 missingMarkers = maxnodeIBS - tnm
!	 write(*,*) missingMarkers
	 IF (itime.eq.itime_start .AND. imbinblk(L).ne.0)  
     &	   write(6,*)'Dom,#markrs',L-1,imbinblk(L),tnm
!     &	   write(6,*)'Dom,#markrs',L-1,imbinblk(L),tnm, maxnodeIBS  
	 imbinblock_loc(L)=imbinblk(L) !New variable for all the other MPI
	enddo



	write(*,*) tnm			! Uncomment for not having missing markers
	write(*,*) maxnodeIBS		! Uncomment for not having missing markers
!	write(*,*) missingMarkers


!Warning if some point is not assigned to some domain
	IF(tnm.lt.maxnodeIBS) THEN
!     		write(6,*)'Some Lagrangian are not assigned to a domain!!!CHECK'
		write(*,*) tnm
	ENDIF



	


  	ii=0
	 DO M=1,bodynum
	    DO L=1,nodes(M)
	      ii=ii+1
		imb_block_loc(ii)=imb_block(ii)
		lag_bod_loc(ii)=M 
	      nodex_loc(ii)=nodex(M,L) ; nodey_loc(ii)=nodey(M,L)
	      nodez_loc(ii)=nodez(M,L)

	     IF (itime.eq.itime_start) then !THIS IS DONE ONCE
		R0_loc(ii)=R0(M,L) ; alpha0_loc(ii)=alpha0(M,L)
	     ENDIF 
		rott_loc(ii)=1 	!Moving Lagrangian
		IF(rotating(M).eq..false.)rott_loc(ii)=2  	!Static Lagrangian
	  ENDDO
	 Enddo
	ENDIF !master
	
!Now the properties of the markers owned by each processor is scattered
!We can't use BCAST because then we share all the vectors (+memory)
	IF(itime.eq.itime_start) then
	  call MPI_BCAST(lag_bod_loc,maxnodeIBS,MPI_INTEGER,
     &			master,MPI_COMM_WORLD,ierr)	!# of the body to which the Lag is.
        call MPI_BCAST(alpha0_loc,maxnodeIBS,MPI_DOUBLE_PRECISION,
     &			master,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(R0_loc,maxnodeIBS,MPI_DOUBLE_PRECISION,
     &			master,MPI_COMM_WORLD,ierr)
	ENDIF

        call MPI_BCAST(rott_loc,maxnodeIBS,MPI_INTEGER,
     &			master,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(imbinblock_loc,num_domains,MPI_INTEGER,
     & 		master,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(imb_block_loc,maxnodeIBS,MPI_INTEGER,
     & 		master,MPI_COMM_WORLD,ierr)
	
        call MPI_BCAST(nodex_loc,maxnodeIBS,MPI_DOUBLE_PRECISION,
     & 		master,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(nodey_loc,maxnodeIBS,MPI_DOUBLE_PRECISION,
     &			master,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(nodez_loc,maxnodeIBS,MPI_DOUBLE_PRECISION,
     &			master,MPI_COMM_WORLD,ierr)

	if(myrank.eq.master) then
	 deallocate(nodex_mas,nodey_mas,nodez_mas)
	endif




      RETURN
	  
	  
      END
!######################################################################
      SUBROUTINE Deltah
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      DOUBLE PRECISION :: dh,dhtotal
      INTEGER :: I,J,L,ib,K,nnnmls
	 nnnmls=0
	IF(nnnmls.eq.0) then

	Do ib=1,nbp  !Loop through all the blocks of one processor
       if (imbinblock_loc(dom_id(ib)+1).ne.0) then !IF THERE ARE ANY POINTS IN THE BLOCK AT ALL
      Do L = 1,maxnodeIBS !investigate all the IB points
      	nl=0 ;dhtotal=0.d0
	IF(imb_block_loc(L).EQ.dom_id(ib)) THEN !If the IB point is not in the present block
	IF(rott_loc(L).eq.2) THEN	!If the Lagrangian is dynamic:exit
!NEIGHBOURS FOR THE U-GRID
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%x(i) .ge.(nodex_loc(L)-nxl*dom(ib)%dx) .AND.
     &     dom(ib)%x(i) .lt.(nodex_loc(L)+nxl*dom(ib)%dx)) THEN
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%yc(j).ge.(nodey_loc(L)-nxl*dom(ib)%dy) .AND.
     &     dom(ib)%yc(j).lt.(nodey_loc(L)+nxl*dom(ib)%dy)) THEN
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%zc(k).ge.(nodez_loc(L)-nxl*dom(ib)%dz) .AND.
     &     dom(ib)%zc(k).lt.(nodez_loc(L)+nxl*dom(ib)%dz)) THEN 
!nl indicates the number of the neighbour and dh1 the delta functions value.
	nl=nl+1
 	  dh1_loc(L,nl)=dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%X(I),dom(ib)%YC(J),dom(ib)%ZC(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase) 
!The index of the neighbours number nl to the Lagrangian L are:    
	  I_nr_U(L,nl)=I ;  J_nr_U(L,nl)=J ;  K_nr_U(L,nl)=K
	  dhtotal=dhtotal+dh1_loc(L,nl)
	  if(dhtotal.ge.0.99999) goto 876
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
        dh1_loc(L,nl)=dh1_loc(L,nl)/dhtotal
876	continue       
	kmaxU(L)=nl !# of neighbours of the Lagrangian L
!NEIGHBOURS FOR THE V-GRID
      	nl=0 ;dhtotal=0.d0
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%xc(i).ge.(nodex_loc(L)-nxl*dom(ib)%dx) .AND.
     &     dom(ib)%xc(i).lt.(nodex_loc(L)+nxl*dom(ib)%dx)) THEN
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%y(j) .ge.(nodey_loc(L)-nxl*dom(ib)%dy) .AND.
     &     dom(ib)%y(j) .lt.(nodey_loc(L)+nxl*dom(ib)%dy)) THEN
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%zc(k).ge.(nodez_loc(L)-nxl*dom(ib)%dz) .AND.
     &     dom(ib)%zc(k).lt.(nodez_loc(L)+nxl*dom(ib)%dz) ) THEN 
	nl=nl+1
 	  dh2_loc(L,nl)=dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%XC(I),dom(ib)%Y(J),dom(ib)%ZC(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase)  
	 I_nr_V(L,nl)=I ;  J_nr_V(L,nl)=J ;  K_nr_V(L,nl)=K
	 dhtotal=dhtotal+dh2_loc(L,nl)
	  if(dhtotal.ge.0.99999) goto 877
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
        dh2_loc(L,nl)=dh2_loc(L,nl)/dhtotal
877	continue              
	kmaxV(L)=nl 
!NEIGHBOURS FOR THE W-GRID
      	nl=0 ;dhtotal=0.d0
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%xc(i).ge.(nodex_loc(L)-nxl*dom(ib)%dx) .AND.
     &     dom(ib)%xc(i).lt.(nodex_loc(L)+nxl*dom(ib)%dx) )  THEN 
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%yc(j).ge.(nodey_loc(L)-nxl*dom(ib)%dy) .AND.
     &     dom(ib)%yc(j).lt.(nodey_loc(L)+nxl*dom(ib)%dy) )  THEN 
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%z(k) .ge.(nodez_loc(L)-nxl*dom(ib)%dz) .AND.
     &     dom(ib)%z(k) .lt.(nodez_loc(L)+nxl*dom(ib)%dz) )  THEN 
	nl=nl+1
 	  dh3_loc(L,nl)=dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%XC(I),dom(ib)%YC(J),dom(ib)%Z(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase)  
	 I_nr_W(L,nl)=I ;  J_nr_W(L,nl)=J ;  K_nr_W(L,nl)=K
	 dhtotal=dhtotal+dh3_loc(L,nl)
	  if(dhtotal.ge.0.99999) goto 878
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
        dh3_loc(L,nl)=dh3_loc(L,nl)/dhtotal
878	 continue                     
	kmaxW(L)=nl 	
	ENDIF
	ENDIF
        Enddo
       ENDIF  
      ENDDO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	ELSE !MLS IS USED        
	Do ib=1,nbp  
     	if(myrank.eq.master)	 write(6,*)'Starting MLS in block#',ib
          if (imbinblock_loc(dom_id(ib)+1).eq.0) GOTO 601 !IF THERE ARE NO POINTS IN THE BLOCK
          Do L = 1,maxnodeIBS
	   IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 701 
	   IF(rott_loc(L).ne.2) GOTO 701	!Rotating
	   call ShapeFunction_MLS(1,L,ib)
	   call ShapeFunction_MLS(2,L,ib)
	   call ShapeFunction_MLS(3,L,ib)
701	CONTINUE   
        Enddo
     	if(myrank.eq.master)	 write(6,*)'Ended MLS in block #',ib
       ENDDO	!ib blocks
601	 CONTINUE
	ENDIF	 !Delta functions or MLS

	 call MPI_BARRIER(MPI_COMM_WORLD,IERR)	
!	 if(myrank.eq.master)write(6,*)'Delta functions generated'
      RETURN
	  END


!######################################################################
      SUBROUTINE interpolationF(vec2,vec3,fieldVal)
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      INTEGER :: I,J,K,L,M,ib,nt,nnmls,KK,iii
      DOUBLE PRECISION :: dh,dhtotal
	  DOUBLE PRECISION :: PI,UIB_loc,VIB_loc,WIB_loc,A1,A2,R1,R2,fbeta
	  
	  !interface variables
	  integer,intent(in):: vec2(8)
	  double precision,intent(in)::vec3(3)
      double precision,intent(out)::fieldVal
	  integer:: nn,ll,id,jd,kd,qF,fieldF
      double precision:: mrx,mry,mrz,uf,vf,wf
      

	   nn = vec2(1)	! Node nds(1.5)  	! Node nds(1.5)
	   ib = vec2(2)
	   ll = vec2(3)
	   id = vec2(4)
	   jd = vec2(5)
	   kd = vec2(6)
	   qF = vec2(7)
	   fieldF  = vec2(8) ! fieldFlag for selecting u velocity  ! fieldFlag for selecting u velocity
	   mrx = vec3(1)
	   mry = vec3(2)!dom(ib)%yc(jd)!vec3(2)
	   mrz = vec3(3)

	   
	U_Beta1_loc=0.d0 ; U_Beta2_loc=0.d0 ; U_Beta3_loc=0.d0	!Pablo
	!Do ib=1,nbp

	 ! if (imbinblock_loc(dom_id(ib)+1).ne.0) THEN	! cheking if there is any marker in that the current 
													! processor handling this subdomain need to take care of 

	if (maxnodeIBS.le.100) nt = 1
	if (maxnodeIBS.gt.100) nt = OMP_threads

	call OMP_SET_NUM_THREADS(nt)

	nnmls=2
	IF (nnmls.eq.1) then	! checking deltaF or mls
!!$OMP parallel DEFAULT(SHARED)PRIVATE(I,J,K,L,nl)
!!$OMP DO SCHEDULE(DYNAMIC,50)
	  !Do L = 1,maxnodeIBS
	  L = nn
	  IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 901 	! cheking processor and domain ID???
        IF(rott_loc(L).eq.1 ) then
	  call ShapeFunction_MLS(1,L,ib) !u-velocity
	  call ShapeFunction_MLS(2,L,ib) !v-velocity
	  call ShapeFunction_MLS(3,L,ib) !w-velocity
		ENDIF

		if(fieldF.eq.1) then ! interpolating only u velocities
       Do nl=1,KmaxU(L)
	  I=I_nr_U(L,nl) ;  J=J_nr_U(L,nl) ;  K=K_nr_U(L,nl)
        uf=uf+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)      
	   Enddo 
	  endif

	  if(fieldF.eq.2) then ! interpolating only v velocities
       Do nl=1,KmaxV(L)
        I=I_nr_V(L,nl) ;  J=J_nr_V(L,nl) ;  K=K_nr_V(L,nl)
        vf=vf+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)
	   Enddo
	  endif

	  if(fieldF.eq.1) then ! interpolating only u velocities
       Do nl=1,KmaxW(L)
	 I=I_nr_W(L,nl) ;  J=J_nr_W(L,nl) ;  K=K_nr_W(L,nl)
        wf=wf+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
	   Enddo
	  endif
901	 CONTINUE   
      !Enddo
!!$OMP end DO
!!$OMP END PARALLEL	

	else


!Using delta functions. Interpolation of U-velocities
!!$OMP parallel DEFAULT(SHARED)PRIVATE(I,J,K,L,nl)


	  if(fieldF.eq.1) then ! interpolating only u velocities
!!$OMP DO SCHEDULE(DYNAMIC,50)
	!  Do L = 1,maxnodeIBS	! loop sweeping markers
	L = nn
	 nl=0 
	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
	 IF( rott_loc(L).eq.1 )then
		  !DO I = 1, dom(ib)%ttc_i 
          DO I = id-deps, id+deps 
       IF (dom(ib)%x(i) .ge.(mrx-nxl*dom(ib)%dx) .and.
     &     dom(ib)%x(i) .lt.(mrx+nxl*dom(ib)%dx)) THEN
		   !DO J = 1, dom(ib)%ttc_j
           DO J = jd-deps, jd+deps  
       IF (dom(ib)%yc(j).ge.(mry-nxl*dom(ib)%dy) .and.
     &     dom(ib)%yc(j).lt.(mry+nxl*dom(ib)%dy)) THEN
			!DO K = 1, dom(ib)%ttc_k
            DO K = kd-deps, kd+deps  
       IF (dom(ib)%zc(k).ge.(mrz-nxl*dom(ib)%dz) .and.
     &     dom(ib)%zc(k).lt.(mrz+nxl*dom(ib)%dz)) THEN 
	 nl=nl+1
        dh1_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%X(I),dom(ib)%YC(J),dom(ib)%ZC(K)
     & ,mrx,mry,mrz,yangcase)  
        uf=uf+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)     
        KmaxU(L)=nl ; I_nr_U(L,nl)=I ; J_nr_U(L,nl)=J ; K_nr_U(L,nl)=K    

		if (yangcase.eq.2 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.4 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.7 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.3 .and. nl.ge.64)  GOTO 700
		if (yangcase.eq.6 .and. nl.ge.64)  GOTO 700
		if (yangcase.eq.1 .and. nl.ge.27)  GOTO 700
		if (yangcase.eq.5 .and. nl.ge.27)  GOTO 700
 
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
	   if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'
	   !debug
	   !if (nl.eq.0) then
	   !if((nn.gt.9240).and.(nn.lt.(9240+126))) then
		!write(*,*) "mucx____mucx____mucx____mucx____mucx____mucx"
		!write(6,*) vec2
		!write(6,*) vec3
		!write(6,*) newu
		!return
	   !endif
	   !endif
        
	ELSE
	  Do nl=1,KmaxU(L)
	  I=I_nr_U(L,nl) ;  J=J_nr_U(L,nl) ;  K=K_nr_U(L,nl)
        uf=uf+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)       
  	  Enddo  	 
	 ENDIF
700 	continue
	endif
      !Enddo	! loop sweeping markers
!!$OMP END DO
	  !endif ! u velocities iterpolation

!	  elseif(fieldF.eq.2) then ! interpolating only u velocities
!!!$OMP DO SCHEDULE(DYNAMIC,50)
!	!  Do L = 1,maxnodeIBS
!	L = nn
!	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
!	 nl=0 
!	IF( rott_loc(L).eq.1 )then
!		  !DO I = 1, dom(ib)%ttc_i
!		DO I = id-deps, id+deps 
!       IF (dom(ib)%xc(i).ge.(mrx-nxl*dom(ib)%dx) .and.
!     &     dom(ib)%xc(i).lt.(mrx+nxl*dom(ib)%dx)) then
!		   !DO J = 1, dom(ib)%ttc_j 
!           DO J = jd-deps, jd+deps  
!       IF (dom(ib)%y(j) .ge.(mry-nxl*dom(ib)%dy) .and.
!     &     dom(ib)%y(j) .lt.(mry+nxl*dom(ib)%dy)) then
!			!DO K = 1, dom(ib)%ttc_k
!            DO K = kd-deps, kd+deps 
!       IF (dom(ib)%zc(k).ge.(mrz-nxl*dom(ib)%dz) .and.
!     &     dom(ib)%zc(k).lt.(mrz+nxl*dom(ib)%dz)) then 
!	 nl=nl+1
!        dh2_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
!     &  dom(ib)%XC(I),dom(ib)%Y(J),dom(ib)%ZC(K)
!     & ,mrx,mry,mrz,yangcase) 		!June 2015
!        vf=vf+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)         
!        KmaxV(L)=nl ; I_nr_V(L,nl)=I ; J_nr_V(L,nl)=J ; K_nr_V(L,nl)=K
!
!	if (yangcase.eq.2 .and. nl.ge.125) GOTO 701
!	if (yangcase.eq.4 .and. nl.ge.125) GOTO 701
!	if (yangcase.eq.7 .and. nl.ge.125) GOTO 701
!	if (yangcase.eq.3 .and. nl.ge.64)  GOTO 701
!	if (yangcase.eq.6 .and. nl.ge.64)  GOTO 701
!	if (yangcase.eq.1 .and. nl.ge.27)  GOTO 701
!	if (yangcase.eq.5 .and. nl.ge.27)  GOTO 701
! 
!	    ENDIF
!            END DO
!	   ENDIF
!           END DO
!	  ENDIF
!          END DO
!       if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'         
!	ELSE
!	 Do nl=1,KmaxV(L)
!	  I=I_nr_V(L,nl) ;  J=J_nr_V(L,nl) ;  K=K_nr_V(L,nl)
!        vf=vf+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)
!  	 Enddo
!	ENDIF
!701	continue
!	endif
!      !Enddo
!!!$OMP END DO
!	  endif ! v velocities interpolation
!
	  elseif(fieldF.eq.3) then ! interpolating only u velocities
!!!$OMP DO SCHEDULE(DYNAMIC,50)
	!  Do L = 1,maxnodeIBS
	L = nn
	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
	 nl=0 
	IF( rott_loc(L).eq.1 )then
		  !DO I = 1, dom(ib)%ttc_i
		DO I = id-deps, id+deps 
       IF (dom(ib)%xc(i).ge.(mrx-nxl*dom(ib)%dx) .and.
     &     dom(ib)%xc(i).lt.(mrx+nxl*dom(ib)%dx)) then 
		   !DO J = 1, dom(ib)%ttc_j
           DO J = jd-deps, jd+deps  
       IF (dom(ib)%yc(j).ge.(mry-nxl*dom(ib)%dy) .and.
     &     dom(ib)%yc(j).lt.(mry+nxl*dom(ib)%dy)) then
			!DO K = 1, dom(ib)%ttc_k
            DO K = kd-deps, kd+deps 
       IF (dom(ib)%z(k) .ge.(mrz-nxl*dom(ib)%dz) .and.
     &     dom(ib)%z(k) .lt.(mrz+nxl*dom(ib)%dz)) then
	 nl=nl+1
        dh3_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%XC(I),dom(ib)%YC(J),dom(ib)%Z(K)
     & ,mrx,mry,mrz,yangcase)  		!June 2015
        wf=wf+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
        KmaxW(L)=nl ;  I_nr_W(L,nl)=I ; J_nr_W(L,nl)=J ; K_nr_W(L,nl)=K

	if (yangcase.eq.2 .and. nl.ge.125) GOTO 702		!March 2016
	if (yangcase.eq.4 .and. nl.ge.125) GOTO 702
	if (yangcase.eq.7 .and. nl.ge.125) GOTO 702
	if (yangcase.eq.3 .and. nl.ge.64)  GOTO 702
	if (yangcase.eq.6 .and. nl.ge.64)  GOTO 702
	if (yangcase.eq.1 .and. nl.ge.27)  GOTO 702
	if (yangcase.eq.5 .and. nl.ge.27)  GOTO 702
 
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
        if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'
       ELSE
	  Do nl=1,KmaxW(L)
	  I=I_nr_W(L,nl) ;  J=J_nr_W(L,nl) ;  K=K_nr_W(L,nl)
        wf=wf+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
  	  Enddo
	 ENDIF
702	continue
	endif
      !Enddo
!!!$OMP end DO
	endif ! w velocities interpolation

!!$OMP END PARALLEL	
	  endif	! checking deltaF or mls
	 !ENDIF	! cheking if there is any marker in that the current 
			! processor handling this subdomain need to take care of 
    !Enddo !ib-loop
     
		if(fieldF.eq.1) then
			fieldVal = uf
		elseif(fieldF.eq.2) then
			fieldVal = vf
		elseif(fieldF.eq.3) then
			fieldVal = wf
		endif
		!debug
		!if((nn.gt.9289).and.(nn.lt.9310)) then
			!write(6,*) qF, fieldF, fieldVal
			!write(6,*) vec2(1),vec2(2),vec2(3)
			!write(6,*) vec2(4),vec2(5),vec2(6)
			!write(6,*) vec2(7),vec2(8)
			!write(6,*) vec3(1),vec3(2),vec3(3)
			!write(6,*) "======================="
		!endif
  
     
!######################################################################
	  END SUBROUTINE interpolationF	!imb_openmp
!######################################################################



!######################################################################
      SUBROUTINE imb_openmp
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      INTEGER :: I,J,K,L,M,ib,nt,nnmls,KK,iii
      DOUBLE PRECISION :: dh,dhtotal
      DOUBLE PRECISION :: PI,UIB_loc,VIB_loc,WIB_loc,A1,A2,R1,R2,fbeta

	U_Beta1_loc=0.d0 ; U_Beta2_loc=0.d0 ; U_Beta3_loc=0.d0	!Pablo
	Do ib=1,nbp

      if (imbinblock_loc(dom_id(ib)+1).ne.0) THEN

	if (maxnodeIBS.le.100) nt = 1
	if (maxnodeIBS.gt.100) nt = OMP_threads

	call OMP_SET_NUM_THREADS(nt)

	nnmls=2
	IF (nnmls.eq.1) then
!$OMP parallel DEFAULT(SHARED)PRIVATE(I,J,K,L,nl)
!$OMP DO SCHEDULE(DYNAMIC,50)
      Do L = 1,maxnodeIBS
	  IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 901 
        IF(rott_loc(L).eq.1 ) then
	  call ShapeFunction_MLS(1,L,ib) !u-velocity
	  call ShapeFunction_MLS(2,L,ib) !v-velocity
	  call ShapeFunction_MLS(3,L,ib) !w-velocity
        ENDIF
       Do nl=1,KmaxU(L)
	  I=I_nr_U(L,nl) ;  J=J_nr_U(L,nl) ;  K=K_nr_U(L,nl)
        U_Beta1_loc(L)=U_Beta1_loc(L)+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)      
       Enddo 
       Do nl=1,KmaxV(L)
        I=I_nr_V(L,nl) ;  J=J_nr_V(L,nl) ;  K=K_nr_V(L,nl)
        U_Beta2_loc(L)=U_Beta2_loc(L)+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)
       Enddo
       Do nl=1,KmaxW(L)
	 I=I_nr_W(L,nl) ;  J=J_nr_W(L,nl) ;  K=K_nr_W(L,nl)
        U_Beta3_loc(L)=U_Beta3_loc(L)+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
       Enddo
901	 CONTINUE   
      Enddo
!$OMP end DO
!$OMP END PARALLEL	

	else


!Using delta functions. Interpolation of U-velocities
!$OMP parallel DEFAULT(SHARED)PRIVATE(I,J,K,L,nl)

!$OMP DO SCHEDULE(DYNAMIC,50)
      Do L = 1,maxnodeIBS
	 nl=0 
	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
	 IF( rott_loc(L).eq.1 )then
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%x(i) .ge.(nodex_loc(L)-nxl*dom(ib)%dx) .and.
     &     dom(ib)%x(i) .lt.(nodex_loc(L)+nxl*dom(ib)%dx)) THEN
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%yc(j).ge.(nodey_loc(L)-nxl*dom(ib)%dy) .and.
     &     dom(ib)%yc(j).lt.(nodey_loc(L)+nxl*dom(ib)%dy)) THEN
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%zc(k).ge.(nodez_loc(L)-nxl*dom(ib)%dz) .and.
     &     dom(ib)%zc(k).lt.(nodez_loc(L)+nxl*dom(ib)%dz)) THEN 
	 nl=nl+1
        dh1_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%X(I),dom(ib)%YC(J),dom(ib)%ZC(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase)  
        U_Beta1_loc(L)=U_Beta1_loc(L)+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)     
        KmaxU(L)=nl ; I_nr_U(L,nl)=I ; J_nr_U(L,nl)=J ; K_nr_U(L,nl)=K    

		if (yangcase.eq.2 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.4 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.7 .and. nl.ge.125) GOTO 700
		if (yangcase.eq.3 .and. nl.ge.64)  GOTO 700
		if (yangcase.eq.6 .and. nl.ge.64)  GOTO 700
		if (yangcase.eq.1 .and. nl.ge.27)  GOTO 700
		if (yangcase.eq.5 .and. nl.ge.27)  GOTO 700
 
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
       if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'
        
	ELSE
	  Do nl=1,KmaxU(L)
	  I=I_nr_U(L,nl) ;  J=J_nr_U(L,nl) ;  K=K_nr_U(L,nl)
        U_Beta1_loc(L)=U_Beta1_loc(L)+dom(ib)%USTAR(I,J,K)*dh1_loc(L,nl)       
  	  Enddo  	 
	 ENDIF
700 	continue
	endif
      Enddo
!$OMP END DO

!$OMP DO SCHEDULE(DYNAMIC,50)
      Do L = 1,maxnodeIBS
	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
	 nl=0 
	IF( rott_loc(L).eq.1 )then
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%xc(i).ge.(nodex_loc(L)-nxl*dom(ib)%dx) .and.
     &     dom(ib)%xc(i).lt.(nodex_loc(L)+nxl*dom(ib)%dx)) then
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%y(j) .ge.(nodey_loc(L)-nxl*dom(ib)%dy) .and.
     &     dom(ib)%y(j) .lt.(nodey_loc(L)+nxl*dom(ib)%dy)) then
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%zc(k).ge.(nodez_loc(L)-nxl*dom(ib)%dz) .and.
     &     dom(ib)%zc(k).lt.(nodez_loc(L)+nxl*dom(ib)%dz)) then 
	 nl=nl+1
        dh2_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%XC(I),dom(ib)%Y(J),dom(ib)%ZC(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase) 		!June 2015
        U_Beta2_loc(L)=U_Beta2_loc(L)+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)         
        KmaxV(L)=nl ; I_nr_V(L,nl)=I ; J_nr_V(L,nl)=J ; K_nr_V(L,nl)=K

	if (yangcase.eq.2 .and. nl.ge.125) GOTO 701
	if (yangcase.eq.4 .and. nl.ge.125) GOTO 701
	if (yangcase.eq.7 .and. nl.ge.125) GOTO 701
	if (yangcase.eq.3 .and. nl.ge.64)  GOTO 701
	if (yangcase.eq.6 .and. nl.ge.64)  GOTO 701
	if (yangcase.eq.1 .and. nl.ge.27)  GOTO 701
	if (yangcase.eq.5 .and. nl.ge.27)  GOTO 701
 
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
       if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'         
	ELSE
	 Do nl=1,KmaxV(L)
	  I=I_nr_V(L,nl) ;  J=J_nr_V(L,nl) ;  K=K_nr_V(L,nl)
        U_Beta2_loc(L)=U_Beta2_loc(L)+dom(ib)%VSTAR(I,J,K)*dh2_loc(L,nl)
  	 Enddo
	ENDIF
701	continue
	endif
      Enddo
!$OMP END DO
!$OMP DO SCHEDULE(DYNAMIC,50)
      Do L = 1,maxnodeIBS
	IF(imb_block_loc(L).eq.dom_id(ib)) THEN
	 nl=0 
	IF( rott_loc(L).eq.1 )then
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%xc(i).ge.(nodex_loc(L)-nxl*dom(ib)%dx) .and.
     &     dom(ib)%xc(i).lt.(nodex_loc(L)+nxl*dom(ib)%dx)) then 
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%yc(j).ge.(nodey_loc(L)-nxl*dom(ib)%dy) .and.
     &     dom(ib)%yc(j).lt.(nodey_loc(L)+nxl*dom(ib)%dy)) then
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%z(k) .ge.(nodez_loc(L)-nxl*dom(ib)%dz) .and.
     &     dom(ib)%z(k) .lt.(nodez_loc(L)+nxl*dom(ib)%dz)) then
	 nl=nl+1
        dh3_loc(L,nl)= dh(dom(ib)%dx,dom(ib)%dy,dom(ib)%dz,
     &  dom(ib)%XC(I),dom(ib)%YC(J),dom(ib)%Z(K)
     & ,nodex_loc(L),nodey_loc(L),nodez_loc(L),yangcase)  		!June 2015
        U_Beta3_loc(L)=U_Beta3_loc(L)+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
        KmaxW(L)=nl ;  I_nr_W(L,nl)=I ; J_nr_W(L,nl)=J ; K_nr_W(L,nl)=K

	if (yangcase.eq.2 .and. nl.ge.125) GOTO 702		!March 2016
	if (yangcase.eq.4 .and. nl.ge.125) GOTO 702
	if (yangcase.eq.7 .and. nl.ge.125) GOTO 702
	if (yangcase.eq.3 .and. nl.ge.64)  GOTO 702
	if (yangcase.eq.6 .and. nl.ge.64)  GOTO 702
	if (yangcase.eq.1 .and. nl.ge.27)  GOTO 702
	if (yangcase.eq.5 .and. nl.ge.27)  GOTO 702
 
	    ENDIF
            END DO
	   ENDIF
           END DO
	  ENDIF
          END DO
        if (nl.eq.0) write(6,*)L,'nl is equal to 0!!'
       ELSE
	  Do nl=1,KmaxW(L)
	  I=I_nr_W(L,nl) ;  J=J_nr_W(L,nl) ;  K=K_nr_W(L,nl)
        U_Beta3_loc(L)=U_Beta3_loc(L)+dom(ib)%WSTAR(I,J,K)*dh3_loc(L,nl)
  	  Enddo
	 ENDIF
702	continue
	endif
      Enddo
!$OMP end DO
!$OMP END PARALLEL	
	  endif
	 ENDIF
	Enddo !ib-loop
!#################   SUBROUTINE calfl   #################################
	 FX1_loc = 0.d0     ; FX2_loc = 0.d0	; FX3_loc = 0.d0
 
	DO ib=1,nbp
	IF (imbinblock_loc(dom_id(ib)+1).NE.0) THEN !No points within the block

!$OMP parallel DEFAULT(SHARED)PRIVATE(L)
!$OMP DO SCHEDULE(DYNAMIC,50)
        Do L = 1,maxnodeIBS
	  IF(imb_block_loc(L).EQ.dom_id(ib)) THEN              !REMOVE GOTO
	   UIB_loc = 0.d0; VIB_loc = 0.d0; WIB_loc = 0.d0
		M=lag_bod_loc(L) 

 	  IF (imb_shape(M).eq.5 .and. turax(M).eq.3) THEN	!Pablo 09/2017
		call ActuatorLine(M,L,ib)
	  ELSE
	   IF(ibturbine(M).eq..TRUE.) then 			!If it is a turbine
	    IF (turax(M).eq.1) then			! Vertical Axis Turbine
	      UIB_loc=-radsin(M)*R0_loc(L)*dcos(rads(M)+alpha0_loc(L))
	      VIB_loc=-radsin(M)*R0_loc(L)*dsin(rads(M)+alpha0_loc(L))
	      WIB_loc= 0.d0	
	    ENDIF	     
	    IF (turax(M).eq.2) then 		! Horizontal Axis Turbine
	      UIB_loc= 0.d0			
	      VIB_loc= radsin(M)*R0_loc(L)*dcos(rads(M)+alpha0_loc(L))
	      WIB_loc=-radsin(M)*R0_loc(L)*dsin(rads(M)+alpha0_loc(L))
	    ENDIF	     
	   ENDIF
	    IF (ibturbine(M).eq..FALSE. .AND. imb_shape(M).eq.5
     &			.and. rotating(M).eq..true.) then	! from file but moving
!	      UIB_loc=-radsin(M)*R0_loc(L)*dcos(rads(M)+alpha0_loc(L)) !Pitching airfoil simu
!	      VIB_loc=-radsin(M)*R0_loc(L)*dsin(rads(M)+alpha0_loc(L))
!	      WIB_loc= 0.d0	
!		A1=-radsin(M)*3.1416D0/180.D0*DSIN(0.1983*(CTIME-dt))
!		A2=-radsin(M)*3.1416D0/180.D0*DSIN(0.1983*CTIME)
		R1=R0_loc(L)*DSIN(A1+alpha0_loc(L))
		R2=R0_loc(L)*DSIN(A2+alpha0_loc(L))
		UIB_loc=(R2-R1)/dt

		R1=R0_loc(L)*DCOS(A1+alpha0_loc(L))
		R2=R0_loc(L)*DCOS(A2+alpha0_loc(L))
		VIB_loc=(R2-R1)/dt
		WIB_loc=0.D0
	    ENDIF

        FX1_loc(L)=UIB_loc-U_Beta1_loc(L)	! 
        FX2_loc(L)=VIB_loc-U_Beta2_loc(L)
        FX3_loc(L)=WIB_loc-U_Beta3_loc(L)  
	
	endif!actuator line

	   ENDIF
	  ENDDO  
!$OMP end DO
!$OMP END PARALLEL
                         
	ENDIF
       Enddo !ib-loop	

!Accumulate the forces as MDF can be performed
	   Do L=1,maxnodeIBS
	    FX1NF(L)=FX1_loc(L)+FX1NF(L)
	    FX2NF(L)=FX2_loc(L)+FX2NF(L)
	    FX3NF(L)=FX3_loc(L)+FX3NF(L)
	   ENDDO
!!################   SUBROUTINE distfbeta   ###################
	Do ib=1,nbp
       if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN
!$OMP parallel DEFAULT(SHARED)PRIVATE(L)
!$OMP DO SCHEDULE(DYNAMIC,50)
      Do L = 1,maxnodeIBS
	IF(imb_block_loc(L).EQ.dom_id(ib)) THEN      !REMOVE GOTO
	 Do nl=1,KmaxU(L)
          I=I_nr_U(L,nl) ;  J=J_nr_U(L,nl) ;  K=K_nr_U(L,nl)
          fbeta = FX1_loc(L)*dh1_loc(L,nl)*reddelta(lag_bod_loc(L))    
          dom(ib)%USTAR(I,J,K) = dom(ib)%USTAR(I,J,K) + fbeta 
  	 Enddo	
	 Do nl=1,KmaxV(L)
	   I=I_nr_V(L,nl) ;  J=J_nr_V(L,nl);  K=K_nr_V(L,nl)
          fbeta = FX2_loc(L)*dh2_loc(L,nl)*reddelta(lag_bod_loc(L))   
          dom(ib)%VSTAR(I,J,K) = dom(ib)%VSTAR(I,J,K) + fbeta
  	 Enddo
	 Do nl=1,KmaxW(L)
	   I=I_nr_W(L,nl) ;  J=J_nr_W(L,nl);  K=K_nr_W(L,nl)
          fbeta = FX3_loc(L)*dh3_loc(L,nl)*reddelta(lag_bod_loc(L))      
          dom(ib)%WSTAR(I,J,K) = dom(ib)%WSTAR(I,J,K) + fbeta
  	 Enddo
	ENDIF
      End do 
!$OMP end DO
!$OMP END PARALLEL
	ENDIF
	Enddo !ib-loop 
	
      RETURN
      END
!######################################################################
      SUBROUTINE caldrag
!######################################################################
	use vars
      use multidata
      use imb
      use mpi
      implicit none
      INTEGER :: N,M,L,j,iii,inipts,finpts,totalpoints
      DOUBLE PRECISION::PI,fx_loc,fy_loc,fz_loc,alpharads
      DOUBLE PRECISION::ft_loc,fn_loc,ft2_loc,fn2_loc,M_loc
      DOUBLE PRECISION::sumvel,l1normU,l1normV
	DOUBLE PRECISION,allocatable,dimension(:)::FX1_mas,FX2_mas
	DOUBLE PRECISION,allocatable,dimension(:)::FX3_mas

      allocate (FX1_mas(maxnodeIBS))
      allocate (FX2_mas(maxnodeIBS))
      allocate (FX3_mas(maxnodeIBS))
	FX1_mas =0.d0 ; FX2_mas =0.d0 ; FX3_mas =0.d0 
	FX1_loc =0.d0 ; FX2_loc =0.d0 ; FX3_loc =0.d0 
        
      PI = 4.D0*DATAN(1.D0)
! To gather the forces ordered by the marker global index L
! the forces calculated by the masters are sent to the MASTER PROC
	   Do L=1,maxnodeIBS
	    FX1_loc(L)=FX1NF(L) ;FX2_loc(L)=FX2NF(L) ; FX3_loc(L)=FX3NF(L)
	   ENDDO
        call MPI_ALLREDUCE (FX1_loc,FX1_mas,maxnodeIBS,
     &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
        call MPI_ALLREDUCE (FX2_loc,FX2_mas,maxnodeIBS,
     &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
        call MPI_ALLREDUCE (FX3_loc,FX3_mas,maxnodeIBS,
     &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!Now the forces are transmitted, the resultants are calcualted by the MASTER
	IF (Myrank.EQ.master) THEN
	 FX1=0.d0;FX2=0.d0;FX3=0.d0 
	N=0 
	Do M=1,bodynum
	 Do L=1,nodes(M)
	  N=N+1
	  FX1(M,L)=FX1_mas(N) ; FX2(M,L)=FX2_mas(N) ; FX3(M,L)=FX3_mas(N)
	 enddo
	enddo

	J=0
	Do M = 1,bodynum
	IF (imb_shape(M).eq.5 .and. rotating(M).eq..true.) then
	  Do iii=1,imbnumber(M)
		J=J+1 ; forcefilej=399+J    
 	  fx_loc = 0.d0   ; fy_loc = 0.d0 ; fz_loc = 0.d0 
	  ft_loc = 0.d0	; fn_loc = 0.d0 ; ft2_loc = 0.d0 ; fn2_loc = 0.d0
	  totalpoints=nodes(M)/imbnumber(M)
	  inipts=(iii-1)*totalpoints+1 
	  finpts=iii*totalpoints
	  alpharads= (rads(M)+(iii-1)*2.*PI/imbnumber(M))*180.d0/PI
!!!!!
	if (turax(M).eq.2) then !HATT
	 do L=1,nodes(M)
	  fx_loc=fx_loc+FX1(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt	
	  fy_loc=fy_loc+FX2(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt 	
	  fz_loc=fz_loc+FX3(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt
	  ft_loc=ft_loc+(FX2(M,L)*dcos(rads(M)+alpha0(M,L))-
     &   	FX3(M,L)*dsin(rads(M)+alpha0(M,L)))*R0(M,L)/dt
     &  	*dxm*dym*dzm*reddelta(lag_bod_loc(L)) 	
	 end do
       write(forcefilej,88)alpharads,fx_loc,fy_loc,fz_loc,ft_loc
!!!!!
	ELSE IF (turax(M).eq.1) then 	!VATT
	M_loc=0.d0
	 do L=inipts,finpts
	  fx_loc=fx_loc+FX1(M,L)*dxm*dym*dzm/dt!*reddelta(lag_bod_loc(L))
	  fy_loc=fy_loc+FX2(M,L)*dxm*dym*dzm/dt  	
!	  fz_loc = fz_loc+FX3(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt
	  ft_loc=ft_loc+(FX1(M,L)*dcos(rads(M)+alpha0(M,L))+
     &     FX2(M,L)*dsin(rads(M)+alpha0(M,L)))*R0(M,L)/dt*dxm*dym*dzm
	  ft2_loc=ft2_loc+(FX1(M,L)*dcos(rads(M)+alpha0(M,L))-
     &     FX2(M,L)*dsin(rads(M)+alpha0(M,L)))*R0(M,L)/dt*dxm*dym*dzm
	  fn_loc=fn_loc+(FX1(M,L)*dsin(rads(M)+alpha0(M,L))+
     &     FX2(M,L)*dcos(rads(M)+alpha0(M,L)))/dt*dxm*dym*dzm
	  fn2_loc=fn2_loc+(FX1(M,L)*dsin(rads(M)+alpha0(M,L))-
     &     FX2(M,L)*dcos(rads(M)+alpha0(M,L)))/dt*dxm*dym*dzm
	   M_loc=M_loc+
     &     (FX1(M,L)*(R0(M,L)*dcos(alpha0(M,L))-
     &                R(M)*dcos(rads(M)+(iii-1)*2.*PI/imbnumber(M)))+
     &      FX2(M,L)*(R0(M,L)*dsin(alpha0(M,L))-
     &                R(M)*dsin(rads(M)+(iii-1)*2.*PI/imbnumber(M))))
     &	/dt*dxm*dym*dzm
	 end do

	If(LSELFST(M).eq..true.) SUMtorque_ST(M) = SUMtorque_ST(M)+ ft_loc !Self-starting 07_2017

         write(forcefilej,88)alpharads,fx_loc,fy_loc
     &	,ft_loc,ft2_loc,fn_loc,fn2_loc,M_loc
	ENDIF

	  Enddo !iii-loop

!!!!! Actuator line - Pablo 09/2017
	IF (turax(M).eq.3) then 	!AL
		fx_loc = 0.d0   ; ft_loc = 0.d0 ;forcefilej=400   
	  	alpharads=rads(M)*180.d0/PI 
	 do L=1,nodes(M)
	  fx_loc=fx_loc+ FX1(M,L)*dzm*c_act(L)	
	  ft_loc=ft_loc+(FX2(M,L)*dcos(rads(M)+alpha0(M,L))
     &    		    -FX3(M,L)*dsin(rads(M)+alpha0(M,L)))
     &  		    *R0(M,L)*dzm*c_act(L)
	 end do
	call ActuatorLine_FEM(M)
!For the AL plot the coefficients of thrust and power:
       write(forcefilej,88)alpharads
     &  ,2.d0*fx_loc/(PI*0.135**2*ubulk**2)
     &  ,2.d0*ft_loc*radsin(M)/(PI*0.135**2*ubulk**3)
       write(6,88)alpharads,2.d0*fx_loc/(PI*0.135**2*ubulk**2)
     &  ,2.d0*ft_loc*radsin(M)/(PI*0.135**2*ubulk**3)
	ENDIF
!!!!!
	ELSE
  	  fx_loc = 0.d0   ; fy_loc = 0.d0 ; fz_loc = 0.d0 
	  J=J+1 ;	 forcefilej=399+J    
	  do L=1,nodes(M)	
	   fx_loc=fx_loc+FX1(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt	
	   fy_loc=fy_loc+FX2(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt 	
	   fz_loc=fz_loc+FX3(M,L)*dxm*dym*dzm*reddelta(lag_bod_loc(L))/dt
	  end do
         write(forcefilej,88) CTIME,fx_loc,fy_loc,fz_loc
	ENDIF

       End do !M loop

!l2-norm is calculated in reference to the final velocitiy field
	sumvel=0.d0 ; l1normU=0.d0 ; l1normV=0.d0 ; l2norm=0.d0
	DO M=1,bodynum
	 Do L=1,nodes(M)
    	   sumvel=sumvel+(FX1(M,L)**2+FX2(M,L)**2+FX3(M,L)**2)
	   l1normU=l1normU+(ABS(FX1(M,L)))!+ABS(FX2(M,L)+ABS(FX3(M,L))
	   l1normV=l1normV+(ABS(FX2(M,L)))!+ABS(FX2(M,L)+ABS(FX3(M,L))
 	 End Do
	 l2norm(M)=DSQRT(sumvel/nodes(M)) 
	 l1normU=l1normU/nodes(M)	;  l1normV=l1normV/nodes(M)
	End do
	 if(bodynum.eq.1) write(757,'(4F20.7)')
     &       CTIME,l2norm(1),l1normU,l1normV
	 if(bodynum.ge.2) write(757,'(3F20.7)')CTIME,l2norm(1),l2norm(2)

	ENDIF !master

	deallocate (FX1_mas,FX2_mas,FX3_mas)

   88 FORMAT (14f15.7)
   98 FORMAT (14E15.7)
      RETURN
      END SUBROUTINE caldrag
!#############################################################
      SUBROUTINE imb_pressure
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      INTEGER      :: ib,M,L,I,J,K,strlen,strlen2,Geom_Time1    
      CHARACTER*8  :: char_block,ibnum
      CHARACTER*31 :: gridfile1

	IF (myrank.eq.master) then

	Do M=1,bodynum
	
	IF (rotating(M).eq..TRUE.) then
         write(ibnum,'(I2)') M
           strlen2=LEN(TRIM(ADJUSTL(ibnum)))
           ibnum=REPEAT('0',(2-strlen2))//TRIM(ADJUSTL(ibnum))
           write(char_block,'(I6)') itime
           strlen=LEN(TRIM(ADJUSTL(char_block)))
           char_block=REPEAT('0',(6-strlen))//TRIM(ADJUSTL(char_block))
           gridfile1='PnFint_'//TRIM(ADJUSTL(char_block))//
     &	   '_'//TRIM(ADJUSTL(ibnum))//'.plt'
         open (unit=Geom_Time1, file=gridfile1)
	   write(Geom_Time1,*)'TITLE = "Forces at IB body"'
	   write(Geom_Time1,*)'VARIABLES=x,y,z,Fx,Fy,Fz'
	   write(Geom_Time1,*)'zone i= ',nodes(M),'DATAPACKING = POINT'
	  do L=1,nodes(M)
	   write (Geom_Time1,89) nodex(M,L),nodey(M,L),nodez(M,L),
     &  FX1(M,L)*dxm*dym*dzm*reddelta(M)/dt*1000.d0,
     &  FX2(M,L)*dxm*dym*dzm*reddelta(M)/dt*1000.d0,
     &  FX3(M,L)*dxm*dym*dzm*reddelta(M)/dt*1000.d0
	  enddo
	 close(Geom_Time1)
	
	ENDIF !rotating

	Enddo !M

	ENDIF

   89 FORMAT (17e14.5)
        RETURN
		END SUBROUTINE	
!#############################################################
      SUBROUTINE ghostCell_forces
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      INTEGER      :: ib,M,L,I,J,K,strlen,strlen2,Geom_Time1   
      INTEGER:: filegh 
      DOUBLE PRECISION:: f1(3),pf1(3),shf1(3)
      CHARACTER*8  :: char_block,ibnum
      CHARACTER*31 :: gridfile2, gridfile
!  call MPI_ALLREDUCE (f1,3,
! &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
!  call MPI_ALLREDUCE (pf1,3,
! &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
!  call MPI_ALLREDUCE (shf1,3,
! &      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
      do ib = 1, nbp
       if(imbinblock_loc(dom_id(ib)+1).NE.0) THEN
           IF(imb_block_loc(1).eq.dom_id(ib)) then
       !IF (myrank.eq.master) then ! The master procesor takes controls
	   !
        ! File for keeping track of the forces at play in the ghost cell method
        gridfile = 'F_gh_'//TRIM(ADJUSTL('01'))//'.dat'
        filegh = 31
		open (unit=filegh, file=gridfile)
		if (itime.eq.itime_start) then
			write (filegh,*)'Variables=CTIME,Fx,Fy,Fz'
		endif
        !
        ! obtaining pressure force around the body
        call pressureProbe(pf1)
        call shearStressProbe(shf1)
       ! call pressureProbe(p1)
       ! call shearStressProbe(sh1)
		!
		!
		!
      f1(1) = pf1(1) + shf1(1)
      f1(2) = pf1(2) + shf1(2)
      f1(3) = pf1(3) + shf1(3)
      write(filegh,87) CTIME,f1(1),f1(2),f1(3),
     & 		pf1(1),pf1(2),pf1(3),shf1(1),shf1(2),shf1(3)
      		!
     		!tf1(1) = p1(1) + sh1(1)
     		!tf1(2) = p1(2) + sh1(2)
     		!tf1(3) = p1(3) + sh1(3)
     		!write(filegh,87) CTIME,tf1(1),tf1(2),tf1(3),
     		!& p1(1),p1(2),p1(3),sh1(1),sh1(2),sh1(3)
          endif
       endif
      enddo
!ENDIF ! End master processor

! csv format
87      format(1x, *(g0, ",")) 
      RETURN
!#############################################################
		END SUBROUTINE	
!#############################################################
      SUBROUTINE imb_FEM
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      INTEGER          :: M,L,K,numblades  
      DOUBLE PRECISION :: dh,alpharads,PI,x1,x2,x3,Rhub
      DOUBLE PRECISION :: Mxtot(3),Mqtot(3),Mzytot(3),Mzxtot(3)
	DOUBLE PRECISION,allocatable,dimension(:)::Mx,Mq,Tx,Tq
	DOUBLE PRECISION,allocatable,dimension(:)::R0_x,R0_y,R0_z

	IF (myrank.eq.master) then
      PI = 4.D0*DATAN(1.D0)
	Do M=1,1!bodynum
	 numblades=3
	  if(itime.eq.itime_start+1) then
         open (unit=1414, file='FEM_1.dat')
	   write(1414,*)'TITLE = "Forces at IB. Fx(kN), Mom (Nm)"'
	   write(1414,*)'VARIABLES=Deg,X1,X2,X3',
     &  ',BR1,BR2,BR3,BT1,BT2,BT3,TX1,TX2,TX3,TQ1,TQ2,TQ3'
	  endif

!Distances of each marker
	 allocate(R0_y(nodes(M)),R0_z(nodes(M)),R0_x(nodes(M)))
	   Rhub=0.0475d0 ; R0_x=0.d0 ; R0_y=0.d0 ; R0_z=0.d0 ;
	   do L=1,nodes(M)/numblades
!		R0_z(L)= ABS(R0(M,L)*cos(alpha0(M,L)))-Rhub	!Always>0 
		R0_z(L)= R0(M,L)-Rhub	!Pablo 07_2017
		R0_y(L)= R0(M,L)*sin(alpha0(M,L))
		R0_x(L)=nodexlocal(M,L)-Rhub-0.035*0.25-0.0048525

	 if(R0_z(L).le.0.d0) write(6,*)'FEM Ro_z',L,'Very small',R0_z(L)
	   enddo
	   do L=1,nodes(M)/numblades
		R0_x(L+nodes(M)/numblades)=R0_x(L) 
		R0_x(L+2*nodes(M)/numblades)=R0_x(L)
		R0_y(L+nodes(M)/numblades)=R0_y(L) 
		R0_y(L+2*nodes(M)/numblades)=R0_y(L)
		R0_z(L+nodes(M)/numblades)=R0_z(L) 
		R0_z(L+2*nodes(M)/numblades)=R0_z(L)	
	   enddo

	 allocate(Mx(nodes(M)),Tx(nodes(M)),Tq(nodes(M)))
	 allocate(Mq(nodes(M)))

	 Mx=0.d0 ; Mq=0.d0 ; Tx=0.d0 ; Tq=0.d0 
	 Mxtot=0.d0 ; Mqtot=0.d0 ; Mzytot=0.d0 ; Mzxtot=0.d0
	 x1=0.d0 ; x2=0.d0 ; x3=0.d0 
!Thrust produced at each blade:
	  do L=1,nodes(M)/numblades
	   x1=x1+FX1(M,L)*dxm*dym*dzm/dt*1000.d0
	   x2=x2+FX1(M,L+1*nodes(M)/numblades)*dxm*dym*dzm/dt*1000.d0
	   x3=x3+FX1(M,L+2*nodes(M)/numblades)*dxm*dym*dzm/dt*1000.d0
	  enddo

!Bending moments:
!Flapwise bending moment:
	  do L=1,nodes(M)
	   Mx(L)=FX1(M,L)*R0_z(L)*dxm*dym*dzm*reddelta(M)/dt*1000.d0
	  enddo
	  do k=1,numblades
	    do L=1,nodes(M)/numblades
	 	Mxtot(k)=Mxtot(k)+Mx(L+nodes(M)/numblades*(k-1))
	    enddo
	  enddo

!Edgewise or radial bending moment:
	  do L=1,nodes(M)
	   Mq(L)=(FX2(M,L)*dcos(rads(M)+alpha0(M,L))-
     &   	FX3(M,L)*dsin(rads(M)+alpha0(M,L)))*R0_z(L)
     &      *dxm*dym*dzm*reddelta(M)/dt*1000.d0
	  enddo
	  do k=1,numblades
	    do L=1,nodes(M)/numblades
		Mqtot(k)=Mqtot(k)+Mq(L+nodes(M)/numblades*(k-1))
	    enddo
	  enddo

!Torsional moments:
	  do L=1,nodes(M)
	   Tx(L)=(FX1(M,L)*dxm*dym*dzm*reddelta(M)/dt)*R0_y(L)*1000.d0
	   Tq(L)=(FX2(M,L)*dcos(rads(M)+alpha0(M,L))-
     &   	    FX3(M,L)*dsin(rads(M)+alpha0(M,L)))
     &          *dxm*dym*dzm*reddelta(M)/dt*R0_x(L)*1000.d0
	  enddo
	 do k=1,numblades
	    do L=1,nodes(M)/numblades
	 	Mzxtot(k)=Mzxtot(k)+Tx(L+nodes(M)/numblades*(k-1))
		Mzytot(k)=Mzytot(k)+Tq(L+nodes(M)/numblades*(k-1))
	    enddo
	 enddo

	  alpharads=rads(M)*180.d0/PI

	  write (1414,89)alpharads,x1,x2,x3,
     &  Mxtot(1),Mxtot(2),Mxtot(3),Mqtot(1),Mqtot(2),Mqtot(3),
     &  Mzxtot(1),Mzxtot(2),Mzxtot(3),Mzytot(1),Mzytot(2),Mzytot(3)
	
	 deallocate(Mx,Mq,Tx,Tq,R0_x,R0_y,R0_z)
	  
	Enddo !M
	ENDIF

   89 FORMAT (16e15.5)
        RETURN
        END SUBROUTINE	
!#############################################################
      SUBROUTINE imb_FEM_oneblade
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
	INTEGER,parameter	:: numsections=5,numblades=3
      INTEGER          :: M,L,K 
      DOUBLE PRECISION :: alpharads,Rhub,PI
      DOUBLE PRECISION :: fx,fx_tot,ft,ft_tot,Mx,Mq,Mx_tot,Mq_tot
	DOUBLE PRECISION,dimension(numsections)::Mxtot,Mqtot
	DOUBLE PRECISION,dimension(numsections)::Xtot,Qtot

	IF (myrank.eq.master) then
      PI = 4.D0*DATAN(1.D0)

	 Do M=1,1!bodynum

	 if(itime.eq.itime_start+1) then
	  if (M.eq.1) then
         open (unit=1414, file='FEM_1.dat')
	   write(1414,*)'TITLE = "Forces at IB#1. Fx(kN), Mom (Nm)"'
	   write(1414,*)'VARIABLES=Deg,T1,T2,T3,T4,T5,Q1,Q2,Q3,Q4,Q5,',
     &  'MX1,MX2,MX3,MX4,MX5,MQ1,MQ2,MQ3,MQ4,MQ5'
	  else
         open (unit=1415, file='FEM_2.dat')
	   write(1415,*)'TITLE = "Forces at IB#2. Fx(kN), Mom (Nm)"'
	   write(1415,*)'VARIABLES=Deg,T1,T2,T3,T4,T5,Q1,Q2,Q3,Q4,Q5,',
     &  'MX1,MX2,MX3,MX4,MX5,MQ1,MQ2,MQ3,MQ4,MQ5'
	  endif
	 endif
		Rhub=0.0500d0 

	 Mx=0.d0 ; Mq=0.d0 ; Mx_tot=0.d0 ; Mq_tot=0.d0
       fx=0.d0 ; ft=0.d0 ; fx_tot=0.d0 ; ft_tot=0.d0
	 Mxtot=0.d0 ; Mqtot=0.d0 ; Xtot=0.d0 ; Qtot=0.d0

!Thrust produced at each blade:
	 do L=1,nodes(M)/numblades
         fx=FX1(M,L)*dxm*dym*dzm*reddelta(1)/dt*1000.d0
         fx_tot=fx_tot+fx
           if (L.ge.1 .and. L.lt.nodes(M)/numblades/numsections)
     &     Xtot(1)=Xtot(1)+fx

           if     (L.ge.nodes(M)/numblades*1/numsections 
     &       .and. L.lt.nodes(M)/numblades*2/numsections)
     &     Xtot(2)=Xtot(2)+fx

           if     (L.ge.nodes(M)/numblades*2/numsections 
     &       .and. L.lt.nodes(M)/numblades*3/numsections) 
     &     Xtot(3)=Xtot(3)+fx

           if     (L.ge.nodes(M)/numblades*3/numsections 
     &       .and. L.lt.nodes(M)/numblades*4/numsections) 
     &     Xtot(4)=Xtot(4)+fx

           if     (L.ge.nodes(M)/numblades*4/numsections 
     &       .and. L.le.nodes(M)/numblades*5/numsections) 
     &     Xtot(5)=Xtot(5)+fx

	 enddo

!Torque produced at each blade:
         do L=1,nodes(M)/numblades
          ft=(FX2(M,L)*dcos(rads(M)+alpha0(M,L))-
     &       FX3(M,L)*dsin(rads(M)+alpha0(M,L)))*R0(M,L)/dt
     &       *dxm*dym*dzm*reddelta(lag_bod_loc(L))*1000.d0   
          ft_tot=ft_tot+ft
           if (L.ge.1 .and. L.lt.nodes(M)/numblades/numsections)
     &     Qtot(1)=Qtot(1)+ft

           if  (L.ge.nodes(M)/numblades*1/numsections 
     &    .and. L.lt.nodes(M)/numblades*2/numsections)
     &    Qtot(2)=Qtot(2)+ft

           if  (L.ge.nodes(M)/numblades*2/numsections 
     &    .and. L.lt.nodes(M)/numblades*3/numsections)
     &    Qtot(3)=Qtot(3)+ft

           if  (L.ge.nodes(M)/numblades*3/numsections 
     &    .and. L.lt.nodes(M)/numblades*4/numsections)
     &    Qtot(4)=Qtot(4)+ft

           if  (L.ge.nodes(M)/numblades*4/numsections 
     &    .and. L.le.nodes(M)/numblades*5/numsections)
     &    Qtot(5)=Qtot(5)+ft
         enddo


!Flapwise bending moment:
         do L=1,nodes(M)/numblades
	    Mx=FX1(M,L)*(R0(M,L)-Rhub)*dxm*dym*dzm*reddelta(M)/dt*1000.d0
          Mx_tot=Mx_tot+Mx

           if (L.ge.1 .and. L.lt.nodes(M)/numblades/numsections)
     &    Mxtot(1)=Mxtot(1)+Mx

           if  (L.ge.nodes(M)/numblades*1/numsections 
     &    .and. L.lt.nodes(M)/numblades*2/numsections)
     &    Mxtot(2)=Mxtot(2)+Mx

           if  (L.ge.nodes(M)/numblades*2/numsections 
     &    .and. L.lt.nodes(M)/numblades*3/numsections)
     &    Mxtot(3)=Mxtot(3)+Mx

           if  (L.ge.nodes(M)/numblades*3/numsections 
     &    .and. L.lt.nodes(M)/numblades*4/numsections)
     &    Mxtot(4)=Mxtot(4)+Mx

           if  (L.ge.nodes(M)/numblades*4/numsections 
     &    .and. L.le.nodes(M)/numblades*5/numsections)
     &    Mxtot(5)=Mxtot(5)+Mx
         enddo

!Edgewise or radial bending moment:
         do L=1,nodes(M)/numblades
	    Mq=(FX2(M,L)*dcos(rads(M)+alpha0(M,L))-
     &   	  FX3(M,L)*dsin(rads(M)+alpha0(M,L)))*(R0(M,L)-Rhub)
     &        *dxm*dym*dzm*reddelta(M)/dt*1000.d0
          Mq_tot=Mq_tot+Mq

           if (L.ge.1 .and. L.lt.nodes(M)/numblades/numsections)
     &    Mqtot(1)=Mqtot(1)+Mq

           if  (L.ge.nodes(M)/numblades*1/numsections 
     &    .and. L.lt.nodes(M)/numblades*2/numsections)
     &    Mqtot(2)=Mqtot(2)+Mq

           if  (L.ge.nodes(M)/numblades*2/numsections 
     &    .and. L.lt.nodes(M)/numblades*3/numsections)
     &    Mqtot(3)=Mqtot(3)+Mq

           if  (L.ge.nodes(M)/numblades*3/numsections 
     &    .and. L.lt.nodes(M)/numblades*4/numsections)
     &    Mqtot(4)=Mqtot(4)+Mq

           if  (L.ge.nodes(M)/numblades*4/numsections 
     &    .and. L.le.nodes(M)/numblades*5/numsections)
     &    Mqtot(5)=Mqtot(5)+Mq
         enddo


	  alpharads=DABS(rads(M))*180.d0/PI

	 if (M.eq.1) then
	  write (1414,89)alpharads,Xtot(:),Qtot(:),Mxtot(:),Mqtot(:)
	 else
	  write (1415,89)alpharads,Xtot(:),Qtot(:),Mxtot(:),Mqtot(:)
	 endif

	Enddo !M
	ENDIF

   89 FORMAT (1f15.5,25e15.6)
        RETURN
        END SUBROUTINE	
!######################################################################
      SUBROUTINE imb_vel_to_zero
!######################################################################
      use vars
      use mpi
      use multidata
      use imb
      implicit none
      DOUBLE PRECISION :: dh,umin,xmax,xmin,ymax,ymin,zmax,zmin
      INTEGER :: I,J,K,L,ib

	xmax=0.d0;  xmin=10000.d0  ;ymax=0.d0;  ymin=10000.d0   
	zmax=0.d0;  zmin=10000.d0   

	umin=1.d-0
	
	Do ib=1,nbp  !Loop through all the blocks of one processor

       if (imbinblock_loc(dom_id(ib)+1).eq.0) GOTO 600 !IF THERE ARE NO POINTS IN THE BLOCK

      Do L = 1,maxnodeIBS !investigate all the IB points
	IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 700 !If the IB point is not in the present block
	xmax=max(xmax,nodex_loc(L)) ;	xmin=min(xmin,nodex_loc(L))
	ymax=max(ymax,nodey_loc(L)) ;	ymin=min(ymin,nodey_loc(L))
	zmax=max(zmax,nodez_loc(L)) ;	zmin=min(zmin,nodez_loc(L))
700 	CONTINUE
       Enddo !L

      Do L = 1,maxnodeIBS !investigate all the IB points
	IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 705 !If the IB point is not in the present block
!NEIGHBOURS FOR THE U-GRID
          DO I = 1, dom(ib)%ttc_i 
       IF (dom(ib)%xc(i).ge.xmin .and. dom(ib)%xc(i) .le.xmax) THEN
           DO J = 1, dom(ib)%ttc_j 
       IF (dom(ib)%yc(j).ge.ymin .and. dom(ib)%yc(j) .le.ymax) THEN
            DO K = 1, dom(ib)%ttc_k 
       IF (dom(ib)%zc(k).ge.zmin .and. dom(ib)%zc(k) .le.zmax) THEN
!nl indicates the number of the neighbour and dh1 the delta functions value.
!The index of the neighbours number nl to the Lagrangian L are:    
	   dom(ib)%U(I,J,K)=umin ; dom(ib)%V(I,J,K)=umin
	   dom(ib)%W(I,J,K)=umin
	ENDIF
            END DO
	ENDIF
           END DO
	ENDIF
          END DO
705 	CONTINUE
       Enddo !L

!      Do L = 1,maxnodeIBS !investigate all the IB points
!	IF(imb_block_loc(L).ne.dom_id(ib)) GOTO 700 !If the IB point is not in the present block
!NEIGHBOURS FOR THE U-GRID
!          DO I = 1, dom(ib)%ttc_i 
!       IF (dom(ib)%xc(i) .gt.(nodex_loc(L)+nxl*dom(ib)%dx) .or.
!     &     dom(ib)%xc(i) .lt.(nodex_loc(L)-nxl*dom(ib)%dx)) GOTO 210
!           DO J = 1, dom(ib)%ttc_j 
!       IF (dom(ib)%yc(j).gt.(nodey_loc(L)+nxl*dom(ib)%dy) .or.
!     &     dom(ib)%yc(j).lt.(nodey_loc(L)-nxl*dom(ib)%dy)) GOTO 211
!            DO K = 1, dom(ib)%ttc_k 
!       IF (dom(ib)%zc(k).gt.(nodez_loc(L)+nxl*dom(ib)%dz) .or.
!     &     dom(ib)%zc(k).lt.(nodez_loc(L)-nxl*dom(ib)%dz)) GOTO 212 
!nl indicates the number of the neighbour and dh1 the delta functions value.
!The index of the neighbours number nl to the Lagrangian L are:    
!	   dom(ib)%U(I,J,K)=umin
!	   dom(ib)%V(I,J,K)=umin
!	   dom(ib)%U(I,J,K)=umin
!212         CONTINUE
!            END DO
!211         CONTINUE
!           END DO
!210         CONTINUE
!          END DO
!700 	CONTINUE
!       Enddo !L
600	CONTINUE   
	Enddo !ib
      RETURN
      END
!#############################################################
      SUBROUTINE imb_averaging
!#############################################################
      use vars
      use multidata
      use imb
      use mpi
      implicit none
      double precision    :: facp1,facm1,facp2,facm2
      INTEGER      :: ib,M,L,I,J,K,strlen,strlen2,Geom_Time1    
      CHARACTER*8  :: char_block,ibnum
      CHARACTER*31 :: gridfile1

	IF (myrank.eq.master) then

	
!.....For first order moments
        if (ctime.ge.t_start_averaging1) then
           facp1 = 1./( ((ctime-t_start_averaging1)/dt) + 1)
        else
           facp1 = 1.
        endif
           facm1 = 1. - facp1
!.....For second order moments
        if (ctime.ge.t_start_averaging2) then
           facp2 = 1./( ((ctime-t_start_averaging2)/dt) + 1)
        else
           facp2 = 1.
        endif
           facm2 = 1. - facp2

	Do M=1,bodynum ; do L=1,nodes(M)
	   FX1M(M,L)=facm1*FX1M(M,L)+facp1*FX1(M,L)
	   FX2M(M,L)=facm1*FX2M(M,L)+facp1*FX2(M,L)
	   FX3M(M,L)=facm1*FX3M(M,L)+facp1*FX3(M,L)
	ENDDO; enddo

! Write out the mean values
      if (mod(itime,n_out).eq.0) then
	Do M=1,bodynum

         write(ibnum,'(I2)') M
           strlen2=LEN(TRIM(ADJUSTL(ibnum)))
           ibnum=REPEAT('0',(2-strlen2))//TRIM(ADJUSTL(ibnum))
           write(char_block,'(I6)') itime
           strlen=LEN(TRIM(ADJUSTL(char_block)))
           char_block=REPEAT('0',(6-strlen))//TRIM(ADJUSTL(char_block))
           gridfile1='PnFmean_'//TRIM(ADJUSTL(char_block))//
     &	   '_'//TRIM(ADJUSTL(ibnum))//'.plt'
         open (unit=Geom_Time1, file=gridfile1)
	   write(Geom_Time1,*)'TITLE = "Mean Forces at IBs"'
	   write(Geom_Time1,*)'VARIABLES=x,y,z,FxM,FyM,FzM'
	   write(Geom_Time1,*)'zone i= ',nodes(M),'DATAPACKING = POINT'
	  do L=1,nodes(M)
	   write (Geom_Time1,89) nodex(M,L),nodey(M,L),nodez(M,L),
     & 	FX1M(M,L)*dxm*dym*dzm*1000.D0/dt,
     &  	FX2M(M,L)*dxm*dym*dzm*1000.D0/dt,
     &  	FX3M(M,L)*dxm*dym*dzm*1000.D0/dt
	  enddo
	 close(Geom_Time1)
	Enddo !M

	endif

	ENDIF !master

   89 FORMAT (17e14.5)
        RETURN
        END SUBROUTINE	
!######################################################################
      SUBROUTINE move_ST
!######################################################################
      use vars
      use imb
      use mpi
      implicit none
      DOUBLE PRECISION    :: Tgen,Tfric,Initial_time,massI
	INTEGER :: STfilej,m

      IF (Myrank.ne.master) RETURN

	Initial_time=0.01d0  !Develop flow field
	massI=2.686d-3      !kg m^2

	Do M=1,bodynum
		Tgen  = 0.0018*radsin(M)+0.199  	!Parameters from Maitre et al 2013
		Tfric = 0.d0 

	acc_ST(M)=-(SUMtorque_ST(M) - (Tfric+Tgen))/ massI

      IF (CTIME .le. Initial_time) acc_ST(M)=0.d0

	radsin(M)= radsin(M) + acc_ST(M)*dt
	rads(M)  = rads(M)   + radsin(M)*dt

      write(6,*)'Ang,Vel,Q',rads(M),radsin(M),SUMtorque_ST(M)
	STfilej=5452+M
      write(STfilej,88) 
     &   ctime,acc_ST(M),radsin(M),rads(M),SUMtorque_ST(M)

	enddo !M
   88 FORMAT (1f12.6,5e15.7)
      RETURN
      END SUBROUTINE 
